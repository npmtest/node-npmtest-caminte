{"/home/travis/build/npmtest/node-npmtest-caminte/test.js":"/* istanbul instrument in package npmtest_caminte */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-caminte/lib.npmtest_caminte.js":"/* istanbul instrument in package npmtest_caminte */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_caminte = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_caminte = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-caminte/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-caminte && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_caminte */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_caminte\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_caminte.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_caminte.rollup.js'] =\n            local.assetsDict['/assets.npmtest_caminte.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_caminte.__dirname + '/lib.npmtest_caminte.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/index.js":"/**\n * Module dependencies\n */\nvar schema = require('./lib/schema');\nvar pkg = require('./package');\nvar abc = require('./lib/abstract-class');\nvar vld = require('./lib/validatable');\nvar Schema = schema.Schema;\n\nexports.schema = {models:{}};\nexports.Schema = Schema;\nexports.AbstractClass = abc.AbstractClass;\nexports.Validatable = vld.Validatable;\nexports.__defineGetter__('BaseSQL', function () {\n    return require('./lib/sql');\n});\n\nexports.init = function (trinte) {\n    if (global.trinte) {\n        global.trinte.orm = exports;\n    } else {\n        trinte.orm = {Schema: exports.Schema, AbstractClass: exports.AbstractClass};\n    }\n};\n\nexports.model = function (name){\n    return this.schema.models[name.toLowerCase()];\n};\n\nexports.version = pkg.version;\n\nexports.__defineGetter__('test', function () {\n    return require('./tmp/tests/common_test');\n});\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/schema.js":"/**\r\n * Module dependencies\r\n */\r\nvar utils = require('./utils');\r\nvar ainst = require('./abstract-class');\r\nvar AbstractClass = ainst.AbstractClass;\r\nvar getState = utils.getState;\r\nvar util = require('util');\r\nvar path = require('path');\r\nvar events = require('events');\r\nvar fs = require('fs');\r\nvar existsSync = fs.existsSync || path.existsSync;\r\n\r\n/**\r\n * Export public API\r\n */\r\nexports.Schema = Schema;\r\n\r\n/**\r\n * Helpers\r\n */\r\nvar slice = Array.prototype.slice;\r\n\r\n/**\r\n * Schema - adapter-specific classes factory.\r\n *\r\n * All classes in single schema shares same adapter type and\r\n * one database connection\r\n *\r\n * @param name - type of schema adapter (mysql, mongoose, sequelize, redis)\r\n * @param settings - any database-specific settings which we need to\r\n * establish connection (of course it depends on specific adapter)\r\n *\r\n * - host\r\n * - port\r\n * - username\r\n * - password\r\n * - database\r\n * - debug {Boolean} = false\r\n *\r\n * @example Schema creation, waiting for connection callback\r\n * ```\r\n * var schema = new Schema('mysql', { database: 'myapp_test' });\r\n * schema.define(...);\r\n * schema.on('connected', function () {\r\n *     // work with database\r\n * });\r\n * ```\r\n */\r\nfunction Schema(name, settings) {\r\n    var schema = this;\r\n\r\n    name = name ? name.toLowerCase() : \"\";\r\n    switch (name) {\r\n        case 'sqlite':\r\n            name = 'sqlite3';\r\n            break;\r\n        case 'mysqldb':\r\n        case 'mariadb':\r\n            name = 'mysql';\r\n            break;\r\n        case 'mongo':\r\n            name = 'mongodb';\r\n            break;\r\n        case 'couchdb':\r\n        case 'couch':\r\n            name = 'nano';\r\n            break;\r\n        case 'rethinkdb':\r\n        case 'rethink':\r\n            name = 'rethinkdb';\r\n            break;\r\n    }\r\n\r\n    // just save everything we get\r\n    schema.name = name;\r\n    schema.settings = settings;\r\n\r\n    // Disconnected by default\r\n    schema.connected = false;\r\n\r\n    // create blank models pool\r\n    schema.models = {};\r\n    schema.definitions = {};\r\n\r\n    // define schema types\r\n    schema.Text = function Text() {\r\n    };\r\n    schema.JSON = schema.Json = function JSON() {\r\n    };\r\n    schema.Float = function Float() {\r\n    };\r\n    schema.Real = schema.Double = function Real() {\r\n    };\r\n    schema.Int = schema.Integer = function Integer() {\r\n    };\r\n    schema.UUID = schema.Uuid = function UUID() {\r\n    };\r\n    schema.TimeUUID = schema.TimeUuid = function TimeUUID() {\r\n    };\r\n    schema.CounterColumn = function CounterColumn() {\r\n    };\r\n    schema.Blob = schema.Bytes = function Blob() {\r\n    };\r\n\r\n    schema.Date = schema.Timestamp = Date;\r\n    schema.Boolean = schema.Tinyint = Boolean;\r\n    schema.Number = Number;\r\n    schema.String = schema.Varchar = String;\r\n    // and initialize schema using adapter\r\n    // this is only one initialization entry point of adapter\r\n    // this module should define `adapter` member of `this` (schema)\r\n    var adapter;\r\n    if (typeof name === 'object') {\r\n        adapter = name;\r\n        schema.name = adapter.name;\r\n    } else if (name.match(/^\\//)) {\r\n        // try absolute path\r\n        adapter = require(name);\r\n    } else if (existsSync(__dirname + '/adapters/' + name + '.js')) {\r\n        // try built-in adapter\r\n        adapter = require('./adapters/' + name);\r\n    } else {\r\n        try {\r\n            adapter = require('caminte-' + name);\r\n        } catch (e) {\r\n            throw new Error('Adapter ' + name + ' is not defined, try\\n  npm install ' + name);\r\n        }\r\n    }\r\n\r\n    adapter.initialize(schema, function () {\r\n\r\n        // we have an adaper now?\r\n        if (!schema.adapter) {\r\n            throw new Error('Adapter is not defined correctly: it should create `adapter` member of schema');\r\n        }\r\n\r\n        schema.adapter.log = function (query, start) {\r\n            schema.log(query, start);\r\n        };\r\n\r\n        schema.adapter.logger = function (query) {\r\n            'use strict';\r\n            var t1 = Date.now();\r\n            var log = schema.log;\r\n            return function (q) {\r\n                log(q || query, t1);\r\n            };\r\n        };\r\n        var res = getState(schema);\r\n        if (util.isError(res)) {\r\n            schema.emit('error', res);\r\n        } else {\r\n            schema.connected = true;\r\n            schema.emit('connected');\r\n        }\r\n    }.bind(schema));\r\n}\r\n\r\nutil.inherits(Schema, events.EventEmitter);\r\n\r\nSchema.Text = function Text() {\r\n};\r\nSchema.JSON = function JSON() {\r\n};\r\n/**\r\n * Define class\r\n *\r\n * @param {String} className\r\n * @param {Object} properties - hash of class properties in format\r\n *   `{property: Type, property2: Type2, ...}`\r\n *   or\r\n *   `{property: {type: Type}, property2: {type: Type2}, ...}`\r\n * @param {Object} settings - other configuration of class\r\n * @return newly created class\r\n *\r\n * @example simple case\r\n * ```\r\n * var User = schema.define('User', {\r\n *     email: String,\r\n *     password: String,\r\n *     birthDate: Date,\r\n *     activated: Boolean\r\n * });\r\n * ```\r\n * @example more advanced case\r\n * ```\r\n * var User = schema.define('User', {\r\n *     email: { type: String, limit: 150, index: true },\r\n *     password: { type: String, limit: 50 },\r\n *     birthDate: Date,\r\n *     registrationDate: {type: Date, default: function () { return new Date }},\r\n *     activated: { type: Boolean, default: false }\r\n * });\r\n * ```\r\n */\r\nSchema.prototype.define = function defineClass(className, properties, settings) {\r\n    'use strict';\r\n    var schema = this;\r\n    var args = slice.call(arguments);\r\n\r\n    if (!className) {\r\n        throw new Error('Class name required');\r\n    }\r\n    if (args.length === 1) {\r\n        properties = {}, args.push(properties);\r\n    }\r\n    if (args.length === 2) {\r\n        settings = {}, args.push(settings);\r\n    }\r\n\r\n    standartize(properties, settings);\r\n\r\n    // every class can receive hash of data as optional param\r\n    var NewClass = function ModelConstructor(data) {\r\n        if (!(this instanceof ModelConstructor)) {\r\n            return new ModelConstructor(data);\r\n        }\r\n        AbstractClass.call(this, data);\r\n    };\r\n\r\n    hiddenProperty(NewClass, 'schema', schema);\r\n    hiddenProperty(NewClass, 'modelName', className);\r\n    hiddenProperty(NewClass, 'cache', {});\r\n    hiddenProperty(NewClass, 'mru', []);\r\n    hiddenProperty(NewClass, 'relations', {});\r\n\r\n    // inherit AbstractClass methods\r\n    for (var i in AbstractClass) {\r\n        NewClass[i] = AbstractClass[i];\r\n    }\r\n    for (var j in AbstractClass.prototype) {\r\n        NewClass.prototype[j] = AbstractClass.prototype[j];\r\n    }\r\n\r\n    NewClass.getter = {};\r\n    NewClass.setter = {};\r\n\r\n    // store class in model pool\r\n    this.models[className] = NewClass;\r\n    this.definitions[className] = {\r\n        properties: properties,\r\n        settings: settings\r\n    };\r\n\r\n    // pass controll to adapter\r\n    this.adapter.define({\r\n        model: NewClass,\r\n        properties: properties,\r\n        settings: settings\r\n    });\r\n\r\n    if (!settings.primaryKeys) {\r\n        NewClass.prototype.__defineGetter__('id', function () {\r\n            return this.__data.id;\r\n        });\r\n        properties.id = properties.id || {type: Number};\r\n    }\r\n\r\n    NewClass.forEachProperty = function (cb) {\r\n        Object.keys(properties).forEach(cb);\r\n    };\r\n\r\n    NewClass.registerProperty = function (attr) {\r\n        Object.defineProperty(NewClass.prototype, attr, {\r\n            get: function () {\r\n                'use strict';\r\n                if (NewClass.getter[attr]) {\r\n                    return NewClass.getter[attr].call(this);\r\n                } else {\r\n                    return this.__data[attr];\r\n                }\r\n            },\r\n            set: function (value) {\r\n                'use strict';\r\n                if (NewClass.setter[attr]) {\r\n                    NewClass.setter[attr].call(this, value);\r\n                } else {\r\n                    this.__data[attr] = value;\r\n                }\r\n            },\r\n            configurable: true,\r\n            enumerable: true\r\n        });\r\n\r\n        NewClass.prototype.__defineGetter__(attr + '_was', function () {\r\n            return this.__dataWas[attr];\r\n        });\r\n\r\n        Object.defineProperty(NewClass.prototype, '_' + attr, {\r\n            get: function () {\r\n                return this.__data[attr];\r\n            },\r\n            set: function (value) {\r\n                this.__data[attr] = value;\r\n            },\r\n            configurable: true,\r\n            enumerable: false\r\n        });\r\n    };\r\n\r\n    NewClass.forEachProperty(NewClass.registerProperty);\r\n\r\n    return NewClass;\r\n};\r\n\r\nfunction standartize(properties, settings) {\r\n    Object.keys(properties).forEach(function (key) {\r\n        var v = properties[key];\r\n        if (\r\n            typeof v === 'function' ||\r\n            typeof v === 'object' && v && v.constructor.name === 'Array'\r\n        ) {\r\n            properties[key] = {type: v};\r\n        }\r\n    });\r\n    // TODO: add timestamps fields\r\n    // when present in settings: {timestamps: true}\r\n    // or {timestamps: {created: 'created_at', updated: false}}\r\n    // by default property names: createdAt, updatedAt\r\n}\r\n/**\r\n * Define single property named `prop` on `model`\r\n *\r\n * @param {String} model - name of model\r\n * @param {String} prop - name of propery\r\n * @param {Object} params - property settings\r\n */\r\nSchema.prototype.defineProperty = function (model, prop, params) {\r\n    this.definitions[model].properties[prop] = params;\r\n    this.models[model].registerProperty(prop);\r\n    if (this.adapter.defineProperty) {\r\n        this.adapter.defineProperty(model, prop, params);\r\n    }\r\n};\r\n\r\n/**\r\n * Extend existing model with bunch of properties\r\n *\r\n * @param {String} model - name of model\r\n * @param {Object} props - hash of properties\r\n *\r\n * Example:\r\n *\r\n *     // Instead of doing this:\r\n *\r\n *     // amend the content model with competition attributes\r\n *     db.defineProperty('Content', 'competitionType', { type: String });\r\n *     db.defineProperty('Content', 'expiryDate', { type: Date, index: true });\r\n *     db.defineProperty('Content', 'isExpired', { type: Boolean, index: true });\r\n *\r\n *     // schema.extend allows to\r\n *     // extend the content model with competition attributes\r\n *     db.extendModel('Content', {\r\n *       competitionType: String,\r\n *       expiryDate: { type: Date, index: true },\r\n *       isExpired: { type: Boolean, index: true }\r\n *     });\r\n */\r\nSchema.prototype.extendModel = function (model, props) {\r\n    var t = this;\r\n    standartize(props, {});\r\n    Object.keys(props).forEach(function (propName) {\r\n        var definition = props[propName];\r\n        t.defineProperty(model, propName, definition);\r\n    });\r\n};\r\n\r\n/**\r\n * Drop each model table and re-create.\r\n * This method make sense only for sql adapters.\r\n * @param {Function} cb\r\n *\r\n * @warning All data will be lost! Use autoupdate if you need your data.\r\n */\r\nSchema.prototype.automigrate = function (cb) {\r\n    this.freeze();\r\n    if (this.adapter.automigrate) {\r\n        this.adapter.automigrate(cb);\r\n    } else if (cb) {\r\n        cb();\r\n    }\r\n};\r\n\r\n/**\r\n * Update existing database tables.\r\n * This method make sense only for sql adapters.\r\n * @param {Function} cb\r\n */\r\nSchema.prototype.autoupdate = function (cb) {\r\n    this.freeze();\r\n    if (this.adapter.autoupdate) {\r\n        this.adapter.autoupdate(cb);\r\n    } else if (cb) {\r\n        cb();\r\n    }\r\n};\r\n\r\n/**\r\n * Check whether migrations needed\r\n * This method make sense only for sql adapters.\r\n * @param {Function} cb\r\n */\r\nSchema.prototype.isActual = function (cb) {\r\n    this.freeze();\r\n    if (this.adapter.isActual) {\r\n        this.adapter.isActual(cb);\r\n    } else if (cb) {\r\n        cb(null, true);\r\n    }\r\n};\r\n\r\n/**\r\n * Log benchmarked message. Do not redefine this method, if you need to grab\r\n * chema logs, use `schema.on('log', ...)` emitter event\r\n * @param {String} sql\r\n * @param {Date} t\r\n *\r\n * @private used by adapters\r\n */\r\nSchema.prototype.log = function (sql, t) {\r\n    this.emit('log', sql, t);\r\n};\r\n\r\n/**\r\n * Freeze schema. Behavior depends on adapter\r\n */\r\nSchema.prototype.freeze = function freeze() {\r\n    if (this.adapter.freezeSchema) {\r\n        this.adapter.freezeSchema();\r\n    }\r\n};\r\n\r\n/**\r\n * Return table name for specified `modelName`\r\n * @param {String} modelName\r\n */\r\nSchema.prototype.tableName = function (modelName) {\r\n    return this.definitions[modelName].settings.table = this.definitions[modelName].settings.table || modelName;\r\n};\r\n\r\n/**\r\n * Define foreign key\r\n * @param {String} className\r\n * @param {String} key - name of key field\r\n */\r\nSchema.prototype.defineForeignKey = function defineForeignKey(className, key) {\r\n    // quit if key already defined\r\n    if (this.definitions[className].properties[key])\r\n        return;\r\n\r\n    if (this.adapter.defineForeignKey) {\r\n        this.adapter.defineForeignKey(className, key, function (err, keyType) {\r\n            if (err)\r\n                throw err;\r\n            this.definitions[className].properties[key] = {type: keyType};\r\n        }.bind(this));\r\n    } else {\r\n        this.definitions[className].properties[key] = {type: Number};\r\n    }\r\n    this.models[className].registerProperty(key);\r\n};\r\n\r\n/**\r\n * Start transaction\r\n *\r\n * @param {Object} params\r\n * @param {Function} callback\r\n */\r\nSchema.prototype.begin = function begin(params, callback) {\r\n    if (typeof callback === 'undefined') {\r\n        callback = function (err) {\r\n            return err;\r\n        };\r\n    }\r\n\r\n    if (typeof this.adapter.begin === 'undefined') {\r\n        callback(new Error('TRANSACTION::begin method not defined for this adapter'));\r\n    } else {\r\n        this.adapter.begin(params, callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Commit transaction\r\n *\r\n * @param {Object} params\r\n * @param {Function} callback\r\n */\r\nSchema.prototype.commit = function commit(params, callback) {\r\n    if (typeof callback === 'undefined') {\r\n        callback = function (err) {\r\n            return err;\r\n        };\r\n    }\r\n\r\n    if (typeof this.adapter.commit === 'undefined') {\r\n        callback(new Error('TRANSACTION::commit method not defined for this adapter'));\r\n    } else {\r\n        this.adapter.commit(params, callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Rollback transaction\r\n *\r\n * @param {Object} params\r\n * @param {Function} callback\r\n */\r\nSchema.prototype.rollback = function rollback(params, callback) {\r\n    if (typeof callback === 'undefined') {\r\n        callback = function (err) {\r\n            return err;\r\n        };\r\n    }\r\n\r\n    if (typeof this.adapter.rollback === 'undefined') {\r\n        callback(new Error('TRANSACTION::rollback method not defined for this adapter'));\r\n    } else {\r\n        this.adapter.rollback(params, callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Close database connection\r\n */\r\nSchema.prototype.disconnect = function disconnect() {\r\n    if (typeof this.adapter.disconnect === 'function') {\r\n        this.connected = false;\r\n        this.adapter.disconnect();\r\n    }\r\n};\r\n\r\n/**\r\n * Returns an array of model names created on this instance of Schema.\r\n *\r\n * ####Note:\r\n *\r\n * _Does not include names of models created using `connection.model()`._\r\n *\r\n * @api public\r\n * @return {Array}\r\n */\r\n\r\nSchema.prototype.modelNames = function () {\r\n    var names = Object.keys(this.models);\r\n    return names;\r\n};\r\n\r\n/**\r\n * Defines a model or retrieves it.\r\n *\r\n * Models defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.\r\n *\r\n * ####Example:\r\n *\r\n *     var mongoose = require('mongoose');\r\n *\r\n *     // define an Actor model with this mongoose instance\r\n *     mongoose.model('Actor', new Schema({ name: String }));\r\n *\r\n *     // create a new connection\r\n *     var conn = mongoose.createConnection(..);\r\n *\r\n *     // retrieve the Actor model\r\n *     var Actor = conn.model('Actor');\r\n *\r\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\r\n *\r\n * ####Example:\r\n *\r\n *     var schema = new Schema({ name: String }, { collection: 'actor' });\r\n *\r\n *     // or\r\n *\r\n *     schema.set('collection', 'actor');\r\n *\r\n *     // or\r\n *\r\n *     var collectionName = 'actor'\r\n *     var M = mongoose.model('Actor', schema, collectionName)\r\n *\r\n * @param {String} name model name\r\n * @param {Schema} [schema]\r\n * @param {String} [collection] name (optional, induced from model name)\r\n * @param {Boolean} [skipInit] whether to skip initialization (defaults to false)\r\n * @api public\r\n */\r\n\r\nSchema.prototype.model = function (name, schema) {\r\n    if ('string' === typeof schema) {\r\n        schema = false;\r\n    }\r\n\r\n    if (typeof schema === 'object') {\r\n        schema = new Schema(schema);\r\n    }\r\n\r\n    var model;\r\n\r\n    // connection.model() may be passing a different schema for\r\n    // an existing model name. in this case don't read from cache.\r\n    if (this.models[name]) {\r\n        model = this.models[name];\r\n    }\r\n\r\n    return model;\r\n};\r\n\r\n/**\r\n * Define hidden property\r\n * @param {Object} where\r\n * @param {String} property\r\n * @param {mixed} value\r\n */\r\nfunction hiddenProperty(where, property, value) {\r\n    Object.defineProperty(where, property, {\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false,\r\n        value: value\r\n    });\r\n}\r\n\r\n/**\r\n * Define readonly property on object\r\n *\r\n * @param {Object} obj\r\n * @param {String} key\r\n * @param {Mixed} value\r\n */\r\nfunction defineReadonlyProp(obj, key, value) {\r\n    Object.defineProperty(obj, key, {\r\n        writable: false,\r\n        enumerable: true,\r\n        configurable: true,\r\n        value: value\r\n    });\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/utils.js":"exports.inherits = function(newClass, baseClass) {\r\n    Object.keys(baseClass).forEach(function(classMethod) {\r\n        newClass[classMethod] = baseClass[classMethod];\r\n    });\r\n    Object.keys(baseClass.prototype).forEach(function(instanceMethod) {\r\n        newClass.prototype[instanceMethod] = baseClass.prototype[instanceMethod];\r\n    });\r\n};\r\n\r\nexports.safeRequire = function safeRequire(module) {\r\n    try {\r\n        return require(module);\r\n    } catch (e) {\r\n        var str = module;\r\n        if(module === 'rethinkdb') { str = module + ' generic-pool moment async'; }\r\n        console.log('Run \"npm install ' + str + '\" command to using ' + module + ' database engine');\r\n        process.exit(1);\r\n    }\r\n};\r\n\r\nexports.getState = function getState(orm) {\r\n    switch (orm.name) {\r\n        case 'mysql':\r\n        case 'mariadb':\r\n            if (orm.client) {\r\n                if (orm.client._protocol) {\r\n                    if (orm.client._protocol._fatalError) {\r\n                        if (orm.client._protocol._fatalError.fatal) {\r\n                            return orm.client._protocol._fatalError;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return true;\r\n};\r\n\r\nexports.helpers = {\r\n    __slice: [].slice,\r\n    __bind: function(fn, me) {\r\n        return function() {\r\n            return fn.apply(me, arguments);\r\n        };\r\n    },\r\n    merge: function(base, update) {\r\n        var k, v;\r\n        if (!base) {\r\n            return update;\r\n        }\r\n        for (k in update) {\r\n            v = update[k];\r\n            base[k] = update[k];\r\n        }\r\n        return base;\r\n    },\r\n    reverse: function(key) {\r\n        var hasOrder = key.match(/\\s+(A|DE)SC$/i);\r\n        if (hasOrder) {\r\n            if (hasOrder[1] === \"DE\") {\r\n                return -1;\r\n            }\r\n        }\r\n        return 1;\r\n    },\r\n    inArray: function(p_val, arr) {\r\n        for (var i = 0, l = arr.length; i < l; i++) {\r\n            if (arr[i] === p_val) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    stripOrder: function(key) {\r\n        return key.replace(/\\s+(A|DE)SC/i, \"\");\r\n    },\r\n    savePrep: function(data) {\r\n        var id = data.id;\r\n        if (id) {\r\n            data._id = id.toString();\r\n        }\r\n        delete data.id;\r\n        if (data._rev === null) {\r\n            return delete data._rev;\r\n        }\r\n    },\r\n    applyFilter: function(filter) {\r\n        var self = this;\r\n        if (typeof filter.where === 'function') {\r\n            return filter.where;\r\n        }\r\n        var keys = Object.keys(filter.where);\r\n        return function(obj) {\r\n            var pass = true;\r\n            keys.forEach(function(key) {\r\n                if (typeof filter.where[key] === 'object' && !filter.where[key].getTime) {\r\n                    pass = self.parseCond(obj[key], filter.where[key]);\r\n                } else {\r\n                    if (!self.testString(filter.where[key], obj[key])) {\r\n                        pass = false;\r\n                    }\r\n                }\r\n            });\r\n            return pass;\r\n        };\r\n    },\r\n    testString: function(example, value) {\r\n        if (typeof value === 'string' && example && example.constructor.name === 'RegExp') {\r\n            return value.match(example);\r\n        }\r\n        // not strict equality\r\n        return (example !== null ? example.toString() : example) === (value !== null ? value.toString() : value);\r\n    },\r\n    parseCond: function(val, conds) {\r\n        var outs = false;\r\n        Object.keys(conds).forEach(function(condType) {\r\n            switch (condType) {\r\n                case 'gt':\r\n                    outs = val > conds[condType] ? true : false;\r\n                    break;\r\n                case 'gte':\r\n                    outs = val >= conds[condType] ? true : false;\r\n                    break;\r\n                case 'lt':\r\n                    outs = val < conds[condType] ? true : false;\r\n                    break;\r\n                case 'lte':\r\n                    outs = val <= conds[condType] ? true : false;\r\n                    break;\r\n                case 'between':\r\n                    var bt = conds[condType];\r\n                    outs = (val >= bt[0] && val <= bt[1]) ? true : false;\r\n                    break;\r\n                case 'inq':\r\n                case 'in':\r\n                    conds[condType].forEach(function(cval) {\r\n                        if (val === cval) {\r\n                            outs = true;\r\n                        }\r\n                    });\r\n                    break;\r\n                case 'nin':\r\n                    outs = true;\r\n                    conds[condType].forEach(function(cval) {\r\n                        if (val === cval) {\r\n                            outs = false;\r\n                        }\r\n                    });\r\n                    break;\r\n                case 'neq':\r\n                case 'ne':\r\n                    outs = val !== conds[condType] ? true : false;\r\n                    break;\r\n                case 'regex':\r\n                case 'like':\r\n                    outs = new RegExp(conds[condType]).test(val);\r\n                    break;\r\n                case 'nlike':\r\n                    outs = !new RegExp(conds[condType]).test(val);\r\n                    break;\r\n                default:\r\n                    outs = val === conds[condType] ? true : false;\r\n                    break;\r\n            }\r\n        });\r\n        return outs;\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/abstract-class.js":"/**\n * Module dependencies\n */\nvar Bluebird = require(\"bluebird\");\nvar vld = require('./validatable');\nvar hkb = require('./hookable');\nvar util = require('util');\nvar utils = require('./utils');\nvar helpers = utils.helpers;\nvar Query = require('./query');\nvar Validatable = vld.Validatable;\nvar List = require('./list');\nvar Hookable = hkb.Hookable;\n// var DEFAULT_CACHE_LIMIT = 1000;\nvar BASE_TYPES = ['String', 'Boolean', 'Number', 'Date', 'Text', 'JSON', 'UUID'];\n\n/**\n * Defer Promise\n * @returns {{resolve: *, reject: *, promise}}\n */\nfunction deferPromise() {\n    var resolve = null, reject = null;\n    var promise = new Bluebird(function () {\n        resolve = arguments[0];\n        reject = arguments[1];\n    });\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise\n    };\n}\n\nexports.AbstractClass = AbstractClass;\n\nif (!Object.prototype.hasOwnProperty('extend')) {\n    Object.defineProperty(Object.prototype, \"extend\", {\n        enumerable: false,\n        writable: true,\n        value: function (from) {\n            var props = Object.getOwnPropertyNames(from);\n            var dest = this;\n            props.forEach(function (name) {\n                if (name in dest) {\n                    var destination = Object.getOwnPropertyDescriptor(from, name);\n                    Object.defineProperty(dest, name, destination);\n                }\n            });\n            return this;\n        }\n    });\n}\n\nAbstractClass.__proto__ = Validatable;\nAbstractClass.prototype.__proto__ = Validatable.prototype;\nutils.inherits(AbstractClass, Hookable);\n\n/**\n * Abstract class - base class for all persist objects\n * provides **common API** to access any database adapter.\n * This class describes only abstract behavior layer, refer to `lib/adapters/*.js`\n * to learn more about specific adapter implementations\n *\n * `AbstractClass` mixes `Validatable` and `Hookable` classes methods\n *\n * @constructor\n * @param {Object} data - initial object data\n */\nfunction AbstractClass(data) {\n    this._initProperties(data, true);\n}\n\nAbstractClass.prototype._initProperties = function (data, applySetters) {\n    var self = this;\n    var ctor = this.constructor;\n    var ds = ctor.schema.definitions[ctor.modelName];\n    var properties = ds.properties;\n    data = data || {};\n\n    Object.defineProperty(this, '__cachedRelations', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__data', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__query', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__dataWas', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    if (data['__cachedRelations']) {\n        this.__cachedRelations = data['__cachedRelations'];\n    }\n\n    for (var i in data) {\n        this.__data[i] = this.__dataWas[i] = data[i];\n    }\n    if (applySetters && ctor.setter) {\n        Object.keys(ctor.setter).forEach(function (attr) {\n            if (self.__data.hasOwnProperty(attr)) {\n                ctor.setter[attr].call(self, self.__data[attr]);\n            }\n        });\n    }\n\n    ctor.forEachProperty(function (attr) {\n        if (!self.__data.hasOwnProperty(attr)) {\n            self.__data[attr] = self.__dataWas[attr] = getDefault(attr);\n        } else {\n            self.__dataWas[attr] = self.__data[attr];\n        }\n    });\n\n    ctor.forEachProperty(function (attr) {\n        if (properties[attr].type === undefined) {\n            properties[attr].type = String;\n        }\n        var type = properties[attr].type;\n        if (BASE_TYPES.indexOf(type.name) === -1) {\n            if (typeof self.__data[attr] !== 'object' && self.__data[attr]) {\n                try {\n                    self.__data[attr] = JSON.parse(self.__data[attr] + '');\n                } catch (e) {\n                    console.log(type.name, attr, self.__data[attr], e);\n                }\n            }\n            if (type.name === 'Array' || typeof type === 'object' && type.constructor.name === 'Array') {\n                self.__data[attr] = new List(self.__data[attr], type, self);\n            }\n        }\n    });\n\n    function getDefault(attr) {\n        var def = properties[attr]['default'];\n        if (isdef(def)) {\n            if (typeof def === 'function') {\n                return def();\n            } else {\n                return def;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    this.trigger(\"initialize\");\n};\n\n/**\n * @param {String} prop - property name\n * @param {Object} params - various property configuration\n */\nAbstractClass.defineProperty = function (prop, params) {\n    this.schema.defineProperty(this.modelName, prop, params);\n};\n\nAbstractClass.whatTypeName = function (propName) {\n    var ds = this.schema.definitions[this.modelName];\n    return ds.properties[propName] && ds.properties[propName].type.name;\n};\n\nAbstractClass.clone = function clone(o) {\n    var ret = {};\n    Object.keys(o).forEach(function (val) {\n        ret[val] = o[val];\n    });\n    return ret;\n};\n\nAbstractClass._forDB = function (data) {\n    var res = {}, YesSQL = ['mysql', 'sqlite', 'sqlite3', 'firebird', 'memory'];\n    Object.keys(data).forEach(function (propName) {\n        if ((this.whatTypeName(propName) || '').toString().toLowerCase() === 'json'\n            || data[propName] instanceof Array) {\n            if (YesSQL.indexOf(this.schema.adapter.name || this.schema.name) !== -1) {\n                res[propName] = JSON.stringify(data[propName]);\n            } else {\n                res[propName] = data[propName];\n            }\n        } else {\n            res[propName] = data[propName];\n        }\n    }.bind(this));\n    return res;\n};\nAbstractClass.promise = deferPromise;\nAbstractClass.q = {\n    conditions: {},\n    params: {},\n    pkey: false,\n    fields: false\n};\n\nAbstractClass.prototype.whatTypeName = function (propName) {\n    return this.constructor.whatTypeName(propName);\n};\n\nAbstractClass.query = function (data, callback) {\n    if (typeof this.schema.adapter.query === 'undefined') {\n        callback(new Error('Model::query not defined for this adapter'));\n    } else {\n        var p = deferPromise();\n        this.schema.adapter.query(data, function (err, data) {\n            if (err) {\n                p.reject(err);\n            } else {\n                p.resolve(data);\n            }\n            return callback && callback(err, data);\n        });\n        return p.promise;\n    }\n};\n/**\n * Create new instance of Model class, saved in database\n *\n * @param data [optional]\n * @param {Function} callback - callback called with (err, obj)\n * callback called with arguments:\n *\n *   - err (null or Error)\n *   - instance (null or Model)\n */\nAbstractClass.create = function (data, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var modelName = this.modelName;\n    var p = deferPromise();\n\n    if (typeof data === 'function') {\n        callback = data;\n        data = {};\n    }\n\n    if (typeof callback !== 'function') {\n        callback = function () {\n        };\n    }\n\n    var obj = null;\n    // if we come from save\n    if (data instanceof this && !data.id) {\n        obj = data;\n        data = obj.toObject(true);\n        obj._initProperties(data, false);\n        create();\n    } else {\n        obj = new this(data);\n        // validation required\n        obj.isValid(function (valid) {\n            if (!valid) {\n                var err = new Error(modelName + ' validation error');\n                p.reject(err);\n                return callback && callback(err, obj);\n            } else {\n                return create();\n            }\n        });\n    }\n\n    function create() {\n        obj.trigger('create', function (done) {\n            var data = this.toObject(true);  // Added this to fix the beforeCreate trigger not fire.\n            // The fix is per issue #72 and the fix was found by by5739.\n            this._adapter().create(modelName, this.constructor._forDB(data), function (err, id, rev) {\n                if (id) {\n                    obj.__data.id = id;\n                    obj.__dataWas.id = id;\n                    defineReadonlyProp(obj, 'id', id);\n                }\n                if (rev) {\n                    obj._rev = rev;\n                }\n                done.call(this, function () {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(obj);\n                    }\n                    return callback && callback(err, obj);\n                });\n            }.bind(this));\n        });\n    }\n\n    return p.promise;\n};\n\nfunction stillConnecting(schema, obj, args) {\n    if (schema.connected) {\n        return false;\n    }\n    var method = args.callee;\n    schema.on('connected', function () {\n        method.apply(obj, [].slice.call(args));\n    });\n    return true;\n}\n\n/**\n * Update or insert (create)\n * @param {Object} query - object.\n * @param {Object} data - object to find or create.\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.upsert = AbstractClass.updateOrCreate = function upsert(query, data, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        console.log('++++  stillConnecting')\n        return;\n    }\n    if (arguments.length === 1) {\n        return;\n    }\n    if ('function' === typeof data) {\n        callback = data;\n        data = {};\n    }\n    var p = deferPromise();\n    var Model = this;\n\n    if (query.id) {\n        this.findById(query.id, function (err, inst) {\n            if (err) {\n                p.reject(err);\n                return callback && callback(err);\n            }\n            if (inst) {\n                inst.updateAttributes(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(inst);\n                    }\n                    return callback && callback(err);\n                });\n            } else {\n                data = helpers.merge(data, query);\n                var obj = new Model(data);\n                obj.save(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(obj);\n                    }\n                    return callback && callback(err);\n                });\n            }\n        });\n    } else {\n        Model.all({\n            where: query\n        }, function (err, insts) {\n            if (err || (insts && insts.length > 1)) {\n                if (insts.length > 1) {\n                    err = new Error('Found more than one record');\n                    p.reject(err);\n                    return callback && callback(err, insts);\n                }\n                if (err.message && !/NotFound/gi.test(err.message)) {\n                    p.reject(err);\n                    return callback && callback(err, insts);\n                }\n            }\n            if (insts[0]) {\n                var inst = insts[0];\n                inst.updateAttributes(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(inst);\n                    }\n                    return callback && callback(err, inst);\n                });\n            } else {\n                data = helpers.merge(data, query);\n                var obj = new Model(data);\n                obj.save(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(obj);\n                    }\n                    return callback && callback(err, obj);\n                });\n            }\n        });\n    }\n    return p.promise;\n};\n\n/**\n * Find one record, same as `all`, limited by 1 and return object, not collection,\n * if not found, create using data provided as second argument\n *\n * @param {Object} query - search conditions: {where: {test: 'me'}}.\n * @param {Object} data - object to create.\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.findOrCreate = function findOrCreate(query, data, callback) {\n    if (stillConnecting(this.schema, this, arguments))\n        return;\n    if (arguments.length === 1) {\n        return;\n    }\n    if ('function' === typeof data) {\n        callback = data;\n        data = {};\n    }\n    var self = this, p = deferPromise();\n    self.findOne({where: query}, function (err, record) {\n        if (err) {\n            p.reject(err);\n            return callback && callback(err);\n        } else if (record) {\n            p.resolve(record);\n            return callback && callback(null, record);\n        } else {\n            data = helpers.merge(query, data);\n            self.create(data).then(function (record) {\n                p.resolve(record);\n                return callback && callback(null, record);\n            }).catch(function (err) {\n                p.reject(err);\n                return callback && callback(err, null);\n            });\n        }\n    });\n    return p.promise;\n};\n\n/**\n * Check whether object exitst in database\n *\n * @param {id} id - identifier of object (primary key value)\n * @param {Function} callback - callbacl called with (err, exists: Bool)\n */\nAbstractClass.exists = function exists(id, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    if (id) {\n        id = getInstanceId(id);\n        this.schema.adapter.exists(this.modelName, id, function (err, data) {\n            if (err) {\n                p.reject(err);\n            } else {\n                p.resolve(data);\n            }\n            return callback && callback(err, data);\n        });\n    } else {\n        var err = new Error('Model::exists requires positive id argument');\n        p.reject(err);\n        return callback && callback(err);\n    }\n    return p.promise;\n};\n\n/**\n * Find all instances of Model, matched by query\n * make sure you have marked as `index: true` fields for filter or sort\n *\n * @param {Object} params (optional)\n *\n * - where: Object `{ key: val, key2: {gt: 'val2'}}`\n * - include: String, Object or Array. See AbstractClass.include documentation.\n * - order: String\n * - limit: Number\n * - skip: Number\n *\n * @param {Function} callback (required) called with arguments:\n *\n * - err (null or Error)\n * - Array of instances\n */\nAbstractClass.find = AbstractClass.exec = AbstractClass.run = AbstractClass.all = function all(params, callback) {\n    if ('function' === typeof params) {\n        callback = params;\n        params = {};\n    }\n    params = params ? params : {};\n    if (typeof callback === 'undefined' && !params.where && !params.order && !params.limit) {\n        return new Query(this.schema.models[this.modelName], 'all', params);\n    } else {\n        if (stillConnecting(this.schema, this, arguments)) {\n            return null;\n        }\n        var p = deferPromise();\n        params = buildQuery(params, this);\n        var Constr = this;\n        this.schema.adapter.all(this.modelName, params, function (err, data) {\n            if (!err && data && data.map) {\n                data.forEach(function (d, i) {\n                    var obj = new Constr();\n                    obj._initProperties(d, false);\n                    data[i] = obj;\n                });\n                // if (data && data.countBeforeLimit) {\n                //     data['countBeforeLimit'] = data.countBeforeLimit;\n                // }\n                p.resolve(data);\n                return callback && callback(err, data);\n            } else {\n                p.reject(err);\n                return callback && callback(err, []);\n            }\n        });\n        return p.promise;\n    }\n};\n\n/**\n * Find object by id\n *\n * @param {id} id - primary key value\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.findById = function findById(id, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    id = getInstanceId(id);\n    var p = deferPromise();\n    this.schema.adapter.findById(this.modelName, id, function (err, data) {\n        var obj = null;\n        if (data) {\n            if (!data.id) {\n                data.id = id;\n            }\n            obj = new this();\n            obj._initProperties(data, false);\n        }\n        if (err) {\n            p.reject(err);\n        } else {\n            p.resolve(obj);\n        }\n        return callback && callback(err, obj);\n    }.bind(this));\n    return p.promise;\n};\n\n/**\n * Find one record, same as `all`, limited by 1 and return object, not collection\n *\n * @param {Object} params - search conditions: {where: {test: 'me'}}\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.findOne = function findOne(params, callback) {\n    if ('function' === typeof params) {\n        callback = params;\n        params = {};\n    }\n    if (typeof callback === 'undefined' && !(params || {}).where) {\n        return new Query(this.schema.models[this.modelName], 'findOne', params);\n    } else {\n        if (stillConnecting(this.schema, this, arguments)) {\n            return null;\n        }\n        var self = this;\n        if (typeof params === 'undefined') {\n            self.q.params.limit = 1;\n            return self;\n        } else {\n            var p = deferPromise();\n            if (typeof params === 'function') {\n                callback = params;\n                params = {};\n            }\n            params = buildQuery(params, self);\n            params.limit = 1;\n            self\n                .all(params)\n                .then(function (collection) {\n                    p.resolve(collection[0]);\n                    return callback && callback(null, collection[0] || null);\n                })\n                .catch(function (err) {\n                    p.reject(err);\n                    return callback && callback(err, null);\n                });\n            return p.promise;\n        }\n    }\n};\n\nfunction substractDirtyAttributes(object, data) {\n    Object.keys(object.toObject()).forEach(function (attr) {\n        if (data.hasOwnProperty(attr) && object.propertyChanged(attr)) {\n            delete data[attr];\n        }\n    });\n}\n\n/**\n * Destroy all records\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.destroyAll = function destroyAll(callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    this.schema.adapter.destroyAll(this.modelName, function (err) {\n        if (err) {\n            p.reject(err);\n        } else {\n            p.resolve(null);\n        }\n        return callback && callback(err);\n    }.bind(this));\n    return p.promise;\n};\n\n/**\n * Return count of matched records\n *\n * @param {Object} params - search conditions (optional)\n * @param {Function} callback - callback, called with (err, count)\n */\nAbstractClass.count = function (params, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    if (typeof params === 'function') {\n        callback = params;\n        params = null;\n    }\n    var p = deferPromise();\n    params = buildQuery(params, this);\n    this.schema.adapter.count(this.modelName, function (err, count) {\n        if (err) {\n            p.reject(err);\n        } else {\n            p.resolve(count);\n        }\n        return callback && callback(err, count);\n    }, params);\n    return p.promise;\n};\n\n/**\n * Allows you to load relations of several objects and optimize numbers of requests.\n *\n * @param {Array} objects - array of instances\n * @param {String|Object|Array} include - which relations you want to load.\n * @param {Function} callback - Callback called when relations are loaded\n *\n * Examples:\n *\n * - User.include(users, 'posts', function() {}); will load all users posts with only one additional request.\n * - User.include(users, ['posts'], function() {}); // same\n * - User.include(users, ['posts', 'passports'], function() {}); // will load all users posts and passports with two\n *     additional requests.\n * - Passport.include(passports, {owner: 'posts'}, function() {}); // will load all passports owner (users), and all\n *     posts of each owner loaded\n * - Passport.include(passports, {owner: ['posts', 'passports']}); // ...\n * - Passport.include(passports, {owner: [{posts: 'images'}, 'passports']}); // ...\n */\nAbstractClass.include = function (objects, include, callback) {\n    var self = this;\n\n    if (\n        (include.constructor.name === 'Array' && include.length === 0) ||\n        (include.constructor.name === 'Object' && Object.keys(include).length === 0)\n    ) {\n        callback(null, objects);\n        return;\n    }\n\n    include = processIncludeJoin(include);\n\n    var keyVals = {};\n    var objsByKeys = {};\n\n    var nbCallbacks = 0;\n    for (var i = 0; i < include.length; i++) {\n        var cb = processIncludeItem(objects, include[i], keyVals, objsByKeys);\n        if (cb !== null) {\n            nbCallbacks++;\n            cb(function () {\n                if (--nbCallbacks === 0) {\n                    callback(null, objects);\n                }\n            });\n        } else {\n            callback(null, objects);\n        }\n    }\n\n    function processIncludeJoin(ij) {\n        if (typeof ij === 'string') {\n            ij = [ij];\n        }\n        if (ij.constructor.name === 'Object') {\n            var newIj = [];\n            for (var key in ij) {\n                var obj = {};\n                obj[key] = ij[key];\n                newIj.push(obj);\n            }\n            return newIj;\n        }\n        return ij;\n    }\n\n    function processIncludeItem(objs, include, keyVals, objsByKeys) {\n        var relations = self.relations, relationName, subInclude;\n\n        if (include.constructor.name === 'Object') {\n            relationName = Object.keys(include)[0];\n            subInclude = include[relationName];\n        } else {\n            relationName = include;\n            subInclude = [];\n        }\n        var relation = relations[relationName];\n\n        var req = {\n            'where': {}\n        };\n\n        if (!keyVals[relation.keyFrom]) {\n            objsByKeys[relation.keyFrom] = {};\n            for (var j = 0; j < objs.length; j++) {\n                if (!objsByKeys[relation.keyFrom][objs[j][relation.keyFrom]]) {\n                    objsByKeys[relation.keyFrom][objs[j][relation.keyFrom]] = [];\n                }\n                objsByKeys[relation.keyFrom][objs[j][relation.keyFrom]].push(objs[j]);\n            }\n            keyVals[relation.keyFrom] = Object.keys(objsByKeys[relation.keyFrom]);\n        }\n\n        if (keyVals[relation.keyFrom].length > 0) {\n            // deep clone is necessary since inq seems to change the processed array\n            var keysToBeProcessed = {};\n            var inValues = [];\n            for (var f = 0; f < keyVals[relation.keyFrom].length; f++) {\n                keysToBeProcessed[keyVals[relation.keyFrom][f]] = true;\n                if (keyVals[relation.keyFrom][f] !== 'null') {\n                    inValues.push(keyVals[relation.keyFrom][f]);\n                }\n            }\n\n            req['where'][relation.keyTo] = {\n                inq: inValues\n            };\n            req['include'] = subInclude;\n\n            return function (clbk) {\n                relation.modelTo.all(req, function (err, objsIncluded) {\n                    for (var i = 0; i < objsIncluded.length; i++) {\n                        delete keysToBeProcessed[objsIncluded[i][relation.keyTo]];\n                        var objectsFrom = objsByKeys[relation.keyFrom][objsIncluded[i][relation.keyTo]];\n                        for (var j = 0; j < objectsFrom.length; j++) {\n                            if (!objectsFrom[j].__cachedRelations) {\n                                objectsFrom[j].__cachedRelations = {};\n                            }\n                            if (relation.multiple) {\n                                if (!objectsFrom[j].__cachedRelations[relationName]) {\n                                    objectsFrom[j].__cachedRelations[relationName] = [];\n                                }\n                                objectsFrom[j].__cachedRelations[relationName].push(objsIncluded[i]);\n                            } else {\n                                objectsFrom[j].__cachedRelations[relationName] = objsIncluded[i];\n                            }\n                        }\n                    }\n\n                    // No relation have been found for these keys\n                    for (var key in keysToBeProcessed) {\n                        var objectsFromRelation = objsByKeys[relation.keyFrom][key];\n                        for (var n = 0; n < objectsFromRelation.length; n++) {\n                            if (!objectsFromRelation[n].__cachedRelations) {\n                                objectsFromRelation[n].__cachedRelations = {};\n                            }\n                            objectsFromRelation[n].__cachedRelations[relationName] = relation.multiple ? [] : null;\n                        }\n                    }\n                    clbk(err, objsIncluded);\n                });\n            };\n        }\n        return null;\n    }\n};\n\n/**\n * Return string representation of class\n * @override default toString method\n */\nAbstractClass.toString = function () {\n    return '[Model ' + this.modelName + ']';\n};\n\n/**\n * Save instance. When instance haven't id, create method called instead.\n * Triggers: validate, save, update | create\n * @param {Object} options {validate: true, throws: false} [optional]\n * @param {Function} callback - (err, obj)\n */\nAbstractClass.prototype.save = function (options, callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n\n    callback = callback || function () {\n        };\n    options = options || {};\n\n    if (!('validate' in options)) {\n        options.validate = true;\n    }\n    if (!('throws' in options)) {\n        options['throws'] = false;\n    }\n\n    if (options.validate) {\n        this.isValid(function (valid) {\n            if (valid) {\n                save.call(this);\n            } else {\n                var err = new Error('Validation error');\n                // throws option is dangerous for async usage\n                if (options['throws']) {\n                    throw err;\n                }\n                callback(err, this);\n            }\n        }.bind(this));\n    } else {\n        save.call(this);\n    }\n\n    function save() {\n        this.trigger('save', function (saveDone) {\n            var modelName = this.constructor.modelName;\n            var data = this.toObject(true);\n            var inst = this;\n\n            if (inst.id) {\n                data.id = inst.id;\n                inst.trigger('update', function (updateDone) {\n                    inst._adapter().save(modelName, inst.constructor._forDB(data), function (err) {\n                        if (err) {\n                            console.log(err);\n                        } else {\n                            inst._initProperties(data, false);\n                        }\n                        updateDone.call(inst, function () {\n                            saveDone.call(inst, function () {\n                                callback(err, inst);\n                            });\n                        });\n                    });\n                }, data);\n            } else {\n                inst.constructor.create(inst, function (err) {\n                    saveDone.call(inst, function () {\n                        callback(err, inst);\n                    });\n                });\n            }\n        });\n    }\n};\n\nAbstractClass.prototype.isNewRecord = function () {\n    return !this.id;\n};\n\n/**\n * Return adapter of current record\n * @private\n */\nAbstractClass.prototype._adapter = function () {\n    return this.constructor.schema.adapter;\n};\n\n/**\n * Convert instance to Object\n *\n * @param {Boolean} onlySchema - restrict properties to schema only, default false\n * when onlySchema == true, only properties defined in schema returned,\n * otherwise all enumerable properties returned\n * @returns {Object} - canonical object representation (no getters and setters)\n */\nAbstractClass.prototype.toObject = function (onlySchema) {\n    var data = {}, self = this;\n    this.constructor.forEachProperty(function (attr) {\n        if (self[attr] instanceof List) {\n            data[attr] = self[attr].toObject();\n        } else if (self.__data.hasOwnProperty(attr)) {\n            data[attr] = self[attr];\n        } else {\n            data[attr] = null;\n        }\n    });\n\n    if (!onlySchema) {\n        Object.keys(self).forEach(function (attr) {\n            if (!data.hasOwnProperty(attr)) {\n                data[attr] = this[attr];\n            }\n        });\n    }\n\n    return data;\n};\n\n// AbstractClass.prototype.hasOwnProperty = function (prop) {\n//     return this.__data && this.__data.hasOwnProperty(prop) ||\n//         Object.getOwnPropertyNames(this).indexOf(prop) !== -1;\n// };\n\nAbstractClass.prototype.toJSON = function () {\n    return this.toObject();\n};\n\n/**\n * Delete object from persistence\n * @param {Function} callback called with (error)\n * @triggers `destroy` hook (async) before and after destroying object\n */\nAbstractClass.prototype.destroy = function (callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    this.trigger('destroy', function (destroyed) {\n        this._adapter().destroy(this.constructor.modelName, this.id, function (err) {\n            destroyed(function () {\n                return callback && callback(err);\n            });\n        }.bind(this));\n    });\n};\n\n/**\n * Destroy records\n * @param {Object|String|Number} id - remove conditions\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.destroyById = function destroyById(id, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    id = getInstanceId(id);\n    this.findById(id, function (err, inst) {\n        if (inst) {\n            inst.destroy(function (err) {\n                if (err) {\n                    p.reject(err);\n                } else {\n                    p.resolve(null);\n                }\n                return callback && callback(err);\n            });\n        } else {\n            p.reject(err);\n            return callback && callback(err);\n        }\n    });\n    return p.promise;\n};\n\n/**\n * Destroy records\n * @param {Object} params - remove conditions\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.remove = function remove(params, callback) {\n    if (typeof callback === 'undefined') {\n        return new Query(this.schema.models[this.modelName], 'remove', params);\n    } else {\n        if (stillConnecting(this.schema, this, arguments)) {\n            return;\n        }\n        this.schema.adapter.remove(this.modelName, params, function (err) {\n            // clearCache(this);\n            callback(err);\n        }.bind(this));\n    }\n};\n\n/**\n * Update single attribute\n *\n * equals to `updateAttributes({name: value}, cb)\n *\n * @param {String} name - name of property\n * @param {Mixed} value - value of property\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.prototype.updateAttribute = function updateAttribute(name, value, callback) {\n    var data = {};\n    data[name] = value;\n    this.updateAttributes(data, callback);\n};\n\n/**\n * Update set of attributes\n *\n * this method performs validation before updating\n *\n * @trigger `validation`, `save` and `update` hooks\n * @param {Object} data - data to update\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.prototype.updateAttributes = function updateAttributes(data, callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    var inst = this;\n    var model = this.constructor.modelName;\n\n    if (!data) {\n        data = {};\n    }\n\n    // update instance's properties\n    Object.keys(data).forEach(function (key) {\n        inst[key] = data[key];\n    });\n\n    inst.isValid(function (valid) {\n        if (!valid) {\n            if (callback) {\n                callback(new Error('Validation error'), inst);\n            }\n        } else {\n            update();\n        }\n    });\n\n    function update() {\n        inst.trigger('save', function (saveDone) {\n            inst.trigger('update', function (done) {\n                Object.keys(data).forEach(function (key) {\n                    data[key] = inst[key];\n                });\n                inst._adapter().updateAttributes(model, inst.id, inst.constructor._forDB(data), function (err) {\n                    if (!err) {\n                        // update _was attrs\n                        Object.keys(data).forEach(function (key) {\n                            inst.__dataWas[key] = inst.__data[key];\n                        });\n                    }\n                    done.call(inst, function () {\n                        saveDone.call(inst, function () {\n                            callback(err, inst);\n                        });\n                    });\n                });\n            }, data);\n        });\n    }\n};\n\n/**\n * Update records\n * @param {Object} filter - update conditions\n * @param {Object} data - data to update\n * @param {Object} options - data to update\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.update = function update(filter, data, options, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    if (this.schema.adapter.update) {\n        var args = [this.modelName, filter, data];\n        if (options && typeof options !== 'function') args.push(options);\n        else if (typeof options === 'function') callback = options;\n        args.push(function (err, affected) {\n            affected = {affected: affected || 0};\n            if (err) {\n                p.reject(err);\n            } else {\n                p.resolve(affected);\n            }\n            return callback && callback(err, affected);\n        });\n        this.schema.adapter.update.apply(this.schema.adapter, args);\n    } else {\n        var err = new Error('Method update undefined for this adapter');\n        p.reject(err);\n        callback && callback(err);\n    }\n    return p.promise;\n};\n\nAbstractClass.prototype.fromObject = function (obj) {\n    Object.keys(obj).forEach(function (key) {\n        this[key] = obj[key];\n    }.bind(this));\n};\n\n/**\n * Checks is property changed based on current property and initial value\n *\n * @param {String} attr - property name\n * @return Boolean\n */\nAbstractClass.prototype.propertyChanged = function propertyChanged(attr) {\n    return this.__data[attr] !== this.__dataWas[attr];\n};\n\n/**\n * Reload object from persistence\n *\n * @requires `id` member of `object` to be able to call `find`\n * @param {Function} callback - called with (err, instance) arguments\n */\nAbstractClass.prototype.reload = function reload(callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    this.constructor.findById(this.id, callback);\n};\n\n/**\n * Reset dirty attributes\n *\n * this method does not perform any database operation it just reset object to it's\n * initial state\n */\nAbstractClass.prototype.reset = function () {\n    var obj = this;\n    Object.keys(obj).forEach(function (k) {\n        if (k !== 'id' && !obj.constructor.schema.definitions[obj.constructor.modelName].properties[k]) {\n            delete obj[k];\n        }\n        if (obj.propertyChanged(k)) {\n            obj[k] = obj[k + '_was'];\n        }\n    });\n};\n\n/**\n * Declare hasMany relation\n *\n * @param {Class} anotherClass - class to has many\n * @param {Object} params - configuration {as:, foreignKey:}\n * @example `User.hasMany(Post, {as: 'posts', foreignKey: 'authorId'});`\n */\nAbstractClass.hasMany = function hasMany(anotherClass, params) {\n    var methodName = params.as || pluralize(anotherClass.modelName);\n    var fk = params.foreignKey;\n\n    this.relations[methodName] = {\n        type: 'hasMany',\n        keyFrom: 'id',\n        keyTo: fk,\n        modelTo: anotherClass,\n        multiple: true\n    };\n\n    // each instance of this class should have method named\n    // which is actually just anotherClass.all({where: {thisModelNameId: this.id}}, cb);\n    defineScope(this.prototype, anotherClass, methodName, function () {\n        var x = {}, id;\n        if (this.id && typeof this.id === 'object') {\n            id = this.id.toString();\n        } else {\n            id = this.id;\n        }\n        x[fk] = id;\n        return {\n            where: x\n        };\n    }, {\n        find: find,\n        update: update,\n        destroy: destroy,\n        remove: remove\n    });\n\n    // obviously, anotherClass should have attribute called `fk`\n    anotherClass.schema.defineForeignKey(anotherClass.modelName, fk);\n\n    function find(query, callback) {\n        if (!callback && typeof query === 'function') {\n            callback = query;\n            query = {\n                where: {}\n            };\n        } else {\n            if (!query.where) {\n                query.where = {};\n            }\n        }\n        query.where[fk] = typeof this.id === 'object' ? this.id.toString() : this.id;\n        anotherClass.all(query, function (err, inst) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, inst);\n        }.bind(this));\n    }\n\n    function update(query, data, callback) {\n        if (!query.where) {\n            query.where = {};\n        }\n        query.where[fk] = typeof this.id === 'object' ? this.id.toString() : this.id;\n        anotherClass.update(query, data, function (err, inst) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, inst);\n        }.bind(this));\n    }\n\n    function remove(query, callback) {\n        if (!callback && typeof query === 'function') {\n            callback = query;\n            query = {\n                where: {}\n            };\n        } else {\n            if (!query.where) {\n                query.where = {};\n            }\n        }\n        query.where[fk] = typeof this.id === 'object' ? this.id.toString() : this.id;\n        anotherClass.remove(query, function (err, inst) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, inst);\n        }.bind(this));\n    }\n\n    function destroy(id, callback) {\n        id = typeof id === 'object' ? id.toString() : id;\n        this.findById(id, function (err, inst) {\n            if (err)\n                return callback(err);\n            if (inst) {\n                inst.destroy(callback);\n            } else {\n                callback(new Error('Not found'));\n            }\n        });\n    }\n};\n\n/**\n * Declare belongsTo relation\n *\n * @param {Class} anotherClass - class to belong\n * @param {Object} params - configuration {as: 'propertyName', foreignKey: 'keyName'}\n *\n * **Usage examples**\n * Suppose model Post have a *belongsTo* relationship with User (the author of the post). You could declare it this way:\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n *\n * When a post is loaded, you can load the related author with:\n * post.author(function(err, user) {\n *     // the user variable is your user object\n * });\n *\n * The related object is cached, so if later you try to get again the author, no additional request will be made.\n * But there is an optional boolean parameter in first position that set whether or not you want to reload the cache:\n * post.author(true, function(err, user) {\n *     // The user is reloaded, even if it was already cached.\n * });\n *\n * This optional parameter default value is false, so the related object will be loaded from cache if available.\n */\nAbstractClass.belongsTo = function (anotherClass, params) {\n    var modelName = this.modelName;\n    var methodName = params.as;\n    var fk = params.foreignKey;\n\n    this.relations[params['as']] = {\n        type: 'belongsTo',\n        keyFrom: params['foreignKey'],\n        keyTo: 'id',\n        modelTo: anotherClass,\n        multiple: false\n    };\n\n    this.schema.defineForeignKey(modelName, fk);\n    this.prototype['__finders__'] = this.prototype['__finders__'] || {};\n\n    this.prototype['__finders__'][methodName] = function (id, cb) {\n        if (id === null) {\n            cb(null, null);\n            return;\n        }\n        anotherClass.findById(id, function (err, inst) {\n            if (!inst) {\n                return cb(new Error(modelName + ' belongsTo ' + anotherClass.modelName + ' via foreign key ' + fk + ' error'));\n            }\n            var sid = typeof inst.id === 'object' ? inst.id.toString() : inst.id;\n            var fid = typeof this[fk] === 'object' ? this[fk].toString() : this[fk];\n            if (err) {\n                return cb(err);\n            }\n            if (!inst)\n                return cb(null, null);\n            if (sid === fid) {\n                cb(null, inst);\n            } else {\n                cb(new Error('Permission denied'));\n            }\n        }.bind(this));\n    };\n\n    this.prototype[methodName] = function (refresh, p) {\n        if (arguments.length === 1) {\n            p = refresh;\n            refresh = false;\n        } else if (arguments.length > 2) {\n            throw new Error('Method can\\'t be called with more than two arguments');\n        }\n        var self = this;\n        var cachedValue;\n        if (!refresh && this.__cachedRelations && (typeof this.__cachedRelations[methodName] !== 'undefined')) {\n            cachedValue = this.__cachedRelations[methodName];\n        }\n        if (p instanceof AbstractClass) { // acts as setter\n            this[fk] = p.id;\n            this.__cachedRelations[methodName] = p;\n        } else if (typeof p === 'function') { // acts as async getter\n            if (typeof cachedValue === 'undefined') {\n                this.__finders__[methodName].apply(self, [this[fk], function (err, inst) {\n                    if (!err) {\n                        self.__cachedRelations[methodName] = inst;\n                    }\n                    p(err, inst);\n                }]);\n                return this[fk];\n            } else {\n                p(null, cachedValue);\n                return cachedValue;\n            }\n        } else if (typeof p === 'undefined') { // acts as sync getter\n            return this[fk];\n        } else { // setter\n            this[fk] = p;\n            delete this.__cachedRelations[methodName];\n        }\n    };\n};\n\n/**\n * Define scope\n * TODO: describe behavior and usage examples\n *\n * @param {String} name - scope name\n * @param {Object} params - scope condition\n */\nAbstractClass.scope = function (name, params) {\n    defineScope(this, this, name, params);\n};\n\nfunction defineScope(cls, targetClass, name, params, methods) {\n\n    // collect meta info about scope\n    if (!cls._scopeMeta) {\n        cls._scopeMeta = {};\n    }\n\n    // only makes sence to add scope in meta if base and target classes\n    // are same\n    if (cls === targetClass) {\n        cls._scopeMeta[name] = params;\n    } else {\n        if (!targetClass._scopeMeta) {\n            targetClass._scopeMeta = {};\n        }\n    }\n\n    Object.defineProperty(cls, name, {\n        enumerable: false,\n        configurable: true,\n        get: function () {\n            var f = function caller(condOrRefresh, cb) {\n                var actualCond = {};\n                var actualRefresh = false;\n                var saveOnCache = true;\n                if (arguments.length === 1) {\n                    cb = condOrRefresh;\n                } else if (arguments.length === 2) {\n                    if (typeof condOrRefresh === 'boolean') {\n                        actualRefresh = condOrRefresh;\n                    } else {\n                        actualCond = condOrRefresh;\n                        actualRefresh = true;\n                        saveOnCache = false;\n                    }\n                } else {\n                    throw new Error('Method can be only called with one or two arguments');\n                }\n\n                if (!this.__cachedRelations || (typeof this.__cachedRelations[name] === 'undefined') || actualRefresh) {\n                    var self = this;\n                    return targetClass.all(mergeParams(actualCond, caller._scope), function (err, data) {\n                        if (!err && saveOnCache) {\n                            self.__cachedRelations[name] = data;\n                        }\n                        cb(err, data);\n                    });\n                } else {\n                    cb(null, this.__cachedRelations[name]);\n                }\n            };\n\n            f._scope = typeof params === 'function' ? params.call(this) : params;\n            f.build = build;\n            f.create = create;\n            f.destroy = destroy;\n            f.destroyAll = destroyAll;\n            for (var i in methods) {\n                f[i] = methods[i].bind(this);\n            }\n\n            // define sub-scopes\n            Object.keys(targetClass._scopeMeta).forEach(function (name) {\n                Object.defineProperty(f, name, {\n                    enumerable: false,\n                    get: function () {\n                        mergeParams(f._scope, targetClass._scopeMeta[name]);\n                        return f;\n                    }\n                });\n            }.bind(this));\n            return f;\n        }\n    });\n\n    // and it should have create/build methods with binded thisModelNameId param\n    function build(data) {\n        return new targetClass(mergeParams(this._scope, {\n            where: data || {}\n        }).where);\n    }\n\n    function create(data, cb) {\n        if (typeof data === 'function') {\n            cb = data;\n            data = {};\n        }\n        this.build(data).save(cb);\n    }\n\n    function destroy(id, callback) {\n        if (callback) {\n            // TODO: impement\n            callback();\n        }\n    }\n\n    /*\n     Callback\n     - The callback will be called after all elements are destroyed\n     - For every destroy call which results in an error\n     - If fetching the Elements on which destroyAll is called results in an error\n     */\n    function destroyAll(callback) {\n        targetClass.all(this._scope, function (err, data) {\n            if (err) {\n                callback(err);\n            } else {\n                (function loopOfDestruction(data) {\n                    if (data.length > 0) {\n                        data.shift().destroy(function (err) {\n                            if (err && callback)\n                                callback(err);\n                            loopOfDestruction(data);\n                        });\n                    } else {\n                        if (callback)\n                            callback();\n                    }\n                }(data));\n            }\n        });\n    }\n\n    function mergeParams(base, update) {\n        if (update && !update.where) {\n            update = {\n                where: update\n            };\n        }\n        if (update.where) {\n            base.where = helpers.merge(base.where, update.where);\n        }\n        // overwrite order\n        if (update.order) {\n            base.order = update.order;\n        }\n        return base;\n    }\n}\n\nAbstractClass.prototype.inspect = function () {\n    return util.inspect(this.__data, false, 4, true);\n};\n\n/**\n * Create index in collection\n *\n * @param {String|Object} fields - index name\n * @param {Object} params - indexed fields list { name : 1, created : -1 }\n * @param {Function} callback - callbacl called with (err, exists: Bool)\n */\nAbstractClass.ensureIndex = function ensureIndex(fields, params, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    if (typeof callback === 'undefined') {\n        callback = function (err) {\n            return err;\n        };\n    }\n\n    if (typeof params === 'object') {\n        if (typeof this.schema.adapter.ensureIndex === 'undefined') {\n            callback(new Error('Model::ensureIndex not defined for this adapter'));\n        } else {\n            this.schema.adapter.ensureIndex(this.modelName, fields, params, callback);\n        }\n    } else {\n        callback(new Error('Model::ensureIndex requires params argument'));\n    }\n};\n\nfunction buildQuery(opts, model) {\n\n    for (var okey in model.q.conditions) {\n        if (typeof opts.where === 'undefined') {\n            opts.where = {};\n        }\n        opts.where[okey] = model.q.conditions[okey];\n    }\n    model.q.conditions = {};\n\n    for (var pkey in model.q.params) {\n        if (typeof opts[pkey] === 'undefined') {\n            opts[pkey] = {};\n        }\n        opts[pkey] = model.q.params[pkey];\n    }\n    model.q.params = {};\n    model.q.pkey = false;\n    return opts;\n}\n\n/**\n * Check whether `s` is not undefined\n * @param {Mixed} s\n * @return {Boolean} s is undefined\n */\nfunction isdef(s) {\n    var undef;\n    return s !== undef;\n}\n\n/**\n * Define readonly property on object\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Mixed} value\n */\nfunction defineReadonlyProp(obj, key, value) {\n    Object.defineProperty(obj, key, {\n        writable: false,\n        enumerable: true,\n        configurable: true,\n        value: value\n    });\n}\n\n/**\n * Normalize id\n *\n * @param {Mixed} id\n */\nfunction getInstanceId(id) {\n    if (typeof id === 'object' && id.constructor === Array) {\n        id = id[0];\n    }\n    return id;\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/validatable.js":"exports.Validatable = Validatable;\n\n/**\n * Validation encapsulated in this abstract class.\n *\n * Basically validation configurators is just class methods, which adds validations\n * configs to AbstractClass._validations. Each of this validations run when\n * `obj.isValid()` method called.\n *\n * Each configurator can accept n params (n-1 field names and one config). Config\n * is {Object} depends on specific validation, but all of them has one common part:\n * `message` member. It can be just string, when only one situation possible,\n * e.g. `Post.validatesPresenceOf('title', { message: 'can not be blank' });`\n *\n * In more complicated cases it can be {Hash} of messages (for each case):\n * `User.validatesLengthOf('password', { min: 6, max: 20, message: {min: 'too short', max: 'too long'}});`\n */\nfunction Validatable() {\n    // validatable class\n};\n\n/**\n * Validate presence. This validation fails when validated field is blank.\n *\n * Default error message \"can't be blank\"\n *\n * @example presence of title\n * ```\n * Post.validatesPresenceOf('title');\n * ```\n * @example with custom message\n * ```\n * Post.validatesPresenceOf('title', {message: 'Can not be blank'});\n * ```\n *\n * @sync\n *\n * @nocode\n * @see helper/validatePresence\n */\nValidatable.validatesPresenceOf = getConfigurator('presence');\n\n/**\n * Validate length. Three kinds of validations: min, max, is.\n *\n * Default error messages:\n *\n * - min: too short\n * - max: too long\n * - is:  length is wrong\n *\n * @example length validations\n * ```\n * User.validatesLengthOf('password', {min: 7});\n * User.validatesLengthOf('email', {max: 100});\n * User.validatesLengthOf('state', {is: 2});\n * User.validatesLengthOf('nick', {min: 3, max: 15});\n * ```\n * @example length validations with custom error messages\n * ```\n * User.validatesLengthOf('password', {min: 7, message: {min: 'too weak'}});\n * User.validatesLengthOf('state', {is: 2, message: {is: 'is not valid state name'}});\n * ```\n *\n * @sync\n * @nocode\n * @see helper/validateLength\n */\nValidatable.validatesLengthOf = getConfigurator('length');\n\n/**\n * Validate numericality.\n *\n * @example\n * ```\n * User.validatesNumericalityOf('age', { message: { number: '...' }});\n * User.validatesNumericalityOf('age', {int: true, message: { int: '...' }});\n * ```\n *\n * Default error messages:\n *\n * - number: is not a number\n * - int: is not an integer\n *\n * @sync\n * @nocode\n * @see helper/validateNumericality\n */\nValidatable.validatesNumericalityOf = getConfigurator('numericality');\n\n/**\n * Validate inclusion in set\n *\n * @example\n * ```\n * User.validatesInclusionOf('gender', {in: ['male', 'female']});\n * User.validatesInclusionOf('role', {\n *     in: ['admin', 'moderator', 'user'], message: 'is not allowed'\n * });\n * ```\n *\n * Default error message: is not included in the list\n *\n * @sync\n * @nocode\n * @see helper/validateInclusion\n */\nValidatable.validatesInclusionOf = getConfigurator('inclusion');\n\n/**\n * Validate exclusion\n *\n * @example `Company.validatesExclusionOf('domain', {in: ['www', 'admin']});`\n *\n * Default error message: is reserved\n *\n * @nocode\n * @see helper/validateExclusion\n */\nValidatable.validatesExclusionOf = getConfigurator('exclusion');\n\n/**\n * Validate format\n *\n * Default error message: is invalid\n *\n * @nocode\n * @see helper/validateFormat\n */\nValidatable.validatesFormatOf = getConfigurator('format');\n\n/**\n * Validate using custom validator\n *\n * Default error message: is invalid\n *\n * Example:\n *\n *     User.validate('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err) {\n *         if (this.name === 'bad') err();\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // true\n *     user.name = 'bad';\n *     user.isValid(); // false\n *\n * @nocode\n * @see helper/validateCustom\n */\nValidatable.validate = getConfigurator('custom');\n\n/**\n * Validate using custom async validator\n *\n * Default error message: is invalid\n *\n * Example:\n *\n *     User.validateAsync('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err, done) {\n *         process.nextTick(function () {\n *             if (this.name === 'bad') err();\n *             done();\n *         });\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // false (because async validation setup)\n *     user.isValid(function (isValid) {\n *         isValid; // true\n *     })\n *     user.name = 'bad';\n *     user.isValid(); // false\n *     user.isValid(function (isValid) {\n *         isValid; // false\n *     })\n *\n * @async\n * @nocode\n * @see helper/validateCustom\n */\nValidatable.validateAsync = getConfigurator('custom', {async: true});\n\n/**\n * Validate uniqueness\n *\n * Default error message: is not unique\n *\n * @async\n * @nocode\n * @see helper/validateUniqueness\n */\nValidatable.validatesUniquenessOf = getConfigurator('uniqueness', {async: true});\n\n// implementation of validators\n\n/**\n * Presence validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validatePresence(attr, conf, err) {\n    if (blank(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Length validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateLength(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    var len = this[attr].length;\n    if (conf.min && len < conf.min) {\n        err('min');\n    }\n    if (conf.max && len > conf.max) {\n        err('max');\n    }\n    if (conf.is && len !== conf.is) {\n        err('is');\n    }\n}\n\n/**\n * Numericality validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateNumericality(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (typeof this[attr] !== 'number') {\n        return err('number');\n    }\n    if (conf.int && this[attr] !== Math.round(this[attr])) {\n        return err('int');\n    }\n}\n\n/**\n * Inclusion validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateInclusion(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (!~conf.in.indexOf(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Exclusion validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateExclusion(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (~conf.in.indexOf(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Format validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateFormat(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n    if (typeof this[attr] === 'string') {\n        if (!this[attr].match(conf['with'])) {\n            err();\n        }\n    } else {\n        err();\n    }\n}\n\n/**\n * Custom validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n * @param {Function} done\n */\nfunction validateCustom(attr, conf, err, done) {\n    conf.customValidator.call(this, err, done);\n}\n\n/**\n * Uniqueness validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n * @param {Function} done\n */\nfunction validateUniqueness(attr, conf, err, done) {\n    var cond = {where: {}};\n    cond.where[attr] = this[attr];\n    this.constructor.all(cond, function (error, found) {\n        if (found.length > 1) {\n            err();\n        } else if (found.length === 1 && (!this.id || !found[0].id || found[0].id.toString() !== this.id.toString())) {\n            err();\n        }\n        done();\n    }.bind(this));\n}\n\nvar validators = {\n    presence: validatePresence,\n    length: validateLength,\n    numericality: validateNumericality,\n    inclusion: validateInclusion,\n    exclusion: validateExclusion,\n    format: validateFormat,\n    custom: validateCustom,\n    uniqueness: validateUniqueness\n};\n\nfunction getConfigurator(name, opts) {\n    return function () {\n        configure(this, name, arguments, opts);\n    };\n}\n\n/**\n * This method performs validation, triggers validation hooks.\n * Before validation `obj.errors` collection cleaned.\n * Each validation can add errors to `obj.errors` collection.\n * If collection is not blank, validation failed.\n *\n * @warning This method can be called as sync only when no async validation\n * configured. It's strongly recommended to run all validations as asyncronous.\n *\n * @param {Function} callback called with (valid)\n * @return {Boolean} true if no async validation configured and all passed\n *\n * @example ExpressJS controller: render user if valid, show flash otherwise\n * ```\n * user.isValid(function (valid) {\n *     if (valid) res.render({user: user});\n *     else res.flash('error', 'User is not valid'), console.log(user.errors), res.redirect('/users');\n * });\n * ```\n */\nValidatable.prototype.isValid = function (callback) {\n    var valid = true, inst = this, wait = 0, async = false;\n\n    // exit with success when no errors\n    if (!this.constructor._validations) {\n        cleanErrors(this);\n        if (callback) {\n            callback(valid);\n        }\n        return valid;\n    }\n\n    Object.defineProperty(this, 'errors', {\n        enumerable: false,\n        configurable: true,\n        value: new Errors\n    });\n\n    this.trigger('validation', function (validationsDone) {\n        var inst = this;\n        this.constructor._validations.forEach(function (v) {\n            if (v[2] && v[2].async) {\n                async = true;\n                wait += 1;\n                validationFailed(inst, v, done);\n            } else {\n                if (validationFailed(inst, v)) {\n                    valid = false;\n                }\n            }\n        });\n\n        if (!async) {\n            validationsDone();\n        }\n\n        var asyncFail = false;\n\n        function done(fail) {\n            asyncFail = asyncFail || fail;\n            if (--wait === 0 && callback) {\n                validationsDone.call(inst, function () {\n                    if (valid && !asyncFail) cleanErrors(inst);\n                    callback(valid && !asyncFail);\n                });\n            }\n        }\n\n    });\n\n    if (!async) {\n        if (valid) cleanErrors(this);\n        if (callback) callback(valid);\n        return valid;\n    } else {\n        // in case of async validation we should return undefined here,\n        // because not all validations are finished yet\n        return;\n    }\n\n};\n\nfunction cleanErrors(inst) {\n    Object.defineProperty(inst, 'errors', {\n        enumerable: false,\n        configurable: true,\n        value: false\n    });\n}\n// 43903\n// 44471\nfunction validationFailed(inst, v, cb) {\n    var attr = v[0];\n    var conf = v[1];\n    var opts = v[2] || {};\n\n    if (typeof attr !== 'string') return false;\n\n    // here we should check skip validation conditions (if, unless)\n    // that can be specified in conf\n    if (skipValidation(inst, conf, 'if')) return false;\n    if (skipValidation(inst, conf, 'unless')) return false;\n\n    var fail = false;\n    var validator = validators[conf.validation];\n    var validatorArguments = [];\n    validatorArguments.push(attr);\n    validatorArguments.push(conf);\n    validatorArguments.push(function onerror(kind) {\n        var message;\n        if (conf.message) {\n            message = conf.message;\n        }\n        if (!message && defaultMessages[conf.validation]) {\n            message = defaultMessages[conf.validation];\n        }\n        if (!message) {\n            message = 'is invalid';\n        }\n        if (kind) {\n            if (message[kind]) {\n                // get deeper\n                message = message[kind];\n            } else if (defaultMessages.common[kind]) {\n                message = defaultMessages.common[kind];\n            }\n        }\n        inst.errors.add(attr, message);\n        fail = true;\n        if (cb) {\n            return cb && cb(fail);\n        }\n    });\n    if (cb) {\n        validatorArguments.push(function onsuccess() {\n            return cb && cb(fail);\n        });\n    }\n    validator.apply(inst, validatorArguments);\n    return fail;\n}\n\nfunction skipValidation(inst, conf, kind) {\n    var doValidate = true;\n    if (typeof conf[kind] === 'function') {\n        doValidate = conf[kind].call(inst);\n        if (kind === 'unless') doValidate = !doValidate;\n    } else if (typeof conf[kind] === 'string') {\n        if (typeof inst[conf[kind]] === 'function') {\n            doValidate = inst[conf[kind]].call(inst);\n            if (kind === 'unless') doValidate = !doValidate;\n        } else if (inst.__data.hasOwnProperty(conf[kind])) {\n            doValidate = inst[conf[kind]];\n            if (kind === 'unless') doValidate = !doValidate;\n        } else {\n            doValidate = kind === 'if';\n        }\n    }\n    return !doValidate;\n}\n\nvar defaultMessages = {\n    presence: 'can\\'t be blank',\n    length: {\n        min: 'too short',\n        max: 'too long',\n        is: 'length is wrong'\n    },\n    common: {\n        blank: 'is blank',\n        'null': 'is null'\n    },\n    numericality: {\n        'int': 'is not an integer',\n        'number': 'is not a number'\n    },\n    inclusion: 'is not included in the list',\n    exclusion: 'is reserved',\n    uniqueness: 'is not unique'\n};\n\nfunction nullCheck(attr, conf, err) {\n    var isNull = this[attr] === null || !(attr in this);\n    if (isNull) {\n        if (!conf.allowNull) {\n            err('null');\n        }\n        return true;\n    } else {\n        if (blank(this[attr])) {\n            if (!conf.allowBlank) {\n                err('blank');\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Return true when v is undefined, blank array, null or empty string\n * otherwise returns false\n *\n * @param {Mix} v\n * @returns {Boolean} whether `v` blank or not\n */\nfunction blank(v) {\n    if (typeof v === 'undefined') return true;\n    if (v instanceof Array && v.length === 0) return true;\n    if (v === null) return true;\n    if (typeof v === 'string' && v === '') return true;\n    return false;\n}\n\nfunction configure(cls, validation, args, opts) {\n    if (!cls._validations) {\n        Object.defineProperty(cls, '_validations', {\n            writable: true,\n            configurable: true,\n            enumerable: false,\n            value: []\n        });\n    }\n    args = [].slice.call(args);\n    var conf;\n    if (typeof args[args.length - 1] === 'object') {\n        conf = args.pop();\n    } else {\n        conf = {};\n    }\n    if (validation === 'custom' && typeof args[args.length - 1] === 'function') {\n        conf.customValidator = args.pop();\n    }\n    conf.validation = validation;\n    args.forEach(function (attr) {\n        cls._validations.push([attr, conf, opts]);\n    });\n}\n\nfunction Errors() {\n}\n\nErrors.prototype.add = function (field, message) {\n    if (!this[field]) {\n        this[field] = [message];\n    } else {\n        this[field].push(message);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/hookable.js":"exports.Hookable = Hookable;\n\nfunction Hookable() {\n// hookable class\n};\n\nHookable.afterInitialize = null;\nHookable.beforeValidation = null;\nHookable.afterValidation = null;\nHookable.beforeSave = null;\nHookable.afterSave = null;\nHookable.beforeCreate = null;\nHookable.afterCreate = null;\nHookable.beforeUpdate = null;\nHookable.afterUpdate = null;\nHookable.beforeDestroy = null;\nHookable.afterDestroy = null;\n\nHookable.prototype.trigger = function trigger(actionName, work, data) {\n    var capitalizedName = capitalize(actionName);\n    var afterHook = this.constructor[\"after\" + capitalizedName];\n    var beforeHook = this.constructor[\"before\" + capitalizedName];\n    var inst = this;\n\n    // we only call \"before\" hook when we have actual action (work) to perform\n    if (work) {\n        if (beforeHook) {\n            // before hook should be called on instance with one param: callback\n            beforeHook.call(inst, function () {\n                // actual action also have one param: callback\n                work.call(inst, next);\n            }, data);\n        } else {\n            work.call(inst, next);\n        }\n    } else {\n        next();\n    }\n\n    function next(done) {\n        if (afterHook) {\n            afterHook.call(inst, done);\n        } else if (done) {\n            done.call(this);\n        }\n    }\n};\n\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/query.js":"/*\n * Copyright 2013 Aelxey Gordeyev <aleksej@gordejev.lv>.\n */\n\n/**\n * Module dependencies.\n */\nvar utils = require('./utils');\nvar helpers = utils.helpers;\n\n/**\n * Query class\n *\n * @api private\n *\n * @param {Object} model\n * @param {String} action\n * @param {mixed} conditions\n */\nfunction Query(model, action, conditions) {\n    var self = this;\n    self.model = model;\n    self.action = action || 'all';\n    self.q = {\n        conditions: {},\n        params: {},\n        pkey: false,\n        fields: false\n    };\n    if (typeof conditions === 'object') {\n        self.q.conditions = helpers.merge(self.q.conditions, conditions);\n    }\n\n    ['all', 'run', 'exec'].forEach(function(method) {\n        self[method] = function(params, callback) {\n            if (arguments.length === 1) {\n                callback = params;\n                params = {};\n            }\n            params = buildQuery(params, this);\n            var action = self.action ? self.action : 'all';\n            self.model[action](params, callback);\n        };\n    });\n\n    ['find', 'findOne'].forEach(function(method) {\n        self[method] = function(params, callback) {\n            if (arguments.length === 1) {\n                callback = params;\n                params = {};\n            }\n            params = buildQuery(params, this);\n            self.model[method](params, callback);\n        };\n    });\n\n    ['skip', 'limit', 'order', 'sort', 'group'].forEach(function(method) {\n        self[method] = function(key, value) {\n            this.q.pkey = false;\n            if (method === 'sort') {\n                method = 'order';\n            }\n            if (typeof value === 'undefined') {\n                if (/^-/.test(key)) {\n                    this.q.params[method] = key.replace(/^-/, \"\") + ' DESC';\n                } else {\n                    this.q.params[method] = key;\n                }\n            } else {\n                this.q.params[method] = key + ' ' + value;\n            }\n            return this;\n        };\n    });\n\n    self.asc = function(value) {\n        this.q.pkey = false;\n        this.q.params['order'] = value + ' ASC';\n        return this;\n    };\n\n    self.desc = function(value) {\n        this.q.pkey = false;\n        this.q.params['order'] = value + ' DESC';\n        return this;\n    };\n\n    self.where = function(key, value) {\n        if (typeof value === 'undefined') {\n            this.q.pkey = key;\n        } else {\n            this.q.pkey = false;\n            this.q.conditions[key] = value;\n        }\n        return this;\n    };\n\n    self.or = function(values) {\n        if (Array.isArray(values)) {\n            this.q.conditions['or'] = values;\n        }\n        return this;\n    };\n\n    self.range = function(key, from, to) {\n        if (typeof to === 'undefined') {\n            if (this.q.pkey) {\n                to = from;\n                from = key;\n                if (typeof this.q.conditions[this.q.pkey] === 'undefined') {\n                    this.q.conditions[this.q.pkey] = {};\n                }\n                this.q.conditions[this.q.pkey].gt = from;\n                this.q.conditions[this.q.pkey].lt = to;\n            }\n        } else {\n            this.q.pkey = false;\n            if (typeof this.q.conditions[key] === 'undefined') {\n                this.q.conditions[key] = {};\n            }\n            this.q.conditions[key].gt = from;\n            this.q.conditions[key].lt = to;\n        }\n        return this;\n    };\n\n    ['gt', 'gte', 'lt', 'lte', 'in', 'inq', 'ne', 'neq', 'nin', 'regex', 'like', 'nlike', 'between'].forEach(function(method) {\n        self[method] = function(key, value) {\n            if (typeof value === 'undefined') {\n                if (this.q.pkey) {\n                    if (typeof this.q.conditions[this.q.pkey] === 'undefined') {\n                        this.q.conditions[this.q.pkey] = {};\n                    }\n                    this.q.conditions[this.q.pkey][method] = key;\n                }\n            } else {\n                this.q.pkey = false;\n                if (typeof this.q.conditions[key] === 'undefined') {\n                    this.q.conditions[key] = {};\n                }\n                this.q.conditions[key][method] = value;\n            }\n            return this;\n        };\n    });\n\n    self.slice = function(values) {\n        if (Array.isArray(values)) {\n            if (typeof values[1] === 'undefined') {\n                this.q.params['limit'] = values[0];\n            } else {\n                this.q.params['skip'] = values[0];\n                this.q.params['limit'] = values[1];\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Destroy records\n     * @param {Object} params\n     * @param {Function} callback\n     */\n    self.remove = function(params, callback) {\n        if (arguments.length === 1) {\n            callback = params;\n            params = {};\n        }\n        params = buildQuery(params, this);\n        self.model.remove(params, callback);\n    };\n\n    function buildQuery(opts, query) {\n        if (typeof opts.where === 'undefined') {\n            opts.where = {};\n        }\n        opts.where = helpers.merge(opts.where, query.q.conditions);\n        query.q.conditions = {};\n\n        for (var pkey in query.q.params) {\n            if (typeof opts[pkey] === 'undefined') {\n                opts[pkey] = {};\n            }\n            opts[pkey] = query.q.params[pkey];\n        }\n\n        query.q.params = {};\n        query.q.pkey = false;\n        return opts;\n    }\n}\n\n/**\n * Exports.\n */\n\nmodule.exports = exports = Query;","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/list.js":"\nmodule.exports = List;\n\nfunction List(data, type, parent) {\n    var list = this;\n\n    Object.defineProperty(list, 'parent', {\n        writable: false,\n        enumerable: false,\n        configurable: false,\n        value: parent\n    });\n\n    Object.defineProperty(list, 'nextid', {\n        writable: true,\n        enumerable: false,\n        value: 1\n    });\n\n    data = list.items = data || [];\n    var Item = list.ItemType = ListItem;\n\n    if (typeof type === 'object' && type.constructor.name === 'Array') {\n        list.ItemType = type[0] || ListItem;\n    }\n\n    data.forEach(function (item, i) {\n        data[i] = new Item(item, list);\n        Object.defineProperty(list, data[i].id, {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value:  data[i]\n        });\n        if (list.nextid <= data[i].id) {\n            list.nextid = data[i].id + 1;\n        }\n    });\n\n    Object.defineProperty(list, 'length', {\n        enumerable: false,\n        configurable: true,\n        get: function () {\n            return list.items.length;\n        }\n    });\n\n    return list;\n}\n\nvar _;\ntry {\n    _ = require('underscore');\n} catch (e) {\n    _ = false;\n}\n\nif (_) {\n    var _import = [\n    // collection methods\n    'each',\n    'map',\n    'reduce',\n    'reduceRight',\n    'find',\n    'filter',\n    'reject',\n    'all',\n    'any',\n    'include',\n    'invoke',\n    'pluck',\n    'max',\n    'min',\n    'sortBy',\n    'groupBy',\n    'sortedIndex',\n    'shuffle',\n    'toArray',\n    'size',\n    // array methods\n    'first',\n    'initial',\n    'last',\n    'rest',\n    'compact',\n    'flatten',\n    'without',\n    'union',\n    'intersection',\n    'difference',\n    'uniq',\n    'zip',\n    'indexOf',\n    'lastIndexOf',\n    'range'\n    ];\n\n    _import.forEach(function (name) {\n        List.prototype[name] = function () {\n            var args = [].slice.call(arguments);\n            args.unshift(this.items);\n            return _[name].apply(_, args);\n        };\n    });\n}\n\nList.prototype.toObject = function () {\n    return this.items;\n};\n\nList.prototype.toJSON = function () {\n    return this.items;\n};\n\nList.prototype.toString = function () {\n    return JSON.stringify(this.items);\n};\n\nList.prototype.autoincrement = function () {\n    return this.nextid++;\n};\n\nList.prototype.push = function (obj) {\n    var item = new ListItem(obj, this);\n    this.items.push(item);\n    return item;\n};\n\nList.prototype.remove = function (obj) {\n    var id = obj.id ? obj.id : obj;\n    var found = false;\n    this.items.forEach(function (o, i) {\n        if (id && o.id === id) {\n            found = i;\n            if (o.id !== id) {\n                console.log('WARNING! Type of id not matched');\n            }\n        }\n    });\n    if (found !== false) {\n        delete this[id];\n        this.items.splice(found, 1);\n    }\n};\n\nList.prototype.forEach = function (cb) {\n    this.items.forEach(cb);\n};\n\nList.prototype.sort = function (cb) {\n    return this.items.sort(cb);\n};\n\nList.prototype.map = function (cb) {\n    if (typeof cb === 'function') return this.items.map(cb);\n    if (typeof cb === 'string') return this.items.map(function (el) {\n        if (typeof el[cb] === 'function') return el[cb]();\n        if (el.hasOwnProperty(cb)) return el[cb];\n    });\n};\n\nfunction ListItem(data, parent) {\n    for (var i in data) this[i] = data[i];\n    Object.defineProperty(this, 'parent', {\n        writable: false,\n        enumerable: false,\n        configurable: true,\n        value: parent\n    });\n    if (!this.id) {\n        this.id = parent.autoincrement();\n    }\n    if (parent.ItemType) {\n        this.__proto__ = parent.ItemType.prototype;\n        if (parent.ItemType !== ListItem) {\n            parent.ItemType.apply(this);\n        }\n    }\n\n    this.save = function (c) {\n        parent.parent.save(c);\n    };\n}","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/sql.js":"module.exports = BaseSQL;\n\n/**\n * Base SQL class\n */\nfunction BaseSQL() {\n}\n\nBaseSQL.prototype.query = function () {\n    throw new Error('query method should be declared in adapter');\n};\n\nBaseSQL.prototype.command = function (sql, callback) {\n    return this.query(sql, callback);\n};\n\nBaseSQL.prototype.queryOne = function (sql, callback) {\n    return this.query(sql, function (err, data) {\n        if (err) {\n            return callback && callback(err);\n        }\n        return callback && callback(err, data[0]);\n    });\n};\n\nBaseSQL.prototype.table = function (model) {\n    return this._models[model].model.schema.tableName(model);\n};\n\nBaseSQL.prototype.escapeName = function (name) {\n    throw new Error('escapeName method should be declared in adapter');\n};\n\nBaseSQL.prototype.tableEscaped = function (model) {\n    return this.escapeName(this.table(model));\n};\n\nBaseSQL.prototype.define = function (descr) {\n    if (!descr.settings) {\n        descr.settings = {};\n    }\n    this._models[descr.model.modelName] = descr;\n};\n\nBaseSQL.prototype.defineProperty = function (model, prop, params) {\n    this._models[model].properties[prop] = params;\n};\n\nBaseSQL.prototype.save = function (model, data, callback) {\n    var sql = 'UPDATE ' + this.tableEscaped(model) + ' SET ' + this.toFields(model, data) + ' WHERE ' + this.escapeName('id') + ' = ' + data.id;\n    this.query(sql, function (err) {\n        return callback && callback(err);\n    });\n};\n\nBaseSQL.prototype.exists = function (model, id, callback) {\n    id = getInstanceId(id);\n    var sql = 'SELECT 1 FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + id + ' LIMIT 1';\n\n    this.query(sql, function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        return callback && callback(null, data.length === 1);\n    });\n};\n\nBaseSQL.prototype.findById = function findById(model, id, callback) {\n    id = getInstanceId(id);\n    var self = this;\n    var sql = 'SELECT * FROM ' +\n        self.tableEscaped(model) + ' WHERE ' +\n        self.escapeName('id') + ' = ' + id + ' LIMIT 1';\n\n    self.query(sql, function (err, data) {\n        if (data && data.length === 1) {\n            data[0].id = id;\n        } else {\n            data = [null];\n        }\n        return callback && callback(err, self.fromDatabase(model, data[0]));\n    }.bind(self));\n};\n\nBaseSQL.prototype.remove = function remove(model, cond, callback) {\n    var self = this, sql = 'DELETE FROM ' + this.tableEscaped(model) + ' ';\n    if (!cond) {\n        cond = {};\n    }\n    if (cond.where) {\n        sql += self.buildWhere(cond.where, self, model);\n        self.command(sql, function (err) {\n            return callback && callback(err);\n        });\n    } else {\n        return callback && callback('Undefined cond.where');\n    }\n};\n\nBaseSQL.prototype.destroy = function destroy(model, id, callback) {\n    var sql = 'DELETE FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + getInstanceId(id);\n    this.command(sql, function (err) {\n        return callback && callback(err);\n    });\n};\n\nBaseSQL.prototype.destroyAll = function destroyAll(model, callback) {\n    this.command('DELETE FROM ' + this.tableEscaped(model), function (err) {\n        if (err) {\n            return callback && callback(err, []);\n        }\n        return callback && callback(err, []);\n    }.bind(this));\n};\n\nBaseSQL.prototype.count = function count(model, callback, cond) {\n    var self = this, sql = 'SELECT count(*) as cnt FROM ' + self.tableEscaped(model) + ' ';\n    if (cond && cond.where) {\n        sql += self.buildWhere(cond.where, self, model);\n    }\n    self.queryOne(sql, function (err, res) {\n        if (err) {\n            return callback && callback(err);\n        }\n        var cnt = parseInt(res && res.cnt || 0);\n        return callback && callback(err, cnt);\n    });\n};\n\nBaseSQL.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\n    data.id = getInstanceId(id);\n    this.save(model, data, cb);\n};\n\nBaseSQL.prototype.disconnect = function disconnect() {\n    this.client.end();\n};\n/**\n * Re create existing database tables.\n * @param {Function} cb\n */\nBaseSQL.prototype.automigrate = function (cb) {\n    var self = this;\n    var wait = 0;\n\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.dropTable(model, function (err) {\n            if (err) {\n                console.log(err);\n            }\n            self.createTable(model, function (err) {\n                if (err) {\n                    console.log(err);\n                }\n                return done && done();\n            });\n        });\n    });\n    if (wait === 0) {\n        cb();\n    }\n    function done() {\n        if (--wait === 0 && cb) {\n            cb();\n        }\n    }\n};\n\nBaseSQL.prototype.dropTable = function (model, cb) {\n    this.command('DROP TABLE IF EXISTS ' + this.tableEscaped(model), cb);\n};\n\nBaseSQL.prototype.createTable = function (model, indexes, cb) {\n    var self = this, m = self._models[model];\n    if ('function' === typeof indexes) {\n        cb = indexes;\n    }\n    var sql = 'CREATE TABLE ' + self.tableEscaped(model) +\n        ' (\\n  ' + self.propertiesSQL(model) + '\\n)';\n    if (self.name === 'mysql') {\n        sql += ' CHARSET=utf8;';\n    } else if (self.name === 'pg') {\n        // TODO\n        // sql = 'PRAGMA encoding = \"UTF-8\"; ' + sql;\n    } else if (self.name === 'cassandra') {\n        // add sorting indexes\n        if (m.settings.orderBy && m.settings.orderBy.columns) {\n            var oda = m.settings.orderBy;\n            var odd = oda.direction ? oda.direction.toUpperCase() : 'ASC';\n            sql += ' WITH CLUSTERING ORDER BY (' + oda.columns + ' ' + odd + ')';\n        }\n    }\n\n    try {\n        self.command(sql, function (err) {\n            if (err) {\n                // console.log('ERROR CREATE TABLE 1: ', model, sql, err);\n            }\n            //  || self.name === 'cassandra'\n            if (self.name === 'sqlite3' || self.name === 'mysql') {\n                self.createIndexes(model, self._models[model], cb);\n            } else {\n                return cb && cb();\n            }\n        });\n    } catch (err) {\n        // console.log('ERROR CREATE TABLE 2: ', model, sql, err);\n        return cb && cb();\n    }\n};\n\n/**\n * Normalize id\n *\n * @param {Mixed} id\n */\nfunction getInstanceId(id) {\n    if (typeof id === 'object' && id.constructor === Array) {\n        id = id[0];\n    }\n    return id;\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/solr.js":"/**\n * Created by Alex on 5/24/2014.\n */\n\nexports.toSolr = function toSolr(params) {\n    params = params ? params : {};\n\n    Object.keys(params).forEach(function(key){\n        console.log(key);\n    });\n\n    try {\n\n    } catch (e) {\n        // console.log(e)\n\n    }\n};\n\nexports.fromSolr = function fromSolr(str) {\n\n};\n\nexports.__applyFilter = function(filter) {\n    var self = this;\n    if (typeof filter.where === 'function') {\n        return filter.where;\n    }\n    var keys = Object.keys(filter.where);\n    return function(obj) {\n        var pass = [];\n        keys.forEach(function(key) {\n            if (typeof filter.where[key] === 'object' && !filter.where[key].getTime) {\n                pass.push(self.parseCond(obj[key], filter.where[key]));\n            } else {\n                pass.push(key + ':' + filter.where[key]);\n            }\n        });\n        return pass;\n    };\n};\n\nexports.__parseCond = function(val, conds) {\n    var outs = false;\n    Object.keys(conds).forEach(function(condType) {\n        switch (condType) {\n            case 'gt':\n                outs = val > conds[condType] ? true : false;\n                break;\n            case 'gte':\n                outs = val >= conds[condType] ? true : false;\n                break;\n            case 'lt':\n                outs = val < conds[condType] ? true : false;\n                break;\n            case 'lte':\n                outs = val <= conds[condType] ? true : false;\n                break;\n            case 'between':\n                // need\n                outs = val !== conds[condType] ? true : false;\n                break;\n            case 'inq':\n            case 'in':\n                conds[condType].forEach(function(cval) {\n                    if (val === cval) {\n                        outs = true;\n                    }\n                });\n                break;\n            case 'nin':\n                conds[condType].forEach(function(cval) {\n                    if (val === cval) {\n                        outs = false;\n                    }\n                });\n                break;\n            case 'neq':\n            case 'ne':\n                outs = val !== conds[condType] ? true : false;\n                break;\n            case 'regex':\n            case 'like':\n                outs = new RegExp(conds[condType]).test(val);\n                break;\n            case 'nlike':\n                outs = !new RegExp(conds[condType]).test(val);\n                break;\n            default:\n                outs = val === conds[condType] ? true : false;\n                break;\n        }\n    });\n    return outs;\n};","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/arango.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar util = require('util');\nvar safeRequire = utils.safeRequire;\nvar arango = safeRequire('arangojs');\nvar url = require('url');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!arango) return;\n    var s = schema.settings;\n\n    if (schema.settings.url) {\n        var uri = url.parse(schema.settings.url);\n        s.host = uri.hostname;\n        s.port = uri.port || '8529';\n        s.database = uri.pathname.replace(/^\\//, '');\n        s.username = uri.auth && uri.auth.split(':')[0];\n        s.password = uri.auth && uri.auth.split(':')[1];\n    }\n    s.host = s.host || 'localhost';\n    s.port = parseInt(s.port || '8529', 10);\n    s.database = s.database || 'test';\n    if (!schema.settings.url) {\n        var durl = schema.settings.host || 'localhost';\n        if (schema.settings.port)\n            durl += ':' + schema.settings.port;\n        var auth = '';\n        if (schema.settings.username) {\n            auth = schema.settings.username;\n            if (schema.settings.password) {\n                auth += ':' + schema.settings.password;\n            }\n        }\n        if (auth) {\n            durl = auth + '@' + url;\n        }\n        durl += '/';\n        durl = 'http://' + durl;\n        schema.settings.url = durl;\n    }\n    schema.adapter = new Arango(s, schema, callback);\n};\n\nvar ArangoId = function (fullId) {\n    var parts = fullId.split('/');\n    this._id = parts[0];\n    this._rev = parts[1];\n};\n\nArangoId.prototype.id = function () {\n    return this._id;\n};\n\nArangoId.prototype.rev = function () {\n    return this._rev;\n};\n\nArangoId.prototype.fullId = function () {\n    return this._id + '/' + this._rev;\n};\n\nArangoId.prototype.setRev = function (rev) {\n    this._rev = rev;\n};\n\nfunction Arango(s, schema, callback) {\n    var self = this;\n    self.name = 'arango';\n    self._models = {};\n    self.settings = s;\n    self.collections = {};\n    self.aqlQuery = arango.aqlQuery;\n    self.client = new arango.Database(schema.settings.url);\n    self.client.createDatabase(s.database, function (res) {\n        // console.log('Database ' + schema.settings.database + ' created!');\n    }, function (err) {\n        if (err.errorNum !== 1207) {\n            console.log(\"Failed to create database: %j\", err);\n        }\n    });\n    self.client.useDatabase(s.database);\n    schema.client = self.client;\n    process.nextTick(function () {\n        callback();\n    });\n}\n\nArango.prototype.define = function (descr) {\n    var self = this, indexes;\n    if (!descr.settings) descr.settings = {};\n    self._models[descr.model.modelName] = descr;\n    self.client.useDatabase(self.settings.database);\n    var collection = self.client.collection(descr.model.modelName);\n    collection.create();\n    self.collections[descr.model.modelName] = collection;\n\n    var keys = self.getModelIndexes(descr.model.modelName);\n    if (keys.indexes.length) {\n        self.ensureIndex(descr.model.modelName, keys.indexes, false, function () {\n            // created\n        }.bind(self));\n    }\n    if (keys.uniques.length) {\n        self.ensureIndex(descr.model.modelName, keys.uniques, true, function () {\n            // created\n        }.bind(self));\n    }\n};\n\nArango.prototype.getModelIndexes = function (name) {\n    var model = this._models[name], indexes = [], uniques = [];\n    Object.keys(model.properties).forEach(function (k) {\n        if (typeof model.properties[k].unique !== 'undefined') {\n            uniques.push(k);\n        }\n        if (typeof model.properties[k].index !== 'undefined') {\n            indexes.push(k);\n        }\n    }.bind(this));\n    return {\n        indexes: indexes,\n        uniques: uniques\n    };\n};\n\nArango.prototype.collection = function (name) {\n    if (this.client.collection) {\n        return this.client.collection(name);\n    } else {\n        if (!this.collections[name]) {\n            this.collections[name] = this.client.collection(name);\n        }\n        return this.collections[name];\n    }\n};\n\n/**\n * Update existing database collections.\n * @param {Function} callback\n */\nArango.prototype.autoupdate = function (callback) {\n    var self = this, pending = Object.keys(self._models).length;\n    if (!pending) {\n        return callback && callback();\n    }\n    Object.keys(self._models).forEach(function (model) {\n        self.collection(model).create(function () {\n            self.collection(model)\n                .setProperties({waitForSync: true}, function () {\n                    if (--pending === 0) {\n                        setTimeout(function () {\n                            var keys = self.getModelIndexes(model);\n                            self.ensureIndex(model, keys.indexes, false, function () {\n                                return self.ensureIndex(model, keys.uniques, true, callback);\n                            });\n                        }, 100);\n                    }\n                });\n        });\n\n    });\n};\n\n/**\n * Re create existing database collections.\n * @param {Function} callback\n */\nArango.prototype.automigrate = function (callback) {\n    var self = this, pending = 0;\n    Object.keys(self._models).forEach(function (model) {\n        pending++;\n        self.client.collection.delete(model, function (err, result) {\n            if (!err || result.code == 404) {\n                self.collection(model).create({waitForSync: true}, function (err) {\n                    if (err) {\n                        return callback && callback(err);\n                    } else {\n                        collectionCreated();\n                    }\n                });\n            }\n        }.bind(self));\n    }, self);\n\n    var collectionCreated = function () {\n        if (--pending == 0 && callback) {\n            callback();\n        }\n    }\n};\n\nArango.prototype.defineForeignKey = function (model, key, cb) {\n    cb(null, String);\n};\n\nArango.prototype.fromDatabase = function (model, data) {\n    if (!data) {\n        return null;\n    }\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (/^_/.test(key)) {\n            delete data[key];\n            return;\n        }\n        var val = data[key];\n        if (props[key]) {\n            if (props[key].type.name === 'Date' && val !== null) {\n                val = new Date(val);\n            }\n        }\n        data[key] = val;\n    });\n    return data;\n};\n\nArango.prototype.create = function (model, data, callback) {\n    this.save(model, data, callback);\n};\n\nArango.prototype.save = function (model, data, callback) {\n    var self = this;\n    self.collection(model).save(data, function (err, res) {\n        if (err) {\n            return callback && callback(err);\n        } else {\n            data.id = parseInt(res._key);\n            self.collection(model).update(res, {id: data.id}, function (err, res) {\n                return callback && callback(err, data.id, res._rev);\n            });\n        }\n    }.bind(this));\n};\n\nArango.prototype.findById = function (model, id, callback) {\n    var self = this;\n    self.collection(model).document('' + id, function (err, res) {\n        var data;\n        err = (err || {}).code !== 404 ? err : null;\n        if (!err) {\n            if (res && res.id) {\n                res.id = parseInt(res._key);\n                data = self.fromDatabase(model, res);\n            }\n        }\n        return callback && callback(err, data);\n    }.bind(this));\n};\n\nArango.prototype.exists = function (model, id, callback) {\n    this.collection(model).document('' + id, function (err, res) {\n        return callback && callback(err, !err && res.id);\n    }.bind(this));\n};\n\nArango.prototype.all = Arango.prototype.find = function (model, filter, callback) {\n    var self = this, query = ['FOR x IN @@collection'];\n    var bindVars = {\n        '@collection': model\n    };\n\n    if (filter) {\n        if (filter.where && Object.keys(filter.where).length === 0) {\n            var csql = self.buildWhere(filter.where, self, model);\n            query.push(csql.query.join(' '));\n            Object.keys(csql.bindVars).forEach(function (bkey) {\n                bindVars[bkey] = csql.bindVars[bkey];\n            });\n        }\n        if (filter.order) {\n            var keys = filter.order;\n            if (typeof keys === 'string') {\n                keys = keys.split(',');\n            }\n            var args = {};\n            for (var index in keys) {\n                var m = keys[index].match(/\\s+(A|DE)SC$/);\n                var key = keys[index];\n                key = key.replace(/\\s+(A|DE)SC$/, '').trim();\n                if (m && m[1] === 'DE') {\n                    args[key] = 'DESC';\n                } else {\n                    args[key] = 'ASC';\n                }\n            }\n\n            var order = '';\n            Object.keys(args).forEach(function (kx) {\n                order += 'x.`' + kx + '` ' + args[kx];\n            });\n            query.push('SORT ' + order);\n        }\n        if (filter.limit) {\n            query.push('LIMIT @skip, @limit');\n            bindVars['skip'] = filter.skip || 0;\n            bindVars['limit'] = filter.limit || 20;\n        }\n        query.push('RETURN x');\n\n        var maql = self.aqlQuery([query.join(' ')]);\n        maql.bindVars = bindVars;\n        if (!Object.keys(bindVars).length) {\n            maql = query.join(' ');\n        }\n\n        self.client.query(maql, function (err, cursor) {\n            if (err) {\n                console.log('query err:', err.message);\n            }\n            var data = (cursor || {})._result || [];\n            if (data && data.length) {\n                data = data.map(function (i) {\n                    return self.fromDatabase(model, i);\n                });\n            }\n            return callback && callback(err, data)\n        }.bind(self));\n    } else {\n        var opt = {};\n        if (filter.limit) {\n            opt.skip = filter.offset || filter.skip || 0;\n            opt.limit = filter.limit;\n        }\n        self.collection(model).all(opt, function (err, res) {\n            var data = (res || {})._result || [];\n            if (data && data.length) {\n                data = data.map(function (i) {\n                    return self.fromDatabase(model, i);\n                });\n            }\n            return callback && callback(err, data);\n        }.bind(self));\n    }\n};\n\nArango.prototype.destroy = function (model, id, callback) {\n    return this.collection(model).remove('' + id, function (err, res) {\n        return callback && callback(err);\n    }.bind(this));\n};\n\nArango.prototype.updateAttributes = function (model, id, newData, callback) {\n    this.collection(model).update('' + id, newData, function (err, data) {\n        return callback && callback(err, data);\n    }.bind(this));\n};\n\n// TODO: implement\nArango.prototype.count = function (model, callback, where) {\n    if (!where) {\n        this.collection(model).count(function (err, res) {\n            return callback && callback(err, (res || {}).count || 0);\n        }.bind(this));\n    } else {\n        this.collection(model).count(function (err, res) {\n            return callback && callback(err, (res || {}).count || 0);\n        }.bind(this));\n    }\n};\n/**\n * Update rows\n * @param {String} model\n * @param {Object} filter\n * @param {Object} data\n * @param {Function} callback\n */\nArango.prototype.update = function (model, filter, data, callback) {\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parametrs undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parametrs undefined\"), null);\n    }\n\n    filter = filter || {};\n    filter = filter.where ? filter.where : filter;\n\n    this.collection(model).updateByExample(filter, data, callback);\n};\n\n// TODO: implement\nArango.prototype.remove = function remove(model, filter, callback) {\n    // var cond = buildWhere(filter.where);\n    this.collection(model).removeByExample(filter.where, callback);\n};\n\n/**\n * Truncate collection.\n * @param {Function} callback\n */\nArango.prototype.destroyAll = function (model, callback) {\n    this.collection(model).truncate(function (res) {\n        var err = (res || {}).error ? res : null;\n        return callback && callback(err);\n    }.bind(this));\n};\n\n/**\n * EnsureIndex in collection.\n * @param {String} model\n * @param {Array} fields\n * @param {Array} unique\n * @param {Function} callback\n * @returns {*}\n */\nArango.prototype.ensureIndex = function ensureIndex(model, fields, unique, callback) {\n    if (!fields || !fields.length) {\n        return callback && callback();\n    }\n    if (typeof unique === 'function') {\n        callback = unique;\n        unique = false;\n    }\n    this.collection(model)\n        .createHashIndex(fields, {unique: unique}, callback);\n};\n\nArango.prototype.buildWhere = function buildWhere(conds, adapter, model) {\n    'use strict';\n    var qw = {}, cs = [], or = [], bindVars = {}, cix = 0,\n        self = adapter,\n        props = self._models[model].properties;\n\n    Object.keys(conds).forEach(function (key) {\n        if (key !== 'or') {\n            qw = parseCond(cs, bindVars, key, props, conds, self, cix);\n        } else {\n            conds[key].forEach(function (oconds) {\n                Object.keys(oconds).forEach(function (okey) {\n                    or = parseCond(or, bindVars, okey, props, oconds, self, cix);\n                });\n            });\n        }\n        cix++;\n    });\n\n    if (cs.length === 0 && or.length === 0) {\n        return '';\n    }\n    var orop = '';\n    if (or.length) {\n        orop = ' (' + or.join(' OR ') + ') ';\n    }\n    orop += (orop !== \"\" && cs.length > 0) ? ' AND ' : '';\n\n    return qw;\n};\n\nArango.prototype.toDatabase = function (prop, val, esc) {\n    \"use strict\";\n    if (val === null) {\n        return '';\n    }\n    if (!prop) {\n        return val;\n    }\n    if (val.constructor.name === 'Object' && type !== 'json') {\n        var operator = Object.keys(val)[0];\n        val = val[operator];\n        if (operator === 'in' || operator === 'inq' || operator === 'nin') {\n            if (!(val.propertyIsEnumerable('length')) && typeof val === 'object' && typeof val.length === 'number') { //if value is array\n                for (var i = 0; i < val.length; i++) {\n                    val[i] = escape(val[i]);\n                }\n                return val.join(',');\n            } else {\n                return val;\n            }\n        }\n    }\n    if (prop.type.name === 'Number') {\n        return val;\n    }\n    if (prop.type.name === 'Date') {\n        if (!val) {\n            return 0;\n        }\n        if (typeof val === 'string') {\n            val = Date.parse(val);\n        }\n        if (val instanceof Date) {\n            val = val.getTime();\n        }\n        return val;\n    }\n    if (prop.type.name === \"Boolean\") {\n        return val ? 1 : 0;\n    }\n    return esc ? escape(val) : val;\n};\n\nfunction escape(val) {\n    if (typeof val === 'string') {\n        return '\\'' + val + '\\'';\n    }\n    return val;\n}\n\nvar parseCond = function (cs, bindVars, key, props, conds, self, cix) {\n    'use strict';\n    var keyEscaped = 'FILTER x.`' + key + '`';\n    var val = conds[key];\n    if (val === null) {\n        cs.push(keyEscaped + '\\'\\'');\n    } else if (val.constructor.name === 'Object') {\n        Object.keys(val).forEach(function (condType) {\n            var inq = 'in,inq,nin'.indexOf(condType) > -1 ? 1 : 0;\n            val = self.toDatabase(props[key], val[condType], true);\n            var sqlCond = keyEscaped;\n            if ((condType === 'inq' || condType === 'nin') && val.length === 0) {\n                cs.push(condType === 'inq' ? 0 : 1);\n                return true;\n            }\n            switch (condType.toString().toLowerCase()) {\n                case 'gt':\n                    sqlCond += ' > ';\n                    break;\n                case 'gte':\n                    sqlCond += ' >= ';\n                    break;\n                case 'lt':\n                    sqlCond += ' < ';\n                    break;\n                case 'lte':\n                    sqlCond += ' <= ';\n                    break;\n                case 'between':\n                    sqlCond += ' ';\n                    break;\n                case 'inq':\n                case 'in':\n                    sqlCond += ' IN ';\n                    break;\n                case 'nin':\n                    sqlCond += ' NOT IN ';\n                    break;\n                case 'neq':\n                case 'ne':\n                    sqlCond += ' != ';\n                    break;\n                case 'regex':\n                    sqlCond += ' REGEXP ';\n                    break;\n                case 'like':\n                    sqlCond += ' LIKE ';\n                    break;\n                case 'nlike':\n                    sqlCond += ' NOT LIKE ';\n                    break;\n                default:\n                    sqlCond += ' ' + condType + ' ';\n                    break;\n            }\n            if (condType === 'between') {\n                sqlCond += ' >= @whereL';\n                sqlCond += ' AND x.`' + key + '`';\n                sqlCond += ' <= @whereG';\n                bindVars['whereL'] = val[0];\n                bindVars['whereG'] = val[1];\n            } else if (inq === 1) {\n                sqlCond += ' @where' + cix;\n                bindVars['where' + cix] = val;\n            } else {\n                sqlCond += val;\n            }\n            cs.push(sqlCond);\n        });\n\n    } else if (/^\\//gi.test(conds[key])) {\n        var reg = val.toString().split('/');\n        cs.push(keyEscaped + ' REGEXP \"' + reg[1] + '\"');\n    } else {\n        val = self.toDatabase(props[key], val, false);\n        cs.push(keyEscaped + ' == @where' + cix);\n        bindVars['where' + cix] = val;\n    }\n    return {\n        query: cs,\n        bindVars: bindVars\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/cassandra.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar cassandra = safeRequire('cassandra-driver');\nvar Types = cassandra.types;\nvar timeUUID = Types.timeuuid;\nvar util = require('util');\nvar url = require('url');\nvar BaseSQL = require('../sql');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!cassandra) {\n        return;\n    }\n    var s = schema.settings;\n    if (s.url) {\n        var uri = url.parse(s.url);\n        s.host = uri.hostname;\n        s.port = uri.port || '9042';\n        s.database = uri.pathname.replace(/^\\//, '');\n        s.username = uri.auth && uri.auth.split(':')[0];\n        s.password = uri.auth && uri.auth.split(':')[1];\n    }\n    s.host = s.host || 'localhost';\n    s.port = parseInt(s.port || '9042', 10);\n    s.database = s.database || s.keyspace || 'test';\n\n    if (!(s.host instanceof Array)) {\n        s.host = [s.host];\n    }\n\n    schema.client = new cassandra.Client({\n        contactPoints: s.host,\n        protocolOptions: {\n            maxVersion: 3\n        },\n        autoPage: true\n    });\n    // , keyspace: s.database\n    schema.adapter = new Cassandra(schema, schema.client);\n\n    schema.client.connect(function (err, result) {\n        schema.client.execute(\"CREATE KEYSPACE IF NOT EXISTS \" + s.database.toString() + \" WITH replication \" +\n            \"= {'class' : 'SimpleStrategy', 'replication_factor' : 2};\", function (err, data) {\n                console.log('Cassandra connected.');\n                schema.client.keyspace = s.database;\n                process.nextTick(callback);\n            }\n        );\n    });\n\n};\n\nfunction Cassandra(schema, client) {\n    this.name = 'cassandra';\n    this._models = {};\n    this.client = client;\n    this.schema = schema;\n}\n\nutil.inherits(Cassandra, BaseSQL);\n\nCassandra.prototype.execute = function (sql, callback) {\n    var self = this;\n    var client = self.client;\n    client.execute(sql, callback);\n};\n\nCassandra.prototype.query = function (sql, callback) {\n    'use strict';\n    var self = this;\n    if (typeof callback !== 'function') {\n        throw new Error('callback should be a function');\n    }\n    self.execute(sql, function (err, data) {\n        if (err && err.message.match(/does\\s+not\\s+exist/i)) {\n            self.query('CREATE KEYSPACE IF NOT EXISTS ' + self.schema.settings.database, function (error) {\n                if (!error) {\n                    self.execute(sql, callback);\n                } else {\n                    callback(err);\n                }\n            });\n        } else if (err && (err.message.match(/no\\s+keyspace\\s+has\\s+been\\s+specified/gi) || parseInt(err.errno) === 1046)) {\n            self.execute('USE ' + self.schema.settings.database + '', function (error) {\n                if (!error) {\n                    self.execute(sql, callback);\n                } else {\n                    callback(error);\n                }\n            });\n        } else {\n            var rows = [];\n            data = data || {};\n            if (data.rows && data.rows.length) {\n                rows = data.rows;\n            }\n            return callback(err, rows);\n        }\n    });\n};\n\n/**\n * Must invoke callback(err, id)\n * @param {Object} model\n * @param {Object} data\n * @param {Function} callback\n */\nCassandra.prototype.create = function (model, data, callback) {\n    'use strict';\n    var self = this;\n    var props = self._models[model].properties;\n    data = data || {};\n    if (data.id === null) {\n        data.id = timeUUID();\n    }\n    var keys = [];\n    var questions = [];\n    Object.keys(data).map(function (key) {\n        var val = self.toDatabase(props[key], data[key]);\n        if (val !== 'NULL') {\n            keys.push(key);\n            questions.push(val);\n        }\n    });\n    var sql = 'INSERT INTO ' + self.tableEscaped(model) + ' (' + keys.join(',') + ') VALUES (';\n    sql += questions.join(',');\n    sql += ')';\n    this.query(sql, function (err, info) {\n        callback(err, !err && data.id);\n    });\n};\n\nCassandra.prototype.all = function all(model, filter, callback) {\n    'use strict';\n    var self = this, sFields = '*';\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n\n    var sql = 'SELECT ' + sFields + ' FROM ' + self.tableEscaped(model);\n\n    if (filter) {\n\n        if (filter.fields) {\n            if (typeof filter.fields === 'string') {\n                sFields = self.tableEscaped(filter.fields);\n            } else if (Object.prototype.toString.call(filter.fields) === '[object Array]') {\n                sFields = filter.fields.map(function (field) {\n                    return '`' + field + '`';\n                }).join(', ');\n            }\n            sql = sql.replace('*', sFields);\n        }\n\n        if (filter.where) {\n            sql += ' ' + self.buildWhere(filter.where, self, model);\n        }\n\n        if (filter.order) {\n            sql += ' ' + self.buildOrderBy(filter.order);\n        }\n\n        if (filter.group) {\n            sql += ' ' + self.buildGroupBy(filter.group);\n        }\n\n        if (filter.limit) {\n            sql += ' ' + self.buildLimit(filter.limit, filter.offset || filter.skip || 0);\n        }\n\n    }\n\n    this.query(sql, function (err, data) {\n        if (err) {\n            return callback(err, []);\n        }\n        callback(null, data.map(function (obj) {\n            return self.fromDatabase(model, obj);\n        }));\n    }.bind(this));\n\n    return sql;\n};\n\nCassandra.prototype.update = function (model, filter, data, callback) {\n    'use strict';\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parametrs undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parametrs undefined\"), null);\n    }\n    filter = filter.where ? filter.where : filter;\n    var self = this;\n    var combined = [];\n    var props = self._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key] || key === 'id') {\n            var k = '' + key + '';\n            var v;\n            if (key !== 'id') {\n                v = self.toDatabase(props[key], data[key]);\n            } else {\n                v = data[key];\n            }\n            combined.push(k + ' = ' + v);\n        }\n    });\n    var sql = 'UPDATE ' + this.tableEscaped(model);\n    sql += ' SET ' + combined.join(', ');\n    sql += ' ' + self.buildWhere(filter, self, model);\n\n    this.query(sql, function (err, affected) {\n        callback(err, !err);\n    });\n};\n\nCassandra.prototype.destroyAll = function destroyAll(model, callback) {\n    this.query('TRUNCATE ' + this.tableEscaped(model), function (err) {\n        if (err) {\n            return callback(err, []);\n        }\n        callback(err);\n    }.bind(this));\n};\n\n/**\n * Update existing database tables.\n * @param {Function} cb\n */\nCassandra.prototype.autoupdate = function (cb) {\n    'use strict';\n    var self = this;\n    var wait = 0;\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.query('SELECT column_name as field, type, validator, index_type, index_name FROM system.schema_columns ' +\n            'WHERE keyspace_name = \\'' + self.schema.settings.database + '\\' ' +\n            'AND columnfamily_name = \\'' + self.escapeName(model) + '\\'',\n            function (err, data) {\n                var indexes = data.filter(function (m) {\n                        return m.index_type !== null || m.type === 'partition_key';\n                    }) || [];\n                if (!err && data.length) {\n                    self.alterTable(model, data, indexes || [], done);\n                } else {\n                    self.createTable(model, indexes || [], done);\n                }\n            });\n    });\n\n    function done(err) {\n        if (err) {\n            console.log(err);\n        }\n        if (--wait === 0 && cb) {\n            cb();\n        }\n    }\n};\n\nCassandra.prototype.alterTable = function (model, actualFields, actualIndexes, done, checkOnly) {\n    'use strict';\n    var self = this;\n    var m = this._models[model];\n    var propNames = Object.keys(m.properties).filter(function (name) {\n        return !!m.properties[name];\n    });\n    var indexNames = m.settings.indexes ? Object.keys(m.settings.indexes).filter(function (name) {\n        return !!m.settings.indexes[name];\n    }) : [];\n    var sql = [];\n    var ai = {};\n\n    if (actualIndexes) {\n        actualIndexes.forEach(function (i) {\n            var name = i.index_name || i.field;\n            if (!ai[name]) {\n                ai[name] = {\n                    info: i,\n                    columns: []\n                };\n            }\n            ai[name].columns.push(i.field);\n        });\n    }\n    var aiNames = Object.keys(ai);\n\n    // change/add new fields\n    propNames.forEach(function (propName) {\n        if (propName === 'id') {\n            return;\n        }\n        var found;\n        actualFields.forEach(function (f) {\n            if (f.field === propName) {\n                found = f;\n            }\n        });\n\n        if (found) {\n            actualize(propName, found);\n        } else {\n            // ALTER TABLE users ADD top_places list<text>;\n            sql.push('ALTER TABLE ' + self.escapeName(model) + ' ADD ' + self.propertySettingsSQL(model, propName));\n        }\n    });\n\n    // drop columns\n    actualFields.forEach(function (f) {\n        var notFound = !~propNames.indexOf(f.field);\n        if (f.field === 'id') {\n            return;\n        }\n        if (notFound || !m.properties[f.field]) {\n            // ALTER TABLE addamsFamily DROP gender;\n            sql.push('ALTER TABLE ' + self.escapeName(model) + ' DROP ' + f.field + '');\n        }\n    });\n\n    // remove indexes\n    aiNames.forEach(function (indexName) {\n        if (indexName === 'id' || indexName === 'PRIMARY') {\n            return;\n        }\n\n        if ((indexNames.indexOf(indexName) === -1 && !m.properties[indexName])\n            || (m.properties[indexName] && !m.properties[indexName].index && !ai[indexName])) {\n            sql.push('DROP INDEX IF EXISTS ' + indexName + '');\n        } else {\n            // first: check single (only type and kind)\n            if (m.properties[indexName] && !m.properties[indexName].index) {\n                // TODO\n                return;\n            }\n            // second: check multiple indexes\n            var orderMatched = true;\n            if (indexNames.indexOf(indexName) !== -1) {\n                m.settings.indexes[indexName].columns.split(/,\\s*/).forEach(function (columnName, i) {\n                    if (ai[indexName].columns[i] !== columnName)\n                        orderMatched = false;\n                });\n            }\n            if (!orderMatched) {\n                sql.push('DROP INDEX IF EXISTS ' + indexName + '');\n                delete ai[indexName];\n            }\n        }\n    });\n\n    // add single-column indexes\n    propNames.forEach(function (propName) {\n        var i = m.properties[propName].index;\n        if (!i) {\n            return;\n        }\n        var found = ai[propName] && ai[propName].info;\n        if (!found) {\n            var type = '';\n            var kind = '';\n            if (i.type) {\n                type = 'USING ' + i.type;\n            }\n            if (i.kind) {\n                // kind = i.kind;\n            }\n\n            // CREATE INDEX IF NOT EXISTS user_state ON myschema.users (state);\n            if (kind && type) {\n                sql.push('CREATE INDEX IF NOT EXISTS ' + propName + ' ON ' + self.escapeName(model) + ' (' + propName + ')');\n            } else {\n                sql.push('CREATE INDEX IF NOT EXISTS ' + propName + ' ON ' + self.escapeName(model) + ' (' + propName + ')');\n            }\n        }\n    });\n    /*\n     // add multi-column indexes\n     indexNames.forEach(function (indexName) {\n     var i = m.settings.indexes[indexName];\n     var found = ai[indexName] && ai[indexName].info;\n     if (!found) {\n     sql.push('CREATE INDEX IF NOT EXISTS '+indexName+' ON '+self.escapeName(model)+' ('+i.columns+')');\n     }\n     });\n     */\n    if (sql.length) {\n        var query = sql;\n        if (checkOnly) {\n            done(null, true, {\n                statements: sql,\n                query: query\n            });\n        } else {\n            var slen = query.length;\n            for (var qi in query) {\n                this.query(query[qi] + '', function (err, data) {\n                    if (err) console.log(err);\n                    if (--slen === 0) {\n                        done();\n                    }\n                });\n            }\n        }\n    } else {\n        done();\n    }\n\n    function actualize(propName, oldSettings) {\n        'use strict';\n        var newSettings = m.properties[propName];\n        if (newSettings && changed(newSettings, oldSettings)) {\n            // ALTER TABLE users ALTER bio TYPE text;\n            sql.push('ALTER TABLE ' + self.escapeName(model) + ' ALTER ' + propName + ' TYPE ' + self.propertySettingsSQL(model, propName));\n        }\n    }\n\n    function changed(newSettings, oldSettings) {\n        'use strict';\n        var type = oldSettings.validator.replace(/ORG\\.APACHE\\.CASSANDRA\\.DB\\.MARSHAL\\./gi, '');\n        type = type.replace(/type/gi, '').toLowerCase();\n        if (/^map/gi.test(type)) {\n            type = 'map<text,text>';\n        }\n\n        switch (type) {\n            case 'utf8':\n                type = 'text';\n                break;\n            case 'int32':\n                type = 'int';\n                break;\n            case 'long':\n                type = 'bigint';\n                break;\n        }\n\n        if (type !== datatype(newSettings) && type !== 'reversed(' + datatype(newSettings) + ')') {\n            return true;\n        }\n        return false;\n    }\n};\n\nCassandra.prototype.ensureIndex = function (model, fields, params, callback) {\n    'use strict';\n    var self = this, sql = \"\", keyName = params.name || null, afld = [], kind = \"\";\n    Object.keys(fields).forEach(function (field) {\n        if (!keyName) {\n            keyName = \"idx_\" + field;\n        }\n        afld.push('' + field + '');\n    });\n    if (params.unique) {\n        kind = \"UNIQUE\";\n    }\n    // CREATE INDEX IF NOT EXISTS xi ON xx5 (x);\n    sql += 'CREATE INDEX IF NOT EXISTS ' + kind + ' INDEX `' + keyName + '` ON  `' + model + '` (' + afld.join(', ') + ');';\n    self.query(sql, callback);\n};\n\nCassandra.prototype.buildLimit = function buildLimit(limit, offset) {\n    'use strict';\n    return 'LIMIT ' + (offset ? (offset + ', ' + limit) : limit);\n};\n\nCassandra.prototype.buildWhere = function buildWhere(conds, adapter, model) {\n    'use strict';\n    var cs = [], or = [],\n        self = adapter,\n        props = self._models[model].properties;\n\n    Object.keys(conds).forEach(function (key) {\n        if (key !== 'or') {\n            cs = parseCond(cs, key, props, conds, self);\n        } else {\n            conds[key].forEach(function (oconds) {\n                Object.keys(oconds).forEach(function (okey) {\n                    or = parseCond(or, okey, props, oconds, self);\n                });\n            });\n        }\n    });\n\n    if (cs.length === 0 && or.length === 0) {\n        return '';\n    }\n    var orop = \"\";\n    if (or.length) {\n        orop = ' (' + or.join(' OR ') + ') ';\n    }\n    orop += (orop !== \"\" && cs.length > 0) ? ' AND ' : '';\n    return 'WHERE ' + orop + cs.join(' AND ');\n};\n\nCassandra.prototype.buildGroupBy = function buildGroupBy(group) {\n    'use strict';\n    if (typeof group === 'string') {\n        group = [group];\n    }\n    return 'GROUP BY ' + group.join(', ');\n};\n\nCassandra.prototype.fromDatabase = function (model, data) {\n    'use strict';\n    if (!data) {\n        return null;\n    }\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        var val = data[key];\n        if (props[key]) {\n            if (props[key].type.name === 'Date' && val !== null) {\n                val = new Date(val.toString().replace(/GMT.*$/, 'GMT'));\n            }\n        }\n        data[key] = val;\n    });\n    return data;\n};\n\nCassandra.prototype.propertiesSQL = function (model) {\n    'use strict';\n    var self = this;\n    var sql = [];\n\n    Object.keys(this._models[model].properties).forEach(function (prop) {\n        if (prop === 'id') {\n            return;\n        }\n        return sql.push('' + prop + ' ' + self.propertySettingsSQL(model, prop));\n    });\n\n    var primaryKeys = this._models[model].settings.primaryKeys || [];\n    primaryKeys = primaryKeys.slice(0);\n    if (primaryKeys.length) {\n        for (var i = 0, length = primaryKeys.length; i < length; i++) {\n            primaryKeys[i] = \"\" + primaryKeys[i] + \"\";\n        }\n        sql.push(\"PRIMARY KEY (\" + primaryKeys.join(', ') + \")\");\n    } else {\n        sql.push('id timeuuid PRIMARY KEY');\n    }\n    return sql.join(',\\n  ');\n};\n\nCassandra.prototype.propertySettingsSQL = function (model, prop) {\n    'use strict';\n    var p = this._models[model].properties[prop], field = [];\n    field.push(datatype(p));\n    return field.join(\" \");\n};\n\nCassandra.prototype.escapeName = function (name) {\n    'use strict';\n    return name.toLowerCase();\n};\n\nCassandra.prototype.toFields = function (model, data) {\n    'use strict';\n    var fields = [];\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key] && key !== 'id') {\n            fields.push(key + ' = ' + this.toDatabase(props[key], data[key]));\n        }\n    }.bind(this));\n    return fields.join(',');\n};\n\nCassandra.prototype.toDatabase = function (prop, val) {\n    'use strict';\n    if (val === null) {\n        return 'NULL';\n    }\n    if (val.constructor.name === 'Object') {\n        var operator = Object.keys(val)[0];\n        val = val[operator];\n        if (operator === 'between') {\n            if (prop.type.name === 'Date') {\n                return 'STR_TO_DATE(' + this.toDatabase(prop, val[0]) + ', \"%Y-%m-%d %H:%i:%s\")' +\n                    ' AND STR_TO_DATE(' +\n                    this.toDatabase(prop, val[1]) + ', \"%Y-%m-%d %H:%i:%s\")';\n            } else {\n                return this.toDatabase(prop, val[0]) +\n                    ' AND ' +\n                    this.toDatabase(prop, val[1]);\n            }\n        } else if (operator === 'in' || operator === 'inq' || operator === 'nin') {\n            if (!(val.propertyIsEnumerable('length')) && typeof val === 'object' && typeof val.length === 'number') { //if value is array\n                for (var i = 0; i < val.length; i++) {\n                    val[i] = this.escapeName(val[i]);\n                }\n                return val.join(',');\n            } else {\n                return val;\n            }\n        }\n    }\n    if (!prop) {\n        return val;\n    }\n    var type = (prop.type.name || '').toLowerCase();\n    if (type === 'json') {\n        return val;\n    }\n    if (type === 'uuid' || type === 'timeuuid'\n        || type === 'number' || type === 'float'\n        || type === 'integer' || type === 'real') {\n        return val;\n    }\n    if (type === 'date') {\n        if (!val) {\n            return 'NULL';\n        }\n        if (typeof val === 'string') {\n            val = val.split('.')[0].replace('T', ' ');\n            val = Date.parse(val);\n        }\n        if (typeof val === 'number') {\n            val = new Date(val);\n        }\n        if (val instanceof Date) {\n            val = val.getTime();\n        }\n        return val;\n    }\n    if (type === \"boolean\" || type === \"tinyint\") {\n        return val ? 1 : 0;\n    }\n    return '\\'' + val.toString() + '\\'';\n};\n\nfunction dateToCassandra(val) {\n    'use strict';\n    return val.getUTCFullYear() + '-' +\n        fillZeros(val.getUTCMonth() + 1) + '-' +\n        fillZeros(val.getUTCDate()) + ' ' +\n        fillZeros(val.getUTCHours()) + ':' +\n        fillZeros(val.getUTCMinutes()) + ':' +\n        fillZeros(val.getUTCSeconds());\n\n    function fillZeros(v) {\n        'use strict';\n        return v < 10 ? '0' + v : v;\n    }\n}\n\nfunction parseCond(cs, key, props, conds, self) {\n    'use strict';\n    var keyEscaped = '' + key + '';\n    var val = self.toDatabase(props[key], conds[key]);\n    if (conds[key] === null) {\n        cs.push(keyEscaped + ' IS NULL');\n    } else if (conds[key].constructor.name === 'Object') {\n        Object.keys(conds[key]).forEach(function (condType) {\n            val = self.toDatabase(props[key], conds[key][condType]);\n            var sqlCond = keyEscaped;\n            if ((condType === 'inq' || condType === 'nin') && val.length === 0) {\n                cs.push(condType === 'inq' ? 0 : 1);\n                return true;\n            }\n            switch (condType) {\n                case 'gt':\n                    sqlCond += ' > ';\n                    break;\n                case 'gte':\n                    sqlCond += ' >= ';\n                    break;\n                case 'lt':\n                    sqlCond += ' < ';\n                    break;\n                case 'lte':\n                    sqlCond += ' <= ';\n                    break;\n                case 'between':\n                    sqlCond += ' BETWEEN ';\n                    break;\n                case 'inq':\n                case 'in':\n                    sqlCond += ' IN ';\n                    break;\n                case 'nin':\n                    sqlCond += ' NOT IN ';\n                    break;\n                case 'neq':\n                case 'ne':\n                    sqlCond += ' != ';\n                    break;\n                case 'regex':\n                    sqlCond += ' REGEXP ';\n                    break;\n                case 'like':\n                    sqlCond += ' LIKE ';\n                    break;\n                case 'nlike':\n                    sqlCond += ' NOT LIKE ';\n                    break;\n                default:\n                    sqlCond += ' ' + condType + ' ';\n                    break;\n            }\n            sqlCond += (condType === 'in' || condType === 'inq' || condType === 'nin') ? '(' + val + ')' : val;\n            cs.push(sqlCond);\n        });\n\n    } else if (/^\\//gi.test(conds[key])) {\n        var reg = val.toString().split('/');\n        cs.push(keyEscaped + ' REGEXP \"' + reg[1] + '\"');\n    } else {\n        cs.push(keyEscaped + ' = ' + val);\n    }\n    return cs;\n}\n\nfunction datatype(p) {\n    'use strict';\n    var dt = '';\n    switch ((p.type.name || 'string').toLowerCase()) {\n        case 'json':\n            dt = 'map<text,text>';\n            break;\n        case 'text':\n            dt = 'text';\n            break;\n        case 'int':\n        case 'integer':\n        case 'number':\n            dt = (parseFloat(p.limit) > 11) ? \"bigint\" : \"int\";\n            break;\n        case 'float':\n        case 'double':\n            dt = 'float';\n        case 'real':\n            dt = 'decimal';\n            break;\n        case 'timestamp':\n        case 'date':\n            dt = 'timestamp';\n            break;\n        case 'boolean':\n        case 'bool':\n            dt = 'boolean';\n            break;\n        case 'uuid':\n        case 'timeuuid':\n            dt = 'uuid';\n            break;\n        case 'blob':\n        case 'bytes':\n            dt = 'bytes';\n            break;\n        case 'countercolumn':\n            dt = 'countercolumn';\n            break;\n        default:\n            dt = 'text';\n    }\n    return dt;\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/couchbase.js":"/**\n * Module dependencies\n */\nvar uuid = require('uuid');\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar helpers = utils.helpers;\nvar couchbase = safeRequire('couchbase');\nvar CouchBase;\n\nexports.initialize = function (schema, callback) {\n    var db, opts;\n    opts = schema.settings || {};\n\n    if (!opts.url) {\n        var host = opts.host || 'localhost';\n        var port = opts.port || '8091';\n        var database = opts.database || 'test';\n        var proto = opts.ssl ? 'couchbases' : 'couchbase';\n        opts.url = proto + '://' + host + ':' + port;\n    }\n    schema.client = new couchbase.Cluster(opts.url);\n    db = schema.client.openBucket(database);\n    schema.adapter = new CouchBase(schema.client, db);\n\n    process.nextTick(function () {\n        schema.adapter.db = schema.client.openBucket(database);\n        return callback && callback();\n    }.bind(this));\n};\n\nfunction CouchBase(client, db, callback) {\n    this.name = 'couchbase';\n    this.client = client;\n    this.db = db;\n    this._models = {};\n}\n\nCouchBase.prototype.define = function (descr) {\n    var m, self = this;\n    m = descr.model.modelName;\n    descr.properties._rev = {\n        type: String\n    };\n    var design = {\n        views: {\n            all: {\n                map: 'function (doc, meta) { if (doc._type === \"' + m.toLowerCase() + '\") { return emit(doc._type, doc); } }',\n                reduce: '_count'\n            }\n        }\n    };\n    return self.db.manager().insertDesignDocument('caminte_' + m.toLowerCase(), design, function (err, doc) {\n        return self.db.get('caminte_' + m.toLowerCase() + '_counter', function (err, doc) {\n            if (!doc) {\n                self.db.insert('caminte_' + m.toLowerCase() + '_counter', 0, function () {\n                    return self._models[m] = descr;\n                });\n            } else {\n                return self._models[m] = descr;\n            }\n        });\n    });\n};\n\nCouchBase.prototype.create = function (model, data, callback) {\n    var self = this;\n    data._type = model.toLowerCase();\n    helpers.savePrep(data);\n    return self.db.counter('caminte_' + data._type + '_counter', +1, function (err, res) {\n        if (err) {\n            console.log('create counter for ' + data._type + ' failed', err);\n        }\n        var uid = res && res.value ? (data._type + '_' + res.value) : uuid.v1();\n        var key = data.id || uid;\n        data.id = key;\n        return self.db.upsert(key, self.forDB(model, data), function (err, doc) {\n            return callback(err, key);\n        });\n    });\n};\n\nCouchBase.prototype.save = function (model, data, callback) {\n    var self = this;\n    data._type = model.toLowerCase();\n    helpers.savePrep(data);\n    var uid = uuid.v1();\n    var key = data.id || data._id || uid;\n    if (data.id) {\n        delete data.id;\n    }\n    if (data._id) {\n        delete data._id;\n    }\n    return self.db.replace(key, self.forDB(model, data), function (err, doc) {\n        return callback(err, key);\n    });\n};\n\nCouchBase.prototype.updateOrCreate = function (model, data, callback) {\n    var self = this;\n    return self.exists(model, data.id, function (err, exists) {\n        if (exists) {\n            return self.save(model, data, callback);\n        } else {\n            return self.create(model, data, function (err, id) {\n                data.id = id;\n                return callback(err, data);\n            });\n        }\n    });\n};\n\nCouchBase.prototype.exists = function (model, id, callback) {\n    return this.db.get(id, function (err, doc) {\n        if (err) {\n            return callback(null, false);\n        }\n        return callback(null, doc);\n    });\n};\n\nCouchBase.prototype.findById = function (model, id, callback) {\n    var self = this;\n    return self.db.get(id, function (err, data) {\n        var doc = data && (data.doc || data.value) ? (data.doc || data.value) : null;\n        if (doc) {\n            if (doc._type) {\n                delete doc._type;\n            }\n            doc = self.fromDB(model, doc);\n            if (doc._id) {\n                doc.id = doc._id;\n                delete doc._id;\n            }\n        }\n        return callback(err, doc);\n    });\n};\n\nCouchBase.prototype.destroy = function (model, id, callback) {\n    var self = this;\n    return self.db.remove(id, function (err, doc) {\n        if (err) {\n            return callback(err);\n        }\n        callback.removed = true;\n        return callback();\n    });\n};\n\nCouchBase.prototype.updateAttributes = function (model, id, data, callback) {\n    var self = this;\n    return self.findById(model, id, function (err, base) {\n        if (err) {\n            return callback(err);\n        }\n        if (base) {\n            data = helpers.merge(base, data);\n            data.id = id;\n        }\n        return self.save(model, data, callback);\n    });\n};\n\nCouchBase.prototype.count = function (model, callback, where) {\n    var self = this;\n    var query = new couchbase.ViewQuery()\n        .from('caminte_' + model, 'all')\n        .reduce(true)\n        .stale(1)\n        .include_docs(true);\n    return self.db.query(query, function (err, body) {\n        return callback(err, docs.length);\n    });\n};\n\nCouchBase.prototype.destroyAll = function (model, callback) {\n    var self = this;\n    return self.all(model, {}, function (err, docs) {\n        return callback(err, docs);\n    });\n};\n\nCouchBase.prototype.forDB = function (model, data) {\n    var k, props, v;\n    if (data === null) {\n        data = {};\n    }\n    props = this._models[model].properties;\n    for (k in props) {\n        v = props[k];\n        if (data[k] && props[k].type.name === 'Date'\n            && (data[k].getTime !== null)\n            && (typeof data[k].getTime === 'function')) {\n            data[k] = data[k].getTime();\n        }\n    }\n    return data;\n};\n\nCouchBase.prototype.fromDB = function (model, data) {\n    var date, k, props, v;\n    if (!data) {\n        return data;\n    }\n    props = this._models[model].properties;\n    for (k in props) {\n        v = props[k];\n        if ((data[k] !== null) && props[k].type.name === 'Date') {\n            date = new Date(data[k]);\n            date.setTime(data[k]);\n            data[k] = date;\n        }\n    }\n    return data;\n};\n\nCouchBase.prototype.remove = function (model, filter, callback) {\n    var self = this;\n    return self.all(model, filter, function (err, docs) {\n        var doc;\n        console.log(docs)\n        // return _this.db.bulk({\n        //     docs: docs\n        //  }, function (err, body) {\n        return callback(err, docs);\n        //  });\n    });\n};\n/*\n CouchBase.prototype.destroyById = function destroyById(model, id, callback) {\n var self = this;\n return self.db.remove(id, function (err, doc) {\n console.log(err, doc)\n return callback(err, doc);\n });\n };\n */\nCouchBase.prototype.all = function (model, filter, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    var self = this;\n    var query = new couchbase.ViewQuery()\n        .from('caminte_' + model, 'all')\n        .reduce(false)\n        .include_docs(true);\n\n    if (filter.order) {\n        if (/desc/gi.test()) {\n            query.order(couchbase.ViewQuery.Order.DESCENDING);\n        }\n        // query.order(filter.order);\n    }\n    if (filter.skip) {\n        query.skip(filter.skip);\n    }\n    if (filter.limit) {\n        query.limit(filter.limit);\n    }\n    if (filter.where) {\n        query.custom(filter.where);\n    }\n\n    return self.db.query(query, function (err, body) {\n        var doc, docs, i, k, key, orders, row, sorting, v, where, _i, _len;\n        if (err) {\n            if (err.statusCode == 404) {\n                return err;\n            } else {\n                return err;\n            }\n        }\n        docs = body.map(function (row) {\n            var item = row.value;\n            item.id = row.id;\n            return item;\n        });\n        // console.log('docs:', docs)\n        where = filter !== null ? filter.where : void 0;\n        if (where) {\n            docs = docs ? docs.filter(helpers.applyFilter(filter)) : docs;\n        }\n\n        orders = filter !== null ? filter.order : void 0;\n        if (orders) {\n            if (typeof orders === 'string') {\n                orders = [orders];\n            }\n            sorting = function (a, b) {\n                var ak, bk, i, item, rev, _i, _len;\n                for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {\n                    item = this[i];\n                    ak = a[this[i].key];\n                    bk = b[this[i].key];\n                    rev = this[i].reverse;\n                    if (ak > bk) {\n                        return 1 * rev;\n                    }\n                    if (ak < bk) {\n                        return -1 * rev;\n                    }\n                }\n                return 0;\n            };\n            for (i = _i = 0, _len = orders.length; _i < _len; i = ++_i) {\n                key = orders[i];\n                orders[i] = {\n                    reverse: helpers.reverse(key),\n                    key: helpers.stripOrder(key)\n                };\n            }\n            docs.sort(sorting.bind(orders));\n        }\n\n        return callback(err, (function () {\n            var _j, _len1, _results;\n            _results = [];\n            for (_j = 0, _len1 = docs.length; _j < _len1; _j++) {\n                doc = docs[_j];\n                _results.push(this.fromDB(model, doc));\n            }\n            return _results;\n        }).call(self));\n    });\n};\n\nCouchBase.prototype.autoupdate = function (callback) {\n    this.client.manager().createBucket(database, {}, function (err) {\n        if (err) console.log('createBucket', err)\n        return callback && callback();\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/firebird.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar fb = safeRequire('node-firebird');\n\nvar quote = function (value) {\n    return '\"' + value + '\"';\n};\n\nexports.initialize = function initializeSchema(schema, callback) {\n    'use strict';\n    if (!fb) {\n        return;\n    }\n    var options = {}, s = schema.settings;\n\n    options.host = s.host;\n    options.port = s.port;\n    options.database = s.database || 'test.fdb';\n    options.user = s.username || 'sysdba';\n    options.password = s.password || 'aea0be33';\n    schema.adapter = new FB(schema, s);\n\n    if (s.pool) {\n        fb.pool(s.pool, options)\n            .get(function (err, client) {\n                if (!err) {\n                    schema.adapter.client = client;\n                    console.log('FB', typeof client.execute)\n                    process.nextTick(function () {\n                        callback();\n                    });\n                } else {\n                    console.error(err);\n                    throw new Error(err);\n                }\n            });\n    } else {\n        fb.attachOrCreate(options, function (err, client) {\n                if (!err) {\n                    schema.adapter.client = client;\n                    console.log('FB', typeof client.execute)\n                    process.nextTick(function () {\n                        callback();\n                    });\n                } else {\n                    console.error(err);\n                    throw new Error(err);\n                }\n            }\n        );\n    }\n};\n\nfunction FB(schema, s) {\n    this.name = 'firebird';\n    this._models = {};\n    this.collections = {};\n    this.client = {};\n    this.schema = schema;\n    this.s = s;\n}\n\nFB.prototype.define = function (descr) {\n    if (!descr.settings) {\n        descr.settings = {};\n    }\n    this._models[descr.model.modelName] = descr;\n};\n\nFB.prototype.autoupdate = function (callback) {\n    var self = this;\n\n    self.client.execute('SELECT a.RDB$RELATION_NAME FROM RDB$RELATIONS a' +\n        ' WHERE RDB$SYSTEM_FLAG = 0 AND RDB$RELATION_TYPE = 0', function (err, relations) {\n        if (err) {\n            console.log('err', err)\n        }\n\n        var tables = ((relations || [])[0] || []).map(function (item) {\n            return (item || '').replace(/^\\s+|\\s+$/, '');\n        });\n        var len = Object.keys(self._models).length;\n\n        Object.keys(self._models).forEach(function (name) {\n\n            if (tables.indexOf(name) === -1) {\n                var table = self.schema.tableName(name);\n                var model = self._models[name];\n                self.client.startTransaction(function (err, tr) {\n                    var sql = 'CREATE TABLE ' + quote(table) + '(\\n' +\n                        ' \"id\" INTEGER NOT NULL,\\n';\n                    Object.keys(model.properties).forEach(function (field) {\n                            var str;\n                            if (field === 'id') {\n                                return;\n                            }\n                            var f = model.properties[field];\n                            switch (f.type.name) {\n                                case 'String':\n                                    str = 'Varchar(' + (f.length || f.limit || 255) + ')';\n                                    break;\n                                case 'Number':\n                                    str = 'Double precision';\n                                    break;\n                                case 'Date':\n                                    str = 'Timestamp';\n                                    break;\n                                case 'Boolean':\n                                    str = 'Smallint';\n                                    break;\n                                default:\n                                    str = 'Blob sub_type 1';\n                            }\n                            sql += ' ' + quote(field) + ' ' + str + (f.allowNull === false || f['null'] === false ? ' NOT NULL,' : ',') + '\\n';\n                        }\n                    );\n                    sql += ' PRIMARY KEY (\"id\"))';\n\n                    console.log('sql:', sql)\n                    tr.execute(sql, function (err) {\n                        if (!err) {\n                            var sequence = quote(table + '_SEQ');\n                            tr.execute('create generator ' + sequence);\n                            tr.execute('set generator ' + sequence + ' to 0');\n                            tr.execute(\n                                'CREATE TRIGGER ' + quote(table + '_BI') + ' FOR ' + quote(table) + '\\n' +\n                                'ACTIVE BEFORE INSERT POSITION 0\\n' +\n                                'AS\\n' +\n                                'BEGIN\\n' +\n                                '  IF (NEW.\"id\" IS NULL) THEN\\n' +\n                                '    NEW.\"id\" = GEN_ID(' + sequence + ', 1);\\n' +\n                                'END', function () {\n                                    if (--len === 0) {\n                                        tr.commit(callback);\n                                    }\n                                });\n                        } else {\n                            if (--len === 0) {\n                                tr.rollback(callback);\n                            }\n                        }\n                    });\n                });\n            } else {\n                // TODO actualise\n                if (--len === 0) {\n                    console.log('autoupdate end')\n                    callback();\n                }\n            }\n        });\n    });\n};\n\nFB.prototype.automigrate = function (cb) {\n    var wait = 0;\n    var self = this;\n\n    this.client.startTransaction(function (err, tr) {\n            Object.keys(self._models).forEach(\n                function (name) {\n                    var table = self.schema.tableName(name);\n                    var model = self._models[name];\n                    wait += 1;\n                    var sql = 'RECREATE TABLE ' + quote(table) + '(\\n' +\n                        ' \"id\" INTEGER NOT NULL,\\n';\n                    Object.keys(model.properties).forEach(\n                        function (field) {\n                            var str;\n                            if (field === 'id')\n                                return;\n                            var f = model.properties[field];\n                            switch (f.type.name) {\n                                case 'String':\n                                    str = 'Varchar(' + (f.length || 255) + ')';\n                                    break;\n                                case 'Number':\n                                    str = 'Double precision';\n                                    break;\n                                case 'Date':\n                                    str = 'Timestamp';\n                                    break;\n                                case 'Boolean':\n                                    str = 'Smallint';\n                                    break;\n                                default:\n                                    str = 'Blob sub_type 1';\n                            }\n                            sql += ' ' + quote(field) + ' ' + str + (f.allowNull === false || f['null'] === false ? ' NOT NULL,' : ',') + '\\n';\n                        }\n                    );\n                    sql += ' PRIMARY KEY (\"id\"))';\n\n                    tr.execute(sql, function (err) {\n                        if (!err) {\n                            var sequence = quote(table + '_SEQ');\n                            tr.execute('create generator ' + sequence);\n                            tr.execute('set generator ' + sequence + ' to 0');\n                            tr.execute(\n                                'CREATE TRIGGER ' + quote(table + '_BI') + ' FOR ' + quote(table) + '\\n' +\n                                'ACTIVE BEFORE INSERT POSITION 0\\n' +\n                                'AS\\n' +\n                                'BEGIN\\n' +\n                                '  IF (NEW.\"id\" IS NULL) THEN\\n' +\n                                '    NEW.\"id\" = GEN_ID(' + sequence + ', 1);\\n' +\n                                'END', done);\n                        } else {\n                            done(err);\n                        }\n                    });\n                }\n            );\n\n            if (wait === 0) {\n                cb();\n            }\n            function done(err) {\n                if (err) {\n                    tr.rollback(cb);\n                } else {\n                    if (--wait === 0) {\n                        tr.commit(cb);\n                    }\n                }\n            }\n        }\n    );\n};\n\nFB.prototype.create = function (name, data, callback) {\n    var table = this.schema.tableName(name);\n    var sql = 'INSERT INTO ' + quote(table);\n\n    var fields = [];\n    var values = [];\n    var params = [];\n\n    Object.keys(data).forEach(\n        function (key) {\n            if (key === 'id')\n                return;\n            fields.push(quote(key));\n            values.push('?');\n            params.push(data[key]);\n        }\n    );\n\n    if (fields.length) {\n        sql += ' (' + fields.join(',') + ') VALUES (' + values.join(',') + ')';\n    } else {\n        sql += ' VALUES ()';\n    }\n\n    sql += ' RETURNING \"id\"';\n\n    this.client.execute(sql, params,\n        function (err, result) {\n            callback(err, (result) ? result[0] : undefined);\n        }\n    );\n};\n\nFB.prototype.destroy = function destroy(name, id, callback) {\n    if (id) {\n        var table = this.schema.tableName(name);\n        var sql = 'DELETE FROM ' + quote(table) + ' WHERE \"id\" = ?';\n        this.client.execute(sql, id, callback);\n    } else {\n        callback('nothing to destroy');\n    }\n};\n\nFB.prototype.save = function (name, data, callback) {\n    var table = this.schema.tableName(name);\n    var sql = 'UPDATE ' + quote(table) + ' SET ';\n\n    var fields = [];\n    var params = [];\n    var model = this._models[name];\n\n    Object.keys(data).forEach(\n        function (key) {\n            if (key === 'id')\n                return;\n            fields.push(quote(key) + ' = ?');\n            if ((data[key]) && (model.properties[key].type.name === 'Date')) {\n                params.push(new Date(data[key]));\n            } else {\n                params.push(data[key]);\n            }\n        }\n    );\n    sql += fields.join(',') + ' WHERE \"id\"=?';\n    params.push(data.id);\n\n    this.client.execute(sql, params, callback);\n};\n\nFB.prototype.findById = function findById(name, id, callback) {\n    var table = this.schema.tableName(name);\n    var sql = 'SELECT FIRST 1 * FROM ' + quote(table) + ' WHERE \"id\" = ?';\n    this.client.query(sql, id,\n        function (err, result) {\n            callback(err, (result && result.length === 1) ? result[0] : undefined);\n        }\n    );\n};\n\nFB.prototype.all = function (name, filter, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    var table = this.schema.tableName(name);\n    var sql = '* FROM ' + quote(table);\n    var params = [];\n\n    if (filter) {\n        var self = this;\n        if (filter.where) {\n            sql += ' ' + buildWhere(filter.where);\n        }\n\n        if (filter.order) {\n            sql += ' ' + buildOrderBy(filter.order);\n        }\n\n        if (filter.limit) {\n            sql = buildLimit(filter.limit, filter.offset || 0) + ' ' + sql;\n        }\n\n    }\n    this.client.query('SELECT ' + sql, params, callback);\n\n    function buildWhere(conds) {\n        var cs = [];\n        var props = self._models[name].properties;\n        Object.keys(conds).forEach(\n            function (key) {\n                var keyEscaped = quote(key);\n                var val = conds[key];\n                var lst, i;\n                if (conds[key] === null) {\n                    cs.push(keyEscaped + ' IS NULL');\n                } else if (conds[key].constructor.name === 'Object') {\n                    switch (Object.keys(conds[key])[0]) {\n                        case 'gt':\n                            cs.push(keyEscaped + ' > ?');\n                            params.push(val.gt);\n                            break;\n                        case 'gte':\n                            cs.push(keyEscaped + ' >= ?');\n                            params.push(val.gte);\n                            break;\n                        case 'lt':\n                            cs.push(keyEscaped + ' < ?');\n                            params.push(val.lt);\n                            break;\n                        case 'lte':\n                            cs.push(keyEscaped + ' <= ?');\n                            params.push(val.lte);\n                            break;\n                        case 'between':\n                            cs.push(keyEscaped + ' BETWEEN ? AND ?');\n                            params.push(val.between[0]);\n                            params.push(val.between[1]);\n                            break;\n                        case 'in':\n                        case 'inq':\n                            if (val.inq instanceof Array) {\n                                lst = new Array(val.inq.length);\n                                for (i = 0; i < val.inq.length; i++) {\n                                    lst[i] = '?';\n                                    params.push(val.inq[i]);\n                                }\n                            } else {\n                                lst = [val.inq];\n                                params.push(val.inq);\n                            }\n                            cs.push(keyEscaped + ' IN (' + lst.join(',') + ')');\n                            break;\n                        case 'nin':\n                            if (val.nin instanceof Array) {\n                                lst = new Array(val.nin.length);\n                                for (i = 0; i < val.nin.length; i++) {\n                                    lst[i] = '?';\n                                    params.push(val.nin[i]);\n                                }\n                            } else {\n                                lst = [val.nin];\n                                params.push(val.nin);\n                            }\n                            cs.push(keyEscaped + ' NOT IN (' + lst.join(',') + ')');\n                            break;\n                        case 'ne':\n                        case 'neq':\n                            cs.push(keyEscaped + ' != ?');\n                            params.push(val.neq);\n                            break;\n                        case 'regexp':\n                            cs.push(keyEscaped + ' REGEXP ?');\n                            params.push(val.lte);\n                            break;\n                    }\n                } else {\n                    cs.push(keyEscaped + ' = ?');\n                    params.push(val);\n                }\n            }\n        );\n        if (cs.length === 0) {\n            return '';\n        }\n        return 'WHERE ' + cs.join(' AND ');\n    }\n\n    function buildOrderBy(order) {\n        if (typeof order === 'string') {\n            order = order.split(' ');\n            order[0] = [quote(order[0])];\n            return 'ORDER BY ' + order.join(' ');\n        } else {\n            for (var i = 0; i < order.length; i++) {\n                order[i] = quote(order[i]);\n            }\n            return 'ORDER BY ' + order.join(', ');\n        }\n    }\n\n    function buildLimit(limit, offset) {\n        var ret = 'FIRST ' + limit;\n        if (offset) {\n            ret += ' SKIP ' + offset;\n        }\n        return ret;\n    }\n};\n\nFB.prototype.destroyAll = function (name, callback) {\n    var table = this.schema.tableName(name);\n    var sql = 'DELETE FROM ' + quote(table);\n    this.client.query(sql, callback);\n};\n\nFB.prototype.count = function count(name, callback, where) {\n    var table = this.schema.tableName(name);\n    var params = [];\n    var model = this._models[name];\n\n    this.client.execute('SELECT count(*) FROM ' + quote(table) + buildWhere(where), params,\n        function (err, result) {\n            callback(err, (result) ? result[0][0] : undefined);\n        }\n    );\n\n    function buildWhere(conds) {\n        var cs = [];\n        Object.keys(conds || {}).forEach(\n            function (key) {\n                if (conds[key] === null) {\n                    cs.push(quote(key) + ' IS NULL');\n                } else {\n                    cs.push(quote(key) + ' = ?');\n                    if (model.properties[key].type.name === 'Date') {\n                        params.push(new Date(conds[key]));\n                    } else {\n                        params.push(conds[key]);\n                    }\n                }\n            }\n        );\n        return cs.length ? ' WHERE ' + cs.join(' AND ') : '';\n    }\n};\n\nFB.prototype.exists = function count(name, id, callback) {\n    var table = this.schema.tableName(name);\n    var sql = 'SELECT FIRST 1 \"id\" FROM ' + quote(table) + ' WHERE \"id\" = ?';\n    this.client.execute(sql, id,\n        function (err, data) {\n            callback(err, (data) ? data.length === 1 : undefined);\n        }\n    );\n};\n\nFB.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\n    data.id = id;\n    this.save(model, data, cb);\n};\n\nFB.prototype.updateOrCreate = function (name, data, callback) {\n    var table = this.schema.tableName(name);\n    var sql = 'UPDATE OR INSERT INTO ' + quote(table);\n\n    var fields = [];\n    var values = [];\n    var params = [];\n\n    Object.keys(data).forEach(\n        function (key) {\n            fields.push(quote(key));\n            values.push('?');\n            params.push(data[key]);\n        }\n    );\n\n    if (fields.length) {\n        sql += ' (' + fields.join(',') + ') VALUES (' + values.join(',') + ')';\n    } else {\n        sql += ' VALUES ()';\n    }\n\n    this.client.execute(sql, params,\n        function (err) {\n            callback(err, data);\n        }\n    );\n};","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/http.js":"exports.initialize = function initializeSchema(schema, callback) {\r\n    schema.adapter = new WebService();\r\n    process.nextTick(callback);\r\n};\r\n\r\nfunction WebService() {\r\n    this.name = 'http';\r\n    this._models = {};\r\n    this.cache = {};\r\n    this.ids = {};\r\n}\r\n\r\nWebService.prototype.define = function defineModel(descr) {\r\n    var m = descr.model.modelName;\r\n    this._models[m] = descr;\r\n};\r\n\r\nWebService.prototype.getResourceUrl = function getResourceUrl(model) {\r\n    var url = this._models[model].settings.restPath;\r\n    if (!url) throw new Error('Resource url (restPath) for ' + model + ' is not defined');\r\n    return url;\r\n};\r\n\r\nWebService.prototype.getBlankReq = function () {\r\n    if (!this.csrfToken) {\r\n        this.csrfToken = $('meta[name=csrf-token]').attr('content');\r\n        this.csrfParam = $('meta[name=csrf-param]').attr('content');\r\n    }\r\n    var req = {};\r\n    req[this.csrfParam] = this.csrfToken;\r\n    return req;\r\n};\r\n\r\nWebService.prototype.create = function create(model, data, callback) {\r\n    var req = this.getBlankReq();\r\n    req[model] = data;\r\n    $.post(this.getResourceUrl(model) + '.json', req, function (res) {\r\n        if (res.code === 200) {\r\n            callback(null, res.data.id);\r\n        } else {\r\n            callback(res.error);\r\n        }\r\n    }, 'json');\r\n    // this.cache[model][id] = data;\r\n};\r\n\r\nWebService.prototype.updateOrCreate = function (model, data, callback) {\r\n    var mem = this;\r\n    this.exists(model, data.id, function (err, exists) {\r\n        if (exists) {\r\n            mem.save(model, data, callback);\r\n        } else {\r\n            mem.create(model, data, function (err, id) {\r\n                data.id = id;\r\n                callback(err, data);\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nWebService.prototype.save = function save(model, data, callback) {\r\n    var req = this.getBlankReq();\r\n    req._method = 'PUT';\r\n    req[model] = data;\r\n    $.post(this.getResourceUrl(model) + '/' + data.id + '.json', req, function (res) {\r\n        if (res.code === 200) {\r\n            callback(null, res.data);\r\n        } else {\r\n            callback(res.error);\r\n        }\r\n    }, 'json');\r\n};\r\n\r\nWebService.prototype.exists = function exists(model, id, callback) {\r\n    $.getJSON(this.getResourceUrl(model) + '/' + id + '.json', function (res) {\r\n        if (res.code === 200) {\r\n            callback(null, true);\r\n        } else if (res.code === 404) {\r\n            callback(null, false);\r\n        } else {\r\n            callback(res.error);\r\n        }\r\n    });\r\n};\r\n\r\nWebService.prototype.findById = function findById(model, id, callback) {\r\n    $.getJSON(this.getResourceUrl(model) + '/' + id + '.json', function (res) {\r\n        if (res.code === 200) {\r\n            callback(null, res.data);\r\n        } else {\r\n            callback(res.error);\r\n        }\r\n    });\r\n};\r\n\r\nWebService.prototype.destroy = function destroy(model, id, callback) {\r\n    delete this.cache[model][id];\r\n    callback();\r\n};\r\n\r\nWebService.prototype.all = function all(model, filter, callback) {\r\n    $.getJSON(this.getResourceUrl(model) + '.json?query=' + JSON.stringify(filter), function (res) {\r\n        if (res.code === 200) {\r\n            callback(null, res.data);\r\n        } else {\r\n            callback(res.error);\r\n        }\r\n    });\r\n};\r\n\r\nWebService.prototype.destroyAll = function destroyAll(model, callback) {\r\n    throw new Error('Not supported');\r\n};\r\n\r\nWebService.prototype.count = function count(model, callback, where) {\r\n    throw new Error('Not supported');\r\n};\r\n\r\nWebService.prototype.updateAttributes = function (model, id, data, callback) {\r\n    data.id = id;\r\n    this.save(model, data, callback);\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/memory.js":"/**\r\n * Module dependencies\r\n */\r\nvar utils = require('../utils');\r\nvar helpers = utils.helpers;\r\n\r\nexports.initialize = function initializeSchema(schema, callback) {\r\n    schema.adapter = new Memory();\r\n    process.nextTick(callback);\r\n};\r\n\r\nfunction Memory() {\r\n    this.name = 'memory';\r\n    this._models = {};\r\n    this.cache = {};\r\n    this.ids = {};\r\n}\r\n\r\nMemory.prototype.define = function defineModel(descr) {\r\n    var m = descr.model.modelName;\r\n    this._models[m] = descr;\r\n    this.cache[m] = {};\r\n    this.ids[m] = 1;\r\n};\r\n\r\nMemory.prototype.toDatabase = function (model, data) {\r\n    var cleaned = {};\r\n    Object.keys(data).forEach(function (key) {\r\n        cleaned[key] = data[key];\r\n    });\r\n    return cleaned;\r\n};\r\n\r\nMemory.prototype.create = function create(model, data, callback) {\r\n    var id = data.id || this.ids[model]++;\r\n    data.id = id;\r\n    this.cache[model][id] = this.toDatabase(model, data);\r\n    process.nextTick(function () {\r\n        callback(null, id);\r\n    });\r\n};\r\n\r\nMemory.prototype.updateOrCreate = function (model, data, callback) {\r\n    var mem = this;\r\n    this.exists(model, data.id, function (err, exists) {\r\n        if (exists) {\r\n            mem.save(model, data, callback);\r\n        } else {\r\n            mem.create(model, data, function (err, id) {\r\n                data.id = id;\r\n                callback(err, data);\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nMemory.prototype.save = function save(model, data, callback) {\r\n    this.cache[model][data.id] = data;\r\n    process.nextTick(function () {\r\n        callback(null, data);\r\n    });\r\n};\r\n\r\nMemory.prototype.exists = function exists(model, id, callback) {\r\n    process.nextTick(function () {\r\n        callback(null, this.cache[model].hasOwnProperty(id));\r\n    }.bind(this));\r\n};\r\n\r\nMemory.prototype.findById = function findById(model, id, callback) {\r\n    process.nextTick(function () {\r\n        callback(null, this.cache[model][id]);\r\n    }.bind(this));\r\n};\r\n\r\nMemory.prototype.destroy = function destroy(model, id, callback) {\r\n    delete this.cache[model][id];\r\n    process.nextTick(callback);\r\n};\r\n\r\nMemory.prototype.remove = function remove(model, filter, callback) {\r\n    var self = this;\r\n    self.all(model, filter, function (err, nodes) {\r\n        var count = nodes.length;\r\n        if (count > 0) {\r\n            nodes.forEach(function (node) {\r\n                delete self.cache[model][node.id];\r\n                if (--count === 0) {\r\n                    callback();\r\n                }\r\n            });\r\n        } else {\r\n            callback();\r\n        }\r\n    });\r\n};\r\n\r\nMemory.prototype.all = function all(model, filter, callback) {\r\n    if ('function' === typeof filter) {\r\n        callback = filter;\r\n        filter = {};\r\n    }\r\n    if (!filter) {\r\n        filter = {};\r\n    }\r\n    var nodes = Object.keys(this.cache[model]).map(function (key) {\r\n        return this.cache[model][key];\r\n    }.bind(this));\r\n\r\n    if (filter) {\r\n\r\n        // do we need some filtration?\r\n        if (filter.where) {\r\n            nodes = nodes ? nodes.filter(helpers.applyFilter(filter)) : nodes;\r\n        }\r\n\r\n        // do we need some sorting?\r\n        if (filter.order) {\r\n            var props = this._models[model].properties;\r\n            var orders = filter.order;\r\n            if (typeof filter.order === \"string\") {\r\n                orders = [filter.order];\r\n            }\r\n            orders.forEach(function (key, i) {\r\n                var reverse = 1;\r\n                var m = key.match(/\\s+(A|DE)SC$/i);\r\n                if (m) {\r\n                    key = key.replace(/\\s+(A|DE)SC/i, '');\r\n                    if (m[1] === 'DE')\r\n                        reverse = -1;\r\n                }\r\n                orders[i] = {\"key\": key, \"reverse\": reverse};\r\n            });\r\n            nodes = nodes.sort(sorting.bind(orders));\r\n        }\r\n    }\r\n\r\n    process.nextTick(function () {\r\n        callback(null, nodes);\r\n    });\r\n\r\n    function sorting(a, b) {\r\n        for (var i = 0, l = this.length; i < l; i++) {\r\n            if (a[this[i].key] > b[this[i].key]) {\r\n                return 1 * this[i].reverse;\r\n            } else if (a[this[i].key] < b[this[i].key]) {\r\n                return -1 * this[i].reverse;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n\r\nMemory.prototype.destroyAll = function destroyAll(model, callback) {\r\n    Object.keys(this.cache[model]).forEach(function (id) {\r\n        delete this.cache[model][id];\r\n    }.bind(this));\r\n    this.cache[model] = {};\r\n    process.nextTick(callback);\r\n};\r\n\r\nMemory.prototype.count = function count(model, callback, where) {\r\n    var cache = this.cache[model];\r\n    var data = Object.keys(cache);\r\n    if (where) {\r\n        data = data.filter(function (id) {\r\n            var ok = true;\r\n            Object.keys(where).forEach(function (key) {\r\n                if (cache[id][key] !== where[key]) {\r\n                    ok = false;\r\n                }\r\n            });\r\n            return ok;\r\n        });\r\n    }\r\n    process.nextTick(function () {\r\n        callback(null, data.length);\r\n    });\r\n};\r\n\r\nMemory.prototype.updateAttributes = function updateAttributes(model, id, data, cb) {\r\n    data.id = id;\r\n    var base = this.cache[model][id];\r\n    this.save(model, helpers.merge(base, data), cb);\r\n};","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/mongodb.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar mongodb = safeRequire('mongodb');\nvar ObjectID = mongodb.ObjectID;\nvar url = require('url');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    'use strict';\n    if (!mongodb) {\n        return;\n    }\n    var s = schema.settings;\n\n    if (schema.settings.rs) {\n        s.rs = schema.settings.rs;\n        if (schema.settings.url) {\n            var uris = schema.settings.url.split(',');\n            s.hosts = [];\n            s.ports = [];\n            uris.forEach(function (uri) {\n                var durl = url.parse(uri);\n\n                s.hosts.push(durl.hostname || 'localhost');\n                s.ports.push(parseInt(durl.port || '27017', 10));\n\n                if (!s.database)\n                    s.database = durl.pathname.replace(/^\\//, '');\n                if (!s.username)\n                    s.username = durl.auth && durl.auth.split(':')[0];\n                if (!s.password)\n                    s.password = durl.auth && durl.auth.split(':')[1];\n            });\n        }\n        s.database = s.database || 'test';\n    } else {\n        if (schema.settings.url) {\n            var durl = url.parse(schema.settings.url);\n            s.host = durl.hostname;\n            s.port = durl.port;\n            s.database = durl.pathname.replace(/^\\//, '');\n            s.username = durl.auth && durl.auth.split(':')[0];\n            s.password = durl.auth && durl.auth.split(':')[1];\n        }\n        s.host = s.host || 'localhost';\n        s.port = parseInt(s.port || '27017', 10);\n        s.database = s.database || process.env.USER || 'test';\n    }\n\n    s.safe = s.safe || false;\n    schema.adapter = new MongoDB(s, schema, callback);\n    schema.ObjectID = ObjectID;\n};\n\nfunction MongoDB(s, schema, callback) {\n    var i, n;\n    this.name = 'mongodb';\n    this._models = {};\n    this.collections = {};\n    this.schema = schema;\n    this.s = s;\n\n    var server;\n    if (s.rs) {\n        var sets = [];\n        for (i = 0, n = s.hosts.length; i < n; i++) {\n            sets.push(new mongodb.Server(s.hosts[i], s.ports[i], {auto_reconnect: true}));\n        }\n        server = new mongodb.ReplSet(sets, {rs_name: s.rs});\n\n    } else {\n        server = new mongodb.Server(s.host, s.port, {});\n    }\n\n    new mongodb.Db(s.database, server, {safe: s.safe}).open(function (err, client) {\n        if (err) {\n            throw err;\n        }\n\n        this.client = client;\n        this.schema = schema;\n\n        this.connection()\n            .then(callback);\n    }.bind(this));\n}\n\nMongoDB.prototype.connection = function () {\n    var t = this;\n\n    return new Promise(function(resolve, reject) {\n        if (t.s.username && t.s.password) {\n            t.client.authenticate(t.s.username, t.s.password, function (err, result) {\n                if (err) {\n                    reject(err);\n                } else {\n                    t.schema.client = t.client;\n                    resolve();\n                }\n            });\n        } else {\n            t.schema.client = t.client;\n            setImmediate(resolve);\n        }\n    });\n};\n\nMongoDB.prototype.define = function (descr) {\n    if (!descr.settings)\n        descr.settings = {};\n    var self = this;\n    this._models[descr.model.modelName] = descr;\n    this.connection().then(function() {\n        Object.keys(descr.properties).forEach(function (k) {\n            if (typeof descr.properties[k].index !== 'undefined' || typeof descr.properties[k].unique !== 'undefined') {\n                var fields = {}, params = {};\n                fields[k] = 1;\n                params['name'] = '_' + k + '_';\n                if (typeof descr.properties[k].unique !== 'undefined') {\n                    params['unique'] = true;\n                }\n                self.collection(descr.model.modelName).ensureIndex(fields, params);\n            }\n        });\n    });\n};\n\nMongoDB.prototype.defineProperty = function (model, prop, params) {\n    this._models[model].properties[prop] = params;\n};\n\nMongoDB.prototype.collection = function (name) {\n    if (this.client.collection) {\n        return this.client.collection(name);\n    } else {\n        if (!this.collections[name]) {\n            this.collections[name] = new mongodb.Collection(this.client, name);\n        }\n        return this.collections[name];\n    }\n};\n\nMongoDB.prototype.ensureIndex = function (model, fields, params, callback) {\n    this.collection(model).ensureIndex(fields, params);\n    return callback(null);\n};\n\nMongoDB.prototype.create = function (model, data, callback) {\n    if (data.id === null) {\n        delete data.id;\n    }\n    this.collection(model).insert(data, {}, function (err, m) {\n        var inserted;\n        inserted = m[0] && m[0]._id ? m[0]._id : null;\n        inserted = m.ops && m.ops[0] && m.ops[0]._id ? m.ops[0]._id : inserted;\n        callback(err, err ? null : inserted);\n    });\n};\n\nMongoDB.prototype.save = function (model, data, callback) {\n    var id = data.id;\n    id = getObjectId(id);\n    this.collection(model).update({_id: id}, data, function (err) {\n        callback(err);\n    });\n};\n/**\n * Update rows\n * @param {String} model\n * @param {Object} filter\n * @param {Object} data\n * @param {Function} callback\n */\nMongoDB.prototype.update = function (model, filter, data, callback) {\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parametrs undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parametrs undefined\"), null);\n    }\n    filter = filter.where ? filter.where : filter;\n    if (filter.id) {\n        var id = getObjectId(filter.id);\n        filter.id = id;\n    }\n    this.collection(model).update(filter, {'$set': data}, {w: 1, multi: true}, function (err) {\n        return callback && callback(err, 0);\n    });\n};\n\nMongoDB.prototype.exists = function (model, id, callback) {\n    id = getObjectId(id);\n    this.collection(model).findOne({_id: id}, function (err, data) {\n        return callback && callback(err, !err && data);\n    });\n};\n\nMongoDB.prototype.findById = function findById(model, id, callback) {\n    var self = this;\n    id = getObjectId(id);\n    self.collection(model).findOne({_id: id}, function (err, data) {\n        if (data) {\n            data.id = id;\n            data = self.fromDatabase(model, data);\n        }\n        callback(err, data);\n    });\n};\n\nMongoDB.prototype.updateOrCreate = function updateOrCreate(model, data, callback) {\n    var adapter = this;\n    if (!data.id)\n        return this.create(data, callback);\n    this.find(model, data.id, function (err, inst) {\n        if (err)\n            return callback(err);\n        if (inst) {\n            adapter.updateAttributes(model, data.id, data, callback);\n        } else {\n            delete data.id;\n            adapter.create(model, data, function (err, id) {\n                if (err)\n                    return callback(err);\n                if (id) {\n                    data.id = id;\n                    delete data._id;\n                    callback(null, data);\n                } else {\n                    callback(null, null); // wtf?\n                }\n            });\n        }\n    });\n};\n\nMongoDB.prototype.destroy = function destroy(model, id, callback) {\n    id = getObjectId(id);\n    this.collection(model).remove({_id: id}, callback);\n};\n\nMongoDB.prototype.remove = function remove(model, filter, callback) {\n    var cond = buildWhere(filter.where);\n    this.collection(model).remove(cond, callback);\n};\n\nMongoDB.prototype.all = MongoDB.prototype.find = function all(model, filter, callback) {\n    if (!filter) {\n        filter = {};\n    }\n    var query = {};\n    if (filter.where) {\n        query = buildWhere(filter.where);\n    }\n    var self = this, cursor = this.collection(model).find(query);\n\n    if (filter.order) {\n        var keys = filter.order;\n        if (typeof keys === 'string') {\n            keys = keys.split(',');\n        }\n        var args = {};\n        for (var index in keys) {\n            var m = keys[index].match(/\\s+(A|DE)SC$/);\n            var key = keys[index];\n            key = key.replace(/\\s+(A|DE)SC$/, '').trim();\n            if (m && m[1] === 'DE') {\n                args[key] = -1;\n            } else {\n                args[key] = 1;\n            }\n        }\n        cursor.sort(args);\n    }\n    if (filter.limit) {\n        cursor.limit(filter.limit);\n    }\n    if (filter.skip || filter.offset) {\n        cursor.skip(filter.skip || filter.offset);\n    }\n    cursor.toArray(function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        callback(null, data.map(function (o) {\n            return self.fromDatabase(model, o);\n        }));\n    });\n};\n\nMongoDB.prototype.destroyAll = function destroyAll(model, callback) {\n    this.collection(model).remove({}, callback);\n};\n\nMongoDB.prototype.count = function count(model, callback, filter) {\n    var cond = {};\n    if (filter && filter.where) {\n        cond = buildWhere(filter.where);\n    } else {\n        cond = buildWhere(filter);\n    }\n    this.collection(model).count(cond, callback);\n};\n\nMongoDB.prototype.updateAttributes = function updateAttrs(model, id, data, callback) {\n    id = getObjectId(id);\n    this.collection(model).findAndModify({_id: id}, [['_id', 'asc']], {$set: data}, {}, callback);\n};\n\nMongoDB.prototype.fromDatabase = function (model, data) {\n    var props = this._models[model].properties;\n    var clean = {};\n    Object.keys(data).forEach(function (key) {\n        if (!props[key]) {\n            return;\n        }\n        if (props[key].type.name.toString().toLowerCase() === 'date') {\n            if (data[key]) {\n                clean[key] = new Date(data[key]);\n            } else {\n                clean[key] = data[key];\n            }\n        } else {\n            clean[key] = data[key];\n        }\n    });\n    clean.id = data._id;\n    return clean;\n};\n\nMongoDB.prototype.disconnect = function () {\n    this.client.close();\n};\n\nfunction getObjectId(id) {\n    if (typeof id === 'string') {\n        id = new ObjectID(id);\n    } else if (typeof id === 'object' && id.constructor === Array) {\n        id = new ObjectID(id[0]);\n    }\n    return id;\n}\n\nfunction buildWhere(filter) {\n    var query = {};\n    Object.keys(filter).forEach(function (k) {\n        var cond = filter[k];\n        var spec = false;\n        if (k === 'id') {\n            k = '_id';\n        }\n\n        if (k === 'or') {\n            var arrcond = [];\n            Object.keys(cond).forEach(function (k2) {\n                var nval = {};\n                nval[k2] = cond[k2]\n                arrcond.push(nval);\n            });\n            query['$or'] = arrcond;\n            return;\n        }\n\n        if (cond && cond.constructor.name === 'Object') {\n            spec = Object.keys(cond)[0];\n            cond = cond[spec];\n        }\n        if (spec) {\n            if (spec === 'between') {\n                query[k] = {$gte: cond[0], $lte: cond[1]};\n            } else {\n                query[k] = {};\n                spec = spec === 'inq' ? 'in' : spec;\n                spec = spec === 'like' ? 'regex' : spec;\n                if (spec === 'nlike') {\n                    query[k]['$not'] = new RegExp(cond, 'i');\n                } else {\n                    query[k]['$' + spec] = cond;\n                }\n            }\n        } else {\n            if (cond === null) {\n                query[k] = {$type: 10};\n            } else {\n                query[k] = cond;\n            }\n        }\n    });\n    return query;\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/mongoose.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar mongoose = safeRequire('mongoose');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!mongoose) {\n        return;\n    }\n\n    if (!schema.settings.url) {\n        var url = schema.settings.host || 'localhost';\n        if (schema.settings.port) url += ':' + schema.settings.port;\n        var auth = '';\n        if (schema.settings.username) {\n            auth = schema.settings.username;\n            if (schema.settings.password) {\n                auth += ':' + schema.settings.password;\n            }\n        }\n        if (auth) {\n            url = auth + '@' + url;\n        }\n        if (schema.settings.database) {\n            url += '/' + schema.settings.database;\n        } else {\n            url += '/';\n        }\n        url = 'mongodb://' + url;\n        schema.settings.url = url;\n    }\n    if (!schema.settings.rs) {\n        schema.client = mongoose.connect(schema.settings.url);\n    } else {\n        schema.client = mongoose.createConnection(schema.settings.url, {\n            rs_name: schema.settings.rs\n        });\n    }\n\n    schema.adapter = new MongooseAdapter(schema.client);\n    process.nextTick(callback);\n};\n\nfunction MongooseAdapter(client) {\n    this.name = 'mongoose';\n    this._models = {};\n    this.client = client;\n    this.cache = {};\n}\n\nMongooseAdapter.prototype.define = function (descr) {\n    var props = {};\n    Object.keys(descr.properties).forEach(function (key) {\n        props[key] = {};\n        props[key].type = descr.properties[key].type;\n        if (props[key].type.name === 'Text') {\n            props[key].type = String;\n        }\n        if (props[key].type.name === 'Object' || props[key].type.name === 'JSON') {\n            props[key].type = mongoose.Schema.Types.Mixed;\n        }\n        if (descr.properties[key].index) {\n            props[key].index = descr.properties[key].index;\n        }\n    });\n    var schema = new mongoose.Schema(props);\n    this._models[descr.model.modelName] = mongoose.model(descr.model.modelName, schema, descr.settings.table || null);\n    this.cache[descr.model.modelName] = {};\n};\n\nMongooseAdapter.prototype.defineForeignKey = function (model, key, cb) {\n    var piece = {};\n    piece[key] = {\n        type: mongoose.Schema.ObjectId,\n        index: true\n    };\n    this._models[model].schema.add(piece);\n    cb(null, String);\n};\n\nMongooseAdapter.prototype.setCache = function (model, instance) {\n    this.cache[model][instance.id] = instance;\n};\n\nMongooseAdapter.prototype.getCached = function (model, id, cb) {\n    if (this.cache[model][id]) {\n        cb(null, this.cache[model][id]);\n    } else {\n        this._models[model].findById(id, function (err, instance) {\n            if (err) {\n                return cb(err);\n            }\n            this.cache[model][id] = instance;\n            cb(null, instance);\n        }.bind(this));\n    }\n};\n\nMongooseAdapter.prototype.create = function (model, data, callback) {\n    var m = new this._models[model](data);\n    m.save(function (err) {\n        callback(err, err ? null : m.id);\n    });\n};\n\nMongooseAdapter.prototype.save = function (model, data, callback) {\n    this.getCached(model, data.id, function (err, inst) {\n        if (err) {\n            return callback(err);\n        }\n        merge(inst, data);\n        inst.save(callback);\n    });\n};\n\nMongooseAdapter.prototype.exists = function (model, id, callback) {\n    delete this.cache[model][id];\n    this.getCached(model, id, function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        callback(err, !!data);\n    });\n};\n\nMongooseAdapter.prototype.findOne = function findOne(model, filter, fields, options, cb) {\n    if ('function' === typeof options) {\n        cb = options;\n        options = null;\n    } else if ('function' === typeof fields) {\n        cb = fields;\n        fields = null;\n        options = null;\n    } else if ('function' === typeof filter) {\n        cb = filter;\n        filter = {};\n        fields = null;\n        options = null;\n    }\n    if (!filter) {\n        filter = {};\n    }\n    var query = this._models[model].findOne({}, options);\n    if (fields) {\n        query.select(fields);\n    }\n    if (filter.where) {\n        Object.keys(filter.where).forEach(function (k) {\n            var cond = filter.where[k];\n            var spec = false;\n            if (cond && cond.constructor.name === 'Object') {\n                spec = Object.keys(cond)[0];\n                cond = cond[spec];\n            }\n            if (spec) {\n                if (spec === 'between') {\n                    query.where(k).gte(cond[0]).lte(cond[1]);\n                } else {\n                    query.where(k)[spec](cond);\n                }\n            } else {\n                query.where(k, cond);\n            }\n        });\n    }\n\n    query.exec(function (err, data) {\n        if (err) return cb(err);\n        cb(null, data);\n    });\n};\n\nMongooseAdapter.prototype.findById = function find(model, id, callback) {\n    delete this.cache[model][id];\n    this.getCached(model, id, function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        callback(err, data ? data.toObject() : null);\n    });\n};\n\nMongooseAdapter.prototype.all = function all(model, filter, cb) {\n\n    var options = {};\n    if ('function' === typeof filter) {\n        cb = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    if (filter.options) {\n        options = filter.options;\n    }\n\n    var query = this._models[model].find({}, options);\n\n    if (filter.where) {\n        Object.keys(filter.where).forEach(function (k) {\n            var cond = filter.where[k];\n            var spec = false;\n            if (cond && cond.constructor.name === 'Object') {\n                spec = Object.keys(cond)[0];\n                cond = cond[spec];\n            }\n            if (spec) {\n                switch (spec) {\n                    case \"between\":\n                        query.where(k).gte(cond[0]).lte(cond[1]);\n                        break;\n                    case \"regex\":\n                    case \"like\":\n                        query.where(k, new RegExp(cond, 'i'));\n                        break;\n                    case \"nlike\":\n                        query.where(k).not(new RegExp(cond, 'i'));\n                        break;\n                    case \"inq\":\n                        query.where(k)['in'](cond);\n                        break;\n                    default:\n                        query.where(k)[spec](cond);\n                }\n\n            } else {\n                query.where(k, cond);\n            }\n        });\n    }\n    if (filter.fields) {\n        query.select(filter.fields);\n    }\n    if (filter.order) {\n        var keys = filter.order; // can be Array or String\n        if (typeof(keys) === \"string\") {\n            keys = keys.split(',');\n        }\n\n        for (index in keys) {\n            var m = keys[index].match(/\\s+(A|DE)SC$/);\n\n            keys[index] = keys[index].replace(/\\s+(A|DE)SC$/, '');\n            if (parseInt(mongoose.version.substr(0, 1)) >= 3) {\n                if (m && m[1] === 'DE') {\n                    query.sort('-' + keys[index].trim());\n                } else {\n                    query.sort(keys[index].trim());\n                }\n            } else {\n                if (m && m[1] === 'DE') {\n                    query.desc(keys[index].trim());\n                } else {\n                    query.asc(keys[index].trim());\n                }\n            }\n        }\n    }\n    if (filter.limit) {\n        query.limit(filter.limit);\n    }\n    if (filter.skip) {\n        query.skip(filter.skip);\n    } else if (filter.offset) {\n        query.skip(filter.offset);\n    }\n    query.exec(function (err, data) {\n        if (err) return cb(err);\n        cb(null, data);\n    });\n};\n\n\nMongooseAdapter.prototype.remove = function remove(model, filter, cb) {\n\n    var options = {};\n    if ('function' === typeof filter) {\n        cb = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    if (filter.options) {\n        options = filter.options;\n    }\n\n    var query = this._models[model].find({}, options);\n\n    if (filter.where) {\n        Object.keys(filter.where).forEach(function (k) {\n            var cond = filter.where[k];\n            var spec = false;\n            if (cond && cond.constructor.name === 'Object') {\n                spec = Object.keys(cond)[0];\n                cond = cond[spec];\n            }\n            if (spec) {\n                switch (spec) {\n                    case \"between\":\n                        query.where(k).gte(cond[0]).lte(cond[1]);\n                        break;\n                    case \"regex\":\n                    case \"like\":\n                        query.where(k, new RegExp(cond, 'i'));\n                        break;\n                    case \"nlike\":\n                        query.where(k).not(new RegExp(cond, 'i'));\n                        break;\n                    case \"inq\":\n                        query.where(k)['in'](cond);\n                        break;\n                    default:\n                        query.where(k)[spec](cond);\n                }\n\n            } else {\n                query.where(k, cond);\n            }\n        });\n    }\n\n    query.exec(function (err, data) {\n        if (err) return cb(err);\n        if (data) {\n            var count = data.length || 0;\n            for (var i in data) {\n                if (typeof data[i] !== 'undefined') {\n                    data[i].remove(function () {\n                        if (--count === 0) {\n                            cb(null, data);\n                        }\n                    });\n                } else {\n                    if (--count === 0) {\n                        cb(null, data);\n                    }\n                }\n            }\n        } else {\n            cb(null, data);\n        }\n    });\n};\n\nMongooseAdapter.prototype.destroy = function destroy(model, id, cb) {\n    this.getCached(model, id, function (err, data) {\n        if (err) {\n            return cb(err);\n        }\n        if (data) {\n            data.remove(cb);\n        } else {\n            cb(null);\n        }\n    });\n};\n\nMongooseAdapter.prototype.destroyAll = function destroyAll(model, cb) {\n\n    this._models[model].find(function (err, data) {\n        if (err) return callback(err);\n        wait = data.length;\n        if (!data.length) return callback(null);\n        data.forEach(function (obj) {\n            obj.remove(done);\n        });\n    });\n\n    var error = null;\n\n    function done(err) {\n        error = error || err;\n        if (--wait === 0) {\n            callback(error);\n        }\n    }\n};\n\nMongooseAdapter.prototype.count = function count(model, cb, where) {\n    this._models[model].count(where || {}, cb);\n};\n\nMongooseAdapter.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\n    this.getCached(model, id, function (err, inst) {\n        if (err) {\n            return cb(err);\n        } else if (inst) {\n            merge(inst, data);\n            inst.save(cb);\n        } else cb();\n    });\n};\n\n// MongooseAdapter.prototype.findAndModify(model, filter, fields, data, {}, cb);\n\nMongooseAdapter.prototype.updateOrCreate = function (model, data, field, cb) {\n    if ('function' === typeof field) {\n        cb = field;\n        field = \"id\";\n    }\n    var props = {};\n    Object.keys(data).forEach(function (key) {\n        if (props[key] || key === field) {\n            props[field] = data[key];\n        }\n    });\n    this._models[model].findOne(props, function (err, doc) {\n        if (!err) {\n            if (!doc) {\n                var m = new this._models[model](data);\n                m.save(function (err) {\n                    cb(err, err ? null : m.id);\n                });\n            } else {\n                doc = merge(doc, data);\n                doc.save(function (err) {\n                    if (!err) {\n                        cb(err);\n                    }\n                    else {\n                        cb(null, doc);\n                    }\n                });\n            }\n        } else {\n            cb(err);\n        }\n    });\n};\n\nMongooseAdapter.prototype.update = function (model, filter, update, options, callback) {\n    if ('function' === typeof options) {\n        callback = options;\n        options = null;\n    } else if ('function' === typeof doc) {\n        callback = update;\n        update = filter;\n        filter = {};\n        options = null;\n    }\n    if (!options) {\n        options = {\n            multi: true\n        };\n    }\n    if (!filter) {\n        filter = {};\n    }\n    update = {\n        $set: update\n    };\n    this._models[model].update(filter, update, options, callback);\n};\n\nMongooseAdapter.prototype.disconnect = function () {\n    this.client.connection.close();\n};\n\nfunction merge(base, update) {\n    Object.keys(update).forEach(function (key) {\n        base[key] = update[key];\n    });\n    return base;\n}","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/mysql.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar util = require('util');\nvar safeRequire = utils.safeRequire;\nvar mysql = safeRequire('mysql');\nvar BaseSQL = require('../sql');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    'use strict';\n    if (!mysql) {\n        return;\n    }\n    var s = schema.settings;\n    var conSettings = {\n        host: s.host || 'localhost',\n        port: s.port || 3306,\n        user: s.username || process.env.USER,\n        password: s.password,\n        debug: s.debug\n    };\n    var dbName = s.database || process.env.USER;\n    conSettings.database = dbName;\n    conSettings.acquireTimeout = s.acquireTimeout || 10000;\n\n    if (s.pool) {\n\n        conSettings.connectionLimit = s.connectionLimit || 10;\n        conSettings.queueLimit = s.queueLimit || 0;\n        conSettings.waitForConnections = s.waitForConnections || true;\n\n        schema.client = mysql.createPool(conSettings);\n        schema.client.getConnection(function (err, connection) {\n            if (err) {\n                throw new Error(err);\n            }\n        });\n        schema.adapter = new MySQL(schema.client, conSettings);\n        schema.adapter.schema = schema;\n        schema.client.once('connection', function (connection) {\n            if (s.autoReconnect) {\n                setInterval(function () {\n                    schema.client.query('SELECT 1+1', function (err, data) {\n                        //\n                    });\n                }, conSettings.acquireTimeout);\n            }\n            startAdapter(schema, dbName, callback);\n        });\n    } else {\n        schema.client = mysql.createConnection(conSettings);\n        schema.adapter = new MySQL(schema.client, conSettings);\n        schema.adapter.schema = schema;\n        if (s.autoReconnect) {\n            setInterval(function () {\n                schema.client.query('SELECT 1+1', function (err, data) {\n                    //\n                });\n            }, conSettings.acquireTimeout);\n        }\n        startAdapter(schema, dbName, callback);\n    }\n\n    function handleDisconnect(client) {\n        schema.client.on('error', function (error) {\n            if (error.code !== 'PROTOCOL_CONNECTION_LOST') throw error;\n            console.log(\"> Re-connecting lost MySQL connection: \" + error.stack);\n            if (s.pool) {\n                schema.client = mysql.createPool(conSettings);\n                schema.client.getConnection(function (err, connection) {\n                    if (err) {\n                        throw new Error(err);\n                    }\n                });\n                schema.adapter = new MySQL(schema.client, conSettings);\n                schema.adapter.schema = schema;\n                schema.client.once('connection', function (connection) {\n                    startAdapter(schema, dbName, callback);\n                });\n                handleDisconnect(schema.client);\n            } else {\n                schema.client = mysql.createConnection(conSettings);\n                schema.adapter = new MySQL(schema.client, conSettings);\n                schema.adapter.schema = schema;\n                startAdapter(schema, dbName, callback);\n                handleDisconnect(schema.client);\n            }\n        });\n    }\n\n    handleDisconnect(schema.client);\n};\n\nfunction startAdapter(schema, dbName, callback) {\n    'use strict';\n    schema.client.query('USE `' + dbName + '`', function (err) {\n        if (err && err.message.match(/unknown database/i)) {\n            schema.client.query('CREATE DATABASE ' + dbName, function (error) {\n                if (!error) {\n                    schema.client.query('USE ' + dbName, callback);\n                } else {\n                    throw error;\n                }\n            });\n        } else {\n            callback();\n        }\n    });\n}\n\n/**\n * MySQL adapter\n * @param {Object} client\n * @param {Object} conSettings\n */\nfunction MySQL(client, conSettings) {\n    'use strict';\n    this.name = 'mysql';\n    this._models = {};\n    this.log = console.log;\n    this.client = client;\n    this.settings = conSettings;\n}\n\nutil.inherits(MySQL, BaseSQL);\n\nMySQL.prototype.query = function (sql, callback) {\n    'use strict';\n    var self = this;\n    var client = self.client;\n    var log = self.log || console.log;\n    if (typeof callback !== 'function') {\n        throw new Error('callback should be a function');\n    }\n    client.query(sql, function (err, data) {\n        if (log) {\n            // log(new Date().toISOString(), '###', sql, err);\n        }\n        if (err && err.message.match(/unknown database/i)) {\n            var dbName = err.message.match(/unknown database '(.*?)'/i)[1];\n            client.query('CREATE DATABASE ' + dbName, function (error) {\n                if (!error) {\n                    client.query(sql, callback);\n                } else {\n                    callback(err);\n                }\n            });\n        } else if (err && (err.message.match(/No\\s+database\\s+selected/gi) || parseInt(err.errno) === 1046)) {\n            client.query('USE `' + self.schema.settings.database + '`', function (error) {\n                if (!error) {\n                    client.query(sql, callback);\n                } else {\n                    callback(error);\n                }\n            });\n        } else {\n            return callback(err, data);\n        }\n    });\n};\n\n/**\n * Start transaction callback(err, id)\n * @param {Object} params\n * @param {Function} callback\n */\nMySQL.prototype.begin = function (params, callback) {\n    'use strict';\n    if ('function' === typeof params) {\n        callback = params;\n        params = null;\n    }\n    this.query('START TRANSACTION', callback);\n};\n\n/**\n * Commit transaction callback(err, id)\n * @param {Object} params\n * @param {Function} callback\n */\nMySQL.prototype.commit = function (params, callback) {\n    'use strict';\n    if ('function' === typeof params) {\n        callback = params;\n        params = null;\n    }\n    this.query('COMMIT', callback);\n};\n\n/**\n * Rollback transaction callback(err, id)\n * @param {Object} params\n * @param {Function} callback\n */\nMySQL.prototype.rollback = function (params, callback) {\n    'use strict';\n    if ('function' === typeof params) {\n        callback = params;\n        params = null;\n    }\n    this.query('ROLLBACK', callback);\n};\n\n/**\n * Create multi column index callback(err, id)\n * @param {String} model\n * @param {Object} fields\n * @param {Object} params\n * @param {Function} callback\n */\nMySQL.prototype.ensureIndex = function (model, fields, params, callback) {\n    'use strict';\n    var self = this, sql = \"\", keyName = params.name || null, afld = [], kind = \"\";\n    Object.keys(fields).forEach(function (field) {\n        if (!keyName) {\n            keyName = \"idx_\" + field;\n        }\n        afld.push('`' + field + '`');\n    });\n    if (params.unique) {\n        kind = \"UNIQUE\";\n    }\n    // CREATE INDEX IF NOT EXISTS xi ON xx5 (x);\n    sql += 'CREATE INDEX IF NOT EXISTS ' + kind + ' INDEX `' + keyName + '` ON  `' + model + '` (' + afld.join(', ') + ');';\n    self.query(sql, callback);\n};\n\n/**\n * Create index callback(err, index)\n * @param {Object} model\n * @param {Object} fields\n * @param {Object} params\n * @param {Function} callback\n */\nMySQL.prototype.createIndexes = function (model, props, done) {\n    'use strict';\n    var self = this, sql = [], m = props;\n    for (var prop in m.properties) {\n        if ('undefined' !== typeof m.properties[prop]['index']\n            || 'undefined' !== typeof m.properties[prop]['unique']) {\n            var UNIQ = 'undefined' !== typeof m.properties[prop]['unique'] ? ' UNIQUE ' : '';\n            sql.push(' ADD ' + UNIQ + ' INDEX `' + prop + '` (`' + prop + '`)');\n        }\n    }\n\n    if (sql.length) {\n        self.command('ALTER TABLE ' + self.tableEscaped(model) + sql.join(',\\n') + ';', done);\n    } else {\n        done();\n    }\n};\n/**\n * Must invoke callback(err, id)\n * @param {Object} model\n * @param {Object} data\n * @param {Function} callback\n */\nMySQL.prototype.create = function (model, data, callback) {\n    'use strict';\n    var fields = this.toFields(model, data);\n    var sql = 'INSERT INTO ' + this.tableEscaped(model);\n\n    if (fields) {\n        sql += ' SET ' + fields;\n    } else {\n        sql += ' VALUES ()';\n    }\n\n    this.query(sql, function (err, info) {\n        callback(err, info && info.insertId);\n    });\n};\n\n/**\n * Update rows\n * @param {String} model\n * @param {Object} filter\n * @param {Object} data\n * @param {Function} callback\n */\nMySQL.prototype.update = function (model, filter, data, callback) {\n    'use strict';\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parametrs undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parametrs undefined\"), null);\n    }\n    filter = filter.where ? filter.where : filter;\n    var self = this;\n    var combined = [];\n    var props = self._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key] || key === 'id') {\n            var k = '`' + key + '`';\n            var v;\n            if (key !== 'id') {\n                v = self.toDatabase(props[key], data[key]);\n            } else {\n                v = data[key];\n            }\n            combined.push(k + ' = ' + v);\n        }\n    });\n    var sql = 'UPDATE ' + this.tableEscaped(model);\n    sql += ' SET ' + combined.join(', ');\n    sql += ' ' + self.buildWhere(filter, self, model);\n\n    this.query(sql, function (err, affected) {\n        callback(err, ((affected || {}).affectedRows || affected));\n    });\n};\n\nMySQL.prototype.toFields = function (model, data) {\n    'use strict';\n    var fields = [];\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key]) {\n            fields.push('`' + key.replace(/\\./g, '`.`') + '` = ' + this.toDatabase(props[key], data[key]));\n        }\n    }.bind(this));\n    return fields.join(',');\n};\n\nfunction dateToMysql(val) {\n    'use strict';\n    return val.getUTCFullYear() + '-' +\n        fillZeros(val.getUTCMonth() + 1) + '-' +\n        fillZeros(val.getUTCDate()) + ' ' +\n        fillZeros(val.getUTCHours()) + ':' +\n        fillZeros(val.getUTCMinutes()) + ':' +\n        fillZeros(val.getUTCSeconds());\n\n    function fillZeros(v) {\n        'use strict';\n        return v < 10 ? '0' + v : v;\n    }\n}\n\nMySQL.prototype.toDatabase = function (prop, val) {\n    'use strict';\n    if (val === null) {\n        return 'NULL';\n    }\n    if (val.constructor.name === 'Object') {\n        var operator = Object.keys(val)[0];\n        val = val[operator];\n        if (operator === 'between') {\n            if (prop.type.name === 'Date') {\n                return 'STR_TO_DATE(' + this.toDatabase(prop, val[0]) + ', \"%Y-%m-%d %H:%i:%s\")' +\n                    ' AND STR_TO_DATE(' +\n                    this.toDatabase(prop, val[1]) + ', \"%Y-%m-%d %H:%i:%s\")';\n            } else {\n                return this.toDatabase(prop, val[0]) +\n                    ' AND ' +\n                    this.toDatabase(prop, val[1]);\n            }\n        } else if (operator === 'in' || operator === 'inq' || operator === 'nin') {\n            if (!(val.propertyIsEnumerable('length')) && typeof val === 'object' && typeof val.length === 'number') { //if value is array\n                for (var i = 0; i < val.length; i++) {\n                    if (/^\"(?:\\\\\"|.)*?\"$/gi.test(val[i]) || /^'(?:\\\\'|.)*?'$/gi.test(val[i])) {\n                        val[i] = val[i];\n                    } else {\n                        val[i] = this.client.escape(val[i]);\n                    }\n                }\n                return val.join(',');\n            } else {\n                return val;\n            }\n        }\n    }\n    if (!prop) {\n        return val;\n    }\n    if (prop.type.name === 'Number') {\n        return val;\n    }\n    if (prop.type.name === 'Date') {\n        if (!val) {\n            return 'NULL';\n        }\n        if (typeof val === 'string') {\n            val = val.split('.')[0].replace('T', ' ');\n            val = Date.parse(val);\n        }\n        if (typeof val === 'number') {\n            val = new Date(val);\n        }\n        if (val instanceof Date) {\n            val = '\"' + dateToMysql(val) + '\"';\n        }\n        return val;\n    }\n    if (prop.type.name === \"Boolean\") {\n        return val ? 1 : 0;\n    }\n    return /^\"(?:\\\\\"|.)*?\"$/gi.test(val) || /^'(?:\\\\'|.)*?'$/gi.test(val) ? val : this.client.escape(val);\n};\n\nMySQL.prototype.fromDatabase = function (model, data) {\n    'use strict';\n    if (!data) {\n        return null;\n    }\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        var val = data[key];\n        if (props[key]) {\n            if (props[key].type.name === 'Date' && val !== null) {\n                val = new Date(val.toString().replace(/GMT.*$/, 'GMT'));\n            }\n            if ((props[key].type.name || '').toString().toLowerCase() === 'json' && typeof val == \"string\") {\n                try {\n                    val = JSON.parse(val);\n                } catch (err) {\n\n                }\n            }\n        }\n        data[key] = val;\n    });\n    return data;\n};\n\nMySQL.prototype.escapeName = function (name) {\n    'use strict';\n    return '`' + name.replace(/\\./g, '`.`') + '`';\n};\n\nMySQL.prototype.all = function all(model, filter, callback) {\n    'use strict';\n    var self = this, sFields = '*';\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n\n    var sql = 'SELECT ' + sFields + ' FROM ' + self.tableEscaped(model);\n\n    if (filter) {\n\n        if (filter.fields) {\n            if (typeof filter.fields === 'string') {\n                sFields = self.tableEscaped(filter.fields);\n            } else if (Object.prototype.toString.call(filter.fields) === '[object Array]') {\n                sFields = filter.fields.map(function (field) {\n                    return '`' + field + '`';\n                }).join(', ');\n            }\n            sql = sql.replace('*', sFields);\n        }\n\n        if (filter.where) {\n            sql += ' ' + self.buildWhere(filter.where, self, model);\n        }\n\n        if (filter.order) {\n            sql += ' ' + self.buildOrderBy(filter.order);\n        }\n\n        if (filter.group) {\n            sql += ' ' + self.buildGroupBy(filter.group);\n        }\n\n        if (filter.limit) {\n            sql += ' ' + self.buildLimit(filter.limit, filter.offset || filter.skip || 0);\n        }\n\n    }\n\n    this.query(sql, function (err, data) {\n        if (err) {\n            return callback(err, []);\n        }\n        callback(null, data.map(function (obj) {\n            return self.fromDatabase(model, obj);\n        }));\n    }.bind(this));\n\n    return sql;\n};\n\n/**\n * Update existing database tables.\n * @param {Function} cb\n */\nMySQL.prototype.autoupdate = function (cb) {\n    'use strict';\n    var self = this;\n    var wait = 0;\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.query('SHOW FIELDS FROM ' + self.tableEscaped(model), function (err, fields) {\n            self.query('SHOW INDEXES FROM ' + self.tableEscaped(model), function (err, indexes) {\n                if (!err && fields.length) {\n                    self.alterTable(model, fields, indexes, done);\n                } else {\n                    self.createTable(model, indexes, done);\n                }\n            });\n        });\n    });\n\n    function done(err) {\n        if (err) {\n            console.log(err);\n        }\n        if (--wait === 0 && cb) {\n            cb();\n        }\n    }\n};\n\n/**\n * Check whether migrations needed\n * This method make sense only for sql adapters.\n * @param {Function} cb\n */\nMySQL.prototype.isActual = function (cb) {\n    'use strict';\n    var ok = false;\n    var self = this;\n    var wait = 0;\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.query('SHOW FIELDS FROM ' + model, function (err, fields) {\n            self.query('SHOW INDEXES FROM ' + model, function (err, indexes) {\n                self.alterTable(model, fields, indexes, done, true);\n            });\n        });\n    });\n\n    function done(err, needAlter) {\n        if (err) {\n            console.log(err);\n        }\n        ok = ok || needAlter;\n        if (--wait === 0 && cb) {\n            cb(null, !ok);\n        }\n    }\n};\n\nMySQL.prototype.alterTable = function (model, actualFields, actualIndexes, done, checkOnly) {\n    'use strict';\n    var self = this;\n    var m = this._models[model];\n    var propNames = Object.keys(m.properties).filter(function (name) {\n        return !!m.properties[name];\n    });\n    var indexNames = m.settings.indexes ? Object.keys(m.settings.indexes).filter(function (name) {\n            return !!m.settings.indexes[name];\n        }) : [];\n    var sql = [];\n    var ai = {};\n    if (actualIndexes) {\n        actualIndexes.forEach(function (i) {\n            var name = i.Key_name;\n            if (!ai[name]) {\n                ai[name] = {\n                    info: i,\n                    columns: []\n                };\n            }\n            ai[name].columns[i.Seq_in_index - 1] = i.Column_name;\n        });\n    }\n    var aiNames = Object.keys(ai);\n    // change/add new fields\n    propNames.forEach(function (propName) {\n        if (propName === 'id') {\n            return;\n        }\n        var found;\n        actualFields.forEach(function (f) {\n            if (f.Field === propName) {\n                found = f;\n            }\n        });\n\n        if (found) {\n            actualize(propName, found);\n        } else {\n            sql.push('ADD COLUMN `' + propName + '` ' + self.propertySettingsSQL(model, propName));\n        }\n    });\n\n    // drop columns\n    actualFields.forEach(function (f) {\n        var notFound = !~propNames.indexOf(f.Field);\n        if (f.Field === 'id') {\n            return;\n        }\n        if (notFound || !m.properties[f.Field]) {\n            sql.push('DROP COLUMN `' + f.Field + '` ');\n        }\n    });\n\n    // remove indexes\n    aiNames.forEach(function (indexName) {\n        if (indexName === 'id' || indexName === 'PRIMARY') {\n            return;\n        }\n        if ((indexNames.indexOf(indexName) === -1 && !m.properties[indexName])\n            || ((m.properties[indexName] && !m.properties[indexName].index)\n            && (m.properties[indexName] && !m.properties[indexName].unique))) {\n            sql.push('DROP INDEX `' + indexName + '`');\n        } else {\n            // first: check single (only type and kind)\n            if (m.properties[indexName] && (!m.properties[indexName].index || !m.properties[indexName].unique)) {\n                // TODO\n                return;\n            }\n            // second: check multiple indexes\n            var orderMatched = true;\n            if (indexNames.indexOf(indexName) !== -1) {\n                m.settings.indexes[indexName].columns.split(/,\\s*/).forEach(function (columnName, i) {\n                    if (ai[indexName].columns[i] !== columnName)\n                        orderMatched = false;\n                });\n            }\n            if (!orderMatched) {\n                sql.push('DROP INDEX `' + indexName + '`');\n                delete ai[indexName];\n            }\n        }\n    });\n\n    // add single-column indexes\n    propNames.forEach(function (propName) {\n        var i = m.properties[propName].index || m.properties[propName].unique;\n        if (!i) {\n            return;\n        }\n        var found = ai[propName] && ai[propName].info;\n        if (!found) {\n            var prop = m.properties[propName];\n            var type = '';\n            var kind = '';\n            if (i.type) {\n                type = 'USING ' + i.type;\n            }\n            if (i.kind || prop.unique) {\n                kind = i.kind ? i.kind : 'UNIQUE';\n            }\n            if (kind && type) {\n                sql.push('ADD ' + kind + ' INDEX `' + propName + '` (`' + propName + '`) ' + type);\n            } else {\n                sql.push('ADD ' + kind + ' INDEX `' + propName + '` ' + type + ' (`' + propName + '`) ');\n            }\n            ai[propName] = {\n                info: true\n            };\n        }\n    });\n\n    // add multi-column indexes\n    indexNames.forEach(function (indexName) {\n        var i = m.settings.indexes[indexName];\n        var found = ai[indexName] && ai[indexName].info;\n        if (!found) {\n            var type = '';\n            var kind = '';\n            if (i.type) {\n                type = 'USING ' + i.kind;\n            }\n            if (i.kind) {\n                kind = i.kind;\n            }\n            var columns = i.columns.split(',').map(function (c) {\n                return '`' + c.replace(/^\\s+|\\s+$/, '') + \"`\";\n            }).join(',');\n            if (kind && type) {\n                sql.push('ADD ' + kind + ' INDEX `' + indexName + '` (' + columns + ') ' + type);\n            } else {\n                sql.push('ADD ' + kind + ' INDEX ' + type + ' `' + indexName + '` (' + columns + ')');\n            }\n        }\n    });\n\n    if (sql.length) {\n        var query = 'ALTER TABLE ' + self.tableEscaped(model) + ' \\n' + sql.join(',\\n');\n        if (checkOnly) {\n            done(null, true, {\n                statements: sql,\n                query: query\n            });\n        } else {\n            this.query(query, done);\n        }\n    } else {\n        done();\n    }\n\n    function actualize(propName, oldSettings) {\n        'use strict';\n        var newSettings = m.properties[propName];\n        if (newSettings && changed(newSettings, oldSettings)) {\n            sql.push('CHANGE COLUMN `' + propName + '` `' + propName + '` ' + self.propertySettingsSQL(model, propName));\n        }\n    }\n\n    function changed(newSettings, oldSettings) {\n        'use strict';\n        if (oldSettings.Null === 'YES' && (newSettings.allowNull === false || newSettings.null === false)) {\n            return true;\n        }\n        if (oldSettings.Null === 'NO' && (getDefaultValue(newSettings) !== getDefaultValue(oldSettings))) {\n            return true;\n        }\n        if (oldSettings.Type.toUpperCase() !== datatype(newSettings)) {\n            return true;\n        }\n        return false;\n    }\n};\n\nMySQL.prototype.propertiesSQL = function (model) {\n    'use strict';\n    var self = this;\n    var sql = [];\n    var primaryKeys = this._models[model].settings.primaryKeys || [];\n    var foreignKeys = this._models[model].settings.foreignKeys || [];\n\n    primaryKeys = primaryKeys.slice(0);\n    foreignKeys = foreignKeys.slice(0);\n\n    Object.keys(this._models[model].properties).forEach(function (prop) {\n        if (prop === 'id') {\n            return;\n        }\n        return sql.push('`' + prop + '` ' + self.propertySettingsSQL(model, prop));\n    });\n\n    if (primaryKeys.length) {\n        for (var i = 0, length = primaryKeys.length; i < length; i++) {\n            primaryKeys[i] = \"`\" + primaryKeys[i].toString().replace(/,\\s+|,/, '`,`') + \"`\";\n        }\n        sql.push(\"PRIMARY KEY (\" + primaryKeys.join(', ') + \")\");\n    } else {\n        sql.push('`id` INT(11) NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY');\n    }\n\n    if (foreignKeys.length) {\n        for (var i = 0, length = foreignKeys.length; i < length; i++) {\n            var foreignKey = foreignKeys[i];\n            var str = \"FOREIGN KEY (`\" + foreignKeys[i].localCol + \"`) REFERENCES \" + foreignKey.foreignTable + \"(`\" + foreignKey.foreignCol + \"`)\";\n\n            if (foreignKey.onDelete) {\n                str += \" ON DELETE CASCADE\";\n            }\n\n            if (foreignKey.onUpdate) {\n                str += \" ON UPDATE CASCADE\";\n            }\n            sql.push(str);\n        }\n    }\n\n    return sql.join(',\\n  ');\n};\n\nMySQL.prototype.propertySettingsSQL = function (model, prop) {\n    'use strict';\n    var p = this._models[model].properties[prop], field = [];\n\n    field.push(datatype(p));\n    field.push(p.allowNull === false || (typeof p['default'] !== 'undefined' && acceptedDefaults(p)) ? 'NOT NULL' : 'NULL');\n    if (typeof p['default'] !== 'undefined' && acceptedDefaults(p) && typeof p['default'] !== 'function') {\n        field.push('DEFAULT ' + getDefaultValue(p));\n    }\n    if (p.unique === true) {\n        field.push('UNIQUE');\n    }\n\n    return field.join(\" \");\n};\n\nfunction datatype(p) {\n    'use strict';\n    var dt = '';\n    switch ((p.type.name || 'string').toLowerCase()) {\n        case 'json':\n        case 'text':\n            dt = 'TEXT';\n            break;\n        case 'int':\n        case 'integer':\n        case 'number':\n            var ftype = (parseFloat(p.limit) > 11) ? \"BIGINT\" : \"INT\";\n            dt = ftype + '(' + (p.limit || 11) + ')';\n            break;\n        case 'float':\n        case 'double':\n            dt = 'FLOAT';\n        case 'real':\n            dt = 'REAL';\n            break;\n        case 'timestamp':\n        case 'date':\n            dt = 'DATETIME';\n            break;\n        case 'boolean':\n        case 'bool':\n            dt = 'TINYINT(' + (p.limit || 1) + ')';\n            break;\n        default:\n            dt = 'VARCHAR(' + (p.limit || 255) + ')';\n    }\n    return dt;\n}\n\nMySQL.prototype.buildWhere = function buildWhere(conds, adapter, model) {\n    'use strict';\n    var cs = [], or = [],\n        self = adapter,\n        props = self._models[model].properties;\n\n    Object.keys(conds).forEach(function (key) {\n        if (key !== 'or') {\n            cs = parseCond(cs, key, props, conds, self);\n        } else {\n            conds[key].forEach(function (oconds) {\n                Object.keys(oconds).forEach(function (okey) {\n                    or = parseCond(or, okey, props, oconds, self);\n                });\n            });\n        }\n    });\n\n    if (cs.length === 0 && or.length === 0) {\n        return '';\n    }\n    var orop = \"\";\n    if (or.length) {\n        orop = ' (' + or.join(' OR ') + ') ';\n    }\n    orop += (orop !== \"\" && cs.length > 0) ? ' AND ' : '';\n    return 'WHERE ' + orop + cs.join(' AND ');\n};\n\nfunction parseCond(cs, key, props, conds, self) {\n    'use strict';\n    var keyEscaped = '`' + key.replace(/\\./g, '`.`') + '`';\n    var val = self.toDatabase(props[key], conds[key]);\n    if (conds[key] === null) {\n        cs.push(keyEscaped + ' IS NULL');\n    } else if (conds[key].constructor.name === 'Object') {\n        Object.keys(conds[key]).forEach(function (condType) {\n            val = self.toDatabase(props[key], conds[key][condType]);\n            var sqlCond = keyEscaped;\n            if ((condType === 'inq' || condType === 'nin') && val.length === 0) {\n                cs.push(condType === 'inq' ? 0 : 1);\n                return true;\n            }\n            switch (condType) {\n                case 'gt':\n                    sqlCond += ' > ';\n                    break;\n                case 'gte':\n                    sqlCond += ' >= ';\n                    break;\n                case 'lt':\n                    sqlCond += ' < ';\n                    break;\n                case 'lte':\n                    sqlCond += ' <= ';\n                    break;\n                case 'between':\n                    sqlCond += ' BETWEEN ';\n                    break;\n                case 'inq':\n                case 'in':\n                    sqlCond += ' IN ';\n                    break;\n                case 'nin':\n                    sqlCond += ' NOT IN ';\n                    break;\n                case 'neq':\n                case 'ne':\n                    sqlCond += ' != ';\n                    break;\n                case 'regex':\n                    sqlCond += ' REGEXP ';\n                    break;\n                case 'like':\n                    sqlCond += ' LIKE ';\n                    break;\n                case 'nlike':\n                    sqlCond += ' NOT LIKE ';\n                    break;\n                default:\n                    sqlCond += ' ' + condType + ' ';\n                    break;\n            }\n            if (condType === 'between') {\n                sqlCond += val[0] + ' AND ' + val[1];\n            } else if (condType === 'in' || condType === 'inq' || condType === 'nin') {\n                sqlCond += \"(\" + val + \")\";\n            } else {\n                sqlCond += val;\n            }\n            cs.push(sqlCond);\n        });\n\n    } else if (/^\\//gi.test(conds[key])) {\n        var reg = val.toString().split('/');\n        cs.push(keyEscaped + ' REGEXP \"' + reg[1] + '\"');\n    } else {\n        cs.push(keyEscaped + ' = ' + val);\n    }\n    return cs;\n}\n\nMySQL.prototype.buildOrderBy = function buildOrderBy(order) {\n    'use strict';\n    if (typeof order === 'string') {\n        order = [order];\n    }\n    return 'ORDER BY ' + order.join(', ');\n};\n\nMySQL.prototype.buildLimit = function buildLimit(limit, offset) {\n    'use strict';\n    return 'LIMIT ' + (offset ? (offset + ', ' + limit) : limit);\n};\n\nMySQL.prototype.buildGroupBy = function buildGroupBy(group) {\n    'use strict';\n    if (typeof group === 'string') {\n        group = [group];\n    }\n    return 'GROUP BY ' + group.join(', ');\n};\n\nfunction acceptedDefaults(prop) {\n    'use strict';\n    if (/^INT|^BIGINT|^VAR|^TINY/i.test(datatype(prop))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction getDefaultValue(prop) {\n    'use strict';\n    if (/^INT|^BIGINT/i.test(prop.Type || datatype(prop))) {\n        return parseInt(prop['default'] || prop['Default'] || 0);\n    } else if (/^TINY/i.test(prop.Type || datatype(prop))) {\n        return prop['default'] || prop['Default'] ? 1 : 0;\n    } else {\n        return \"'\" + (prop['default'] || prop['Default'] || '') + \"'\";\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/nano.js":"/**\r\n * Module dependencies\r\n */\r\nvar url = require('url');\r\nvar utils = require('../utils');\r\nvar safeRequire = utils.safeRequire;\r\nvar helpers = utils.helpers;\r\nvar nano = safeRequire('nano');\r\nvar NanoAdapter;\r\n\r\nexports.initialize = function (schema, callback) {\r\n    var db, server, opts, srvuri, database;\r\n    opts = schema.settings || {};\r\n\r\n    if (!opts.url) {\r\n        var host = opts.host || 'localhost';\r\n        var port = opts.port || '5984';\r\n        var proto = opts.ssl ? 'https' : 'http';\r\n        database = opts.database || 'test';\r\n        opts.url = proto + '://' + host + ':' + port + '/' + database;\r\n        srvuri = proto + '://' + host + ':' + port;\r\n    } else {\r\n        var parsed_url = url.parse(opts.url);\r\n        database = (parsed_url.path || parsed_url.pathname || '').replace(/\\//g, '');\r\n        srvuri = (opts.url || '').replace(parsed_url.path, '');\r\n    }\r\n    db = nano(opts);\r\n    server = nano(srvuri);\r\n    server.db.create(database, function (err, body) {\r\n        if (!err) {\r\n            console.log('database ' + database + ' created!');\r\n        }\r\n    });\r\n\r\n    schema.adapter = new NanoAdapter(db, callback);\r\n\r\n};\r\n\r\nfunction NanoAdapter(db, callback) {\r\n    this.name = 'nano';\r\n    this.db = db;\r\n    this.all = helpers.__bind(this.all, this);\r\n    this.fromDB = helpers.__bind(this.fromDB, this);\r\n    this.forDB = helpers.__bind(this.forDB, this);\r\n    this.destroyAll = helpers.__bind(this.destroyAll, this);\r\n    this.count = helpers.__bind(this.count, this);\r\n    this.updateAttributes = helpers.__bind(this.updateAttributes, this);\r\n    this.destroy = helpers.__bind(this.destroy, this);\r\n    this.findById = helpers.__bind(this.findById, this);\r\n    this.findOne = helpers.__bind(this.findOne, this);\r\n    this.exists = helpers.__bind(this.exists, this);\r\n    this.updateOrCreate = helpers.__bind(this.updateOrCreate, this);\r\n    this.save = helpers.__bind(this.save, this);\r\n    this.create = helpers.__bind(this.create, this);\r\n    this.remove = helpers.__bind(this.remove, this);\r\n    this.define = helpers.__bind(this.define, this);\r\n    this._models = {};\r\n    process.nextTick(function () {\r\n        callback();\r\n    });\r\n}\r\n\r\nNanoAdapter.prototype.define = function (descr) {\r\n    var m, self = this;\r\n    m = descr.model.modelName;\r\n    descr.properties._rev = {\r\n        type: String\r\n    };\r\n\r\n    var design = {\r\n        views: {\r\n            all: {\r\n                map: 'function (doc) { if (doc.model === \"' + m + '\") { return emit(doc.model, doc); } }'\r\n            }\r\n        },\r\n        updates: {\r\n            modify: \"function (doc, req) { var fields = JSON.parse(req.body); for (var i in fields) { doc[i] = fields[i]; } return [doc, toJSON(doc)];}\"\r\n        }\r\n    };// var resp = eval(uneval(doc)); \r\n    return self.db.insert(design, '_design/caminte_' + m, function (err, doc) {\r\n        return self._models[m] = descr;\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.create = function (model, data, callback) {\r\n    var _this = this;\r\n    data.model = model;\r\n    helpers.savePrep(data);\r\n    return this.db.insert(this.forDB(model, data), function (err, doc) {\r\n        if (err) {\r\n            doc = data;\r\n            console.log('###    error create:', err.message, doc.id || doc._id, doc._rev)\r\n        }\r\n        return callback(err, doc.id, doc.rev);\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.save = function (model, data, callback) {\r\n    var _this = this, id;\r\n    data.model = model;\r\n    helpers.savePrep(data);\r\n    var item = this.forDB(model, data);\r\n    id = item._id;\r\n    item.up = Date.now();\r\n    return this.db.insert(item, id, function (err, doc) {\r\n        // return this.db.atomic(\"caminte_\" + model, \"modify\", id, item, function (err, doc) {\r\n        if (err && err.statusCode != 409) {\r\n            console.log('###             error save:', err)\r\n        } else if (err && err.statusCode == 409) {\r\n            doc = item;\r\n            err = null;\r\n        }\r\n        return callback(err, doc.id, doc.rev);\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.updateOrCreate = function (model, data, callback) {\r\n    var _this = this;\r\n    return this.exists(model, data.id, function (err, exists) {\r\n        if (exists) {\r\n            return _this.save(model, data, callback);\r\n        } else {\r\n            return _this.create(model, data, function (err, id) {\r\n                data.id = id;\r\n                return callback(err, data);\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.exists = function (model, id, callback) {\r\n    return this.db.head(id, function (err, _, headers) {\r\n        if (err) {\r\n            return callback(null, false);\r\n        }\r\n        return callback(null, headers !== null);\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.findById = function (model, id, callback) {\r\n    var _this = this;\r\n    return this.db.get(id, function (err, doc) {\r\n        return callback(err, _this.fromDB(model, doc));\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.destroy = function (model, id, callback) {\r\n    var _this = this;\r\n    return this.db.get(id, function (err, doc) {\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n        return _this.db.destroy(id, doc._rev, function (err, doc) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n            callback.removed = true;\r\n            return callback();\r\n        });\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.updateAttributes = function (model, id, data, callback) {\r\n    var _this = this;\r\n    return this.db.get(id, function (err, base) {\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n        return _this.save(model, helpers.merge(base, data), callback);\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.count = function (model, callback, where) {\r\n    var _this = this;\r\n    return _this.all(model, {\r\n        where: where\r\n    }, function (err, docs) {\r\n        return callback(err, docs.length);\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.destroyAll = function (model, callback) {\r\n    var _this = this;\r\n    return _this.all(model, {}, function (err, docs) {\r\n        var doc;\r\n        docs = (function () {\r\n            var _i, _len, _results;\r\n            _results = [];\r\n            for (_i = 0, _len = docs.length; _i < _len; _i++) {\r\n                doc = docs[_i];\r\n                _results.push({\r\n                    _id: doc.id,\r\n                    _rev: doc._rev,\r\n                    _deleted: true\r\n                });\r\n            }\r\n            return _results;\r\n        })();\r\n        return _this.db.bulk({\r\n            docs: docs\r\n        }, function (err, body) {\r\n            return callback(err, body);\r\n        });\r\n    });\r\n};\r\n\r\nNanoAdapter.prototype.forDB = function (model, data) {\r\n    var k, props, v;\r\n    if (data === null) {\r\n        data = {};\r\n    }\r\n    props = this._models[model].properties;\r\n    for (k in props) {\r\n        v = props[k];\r\n        if (data[k] && v.type.name === 'Date'\r\n            && (data[k].getTime !== null)\r\n            && (typeof data[k].getTime === 'function')) {\r\n            data[k] = data[k].getTime();\r\n        }\r\n    }\r\n    for (f in data) {\r\n        if (typeof data[f] === 'function') {\r\n            delete data[f];\r\n        }\r\n    }\r\n    return data;\r\n};\r\n\r\nNanoAdapter.prototype.fromDB = function (model, data) {\r\n    var date, k, props, v;\r\n    if (!data) {\r\n        return data;\r\n    }\r\n    props = this._models[model].properties;\r\n    for (k in props) {\r\n        v = props[k];\r\n        if ((data[k] !== null) && props[k].type.name === 'Date') {\r\n            date = new Date(data[k]);\r\n            date.setTime(data[k]);\r\n            data[k] = date;\r\n        }\r\n    }\r\n    return data;\r\n};\r\n\r\nNanoAdapter.prototype.remove = function (model, filter, callback) {\r\n    var _this = this;\r\n    return _this.all(model, filter, function (err, docs) {\r\n        var doc;\r\n        docs = (function () {\r\n            var _i, _len, _results;\r\n            _results = [];\r\n            for (_i = 0, _len = docs.length; _i < _len; _i++) {\r\n                doc = docs[_i];\r\n                _results.push({\r\n                    _id: doc.id,\r\n                    _rev: doc._rev,\r\n                    _deleted: true\r\n                });\r\n            }\r\n            return _results;\r\n        })();\r\n        return _this.db.bulk({\r\n            docs: docs\r\n        }, function (err, body) {\r\n            return callback(err, body);\r\n        });\r\n    });\r\n};\r\n\r\n\r\nNanoAdapter.prototype.all = function (model, filter, callback) {\r\n    if ('function' === typeof filter) {\r\n        callback = filter;\r\n        filter = {};\r\n    }\r\n    if (!filter) {\r\n        filter = {};\r\n    }\r\n    var _this = this;\r\n    var vopts = {\r\n        include_docs: true\r\n    };\r\n\r\n    return this.db.view('caminte_' + model, 'all', vopts, function (err, body) {\r\n        var doc, docs, i, k, key, orders, row, sorting, v, where, _i, _len;\r\n        if (err) console.log(err)\r\n        docs = (function () {\r\n            var _i, _len, _ref, _results;\r\n            _ref = body.rows;\r\n            _results = [];\r\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\r\n                row = _ref[_i];\r\n                row.doc = row.value;\r\n                row.doc.id = row.doc._id;\r\n                delete row.doc._id;\r\n                _results.push(row.doc);\r\n            }\r\n            return _results;\r\n        })();\r\n\r\n        where = filter !== null ? filter.where : void 0;\r\n        if (where) {\r\n            docs = docs ? docs.filter(helpers.applyFilter(filter)) : docs;\r\n        }\r\n\r\n        orders = filter !== null ? filter.order : void 0;\r\n        if (orders) {\r\n            if (typeof orders === 'string') {\r\n                orders = [orders];\r\n            }\r\n            sorting = function (a, b) {\r\n                var ak, bk, i, item, rev, _i, _len;\r\n                for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {\r\n                    item = this[i];\r\n                    ak = a[this[i].key];\r\n                    bk = b[this[i].key];\r\n                    rev = this[i].reverse;\r\n                    if (ak > bk) {\r\n                        return 1 * rev;\r\n                    }\r\n                    if (ak < bk) {\r\n                        return -1 * rev;\r\n                    }\r\n                }\r\n                return 0;\r\n            };\r\n            for (i = _i = 0, _len = orders.length; _i < _len; i = ++_i) {\r\n                key = orders[i];\r\n                orders[i] = {\r\n                    reverse: helpers.reverse(key),\r\n                    key: helpers.stripOrder(key)\r\n                };\r\n            }\r\n            docs.sort(sorting.bind(orders));\r\n        }\r\n\r\n        return callback(err, (function () {\r\n            var _j, _len1, _results;\r\n            _results = [];\r\n            for (_j = 0, _len1 = docs.length; _j < _len1; _j++) {\r\n                doc = docs[_j];\r\n                _results.push(this.fromDB(model, doc));\r\n            }\r\n            return _results;\r\n        }).call(_this));\r\n    });\r\n};","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/neo4j.js":"/**\r\n * Module dependencies\r\n */\r\nvar utils = require('../utils');\r\nvar safeRequire = utils.safeRequire;\r\nvar neo4j = safeRequire('node-neo4j');\r\n\r\nexports.initialize = function initializeSchema(schema, callback) {\r\n    // 'http://username:password@localhost:7474'\r\n    if (!schema.settings.url) {\r\n        var auth = '';\r\n        var url = schema.settings.host || 'localhost';\r\n        var port = schema.settings.port || 7474;\r\n        url += ':' + port;\r\n\r\n        if (schema.settings.username) {\r\n            auth = schema.settings.username;\r\n            if (schema.settings.password) {\r\n                auth += ':' + schema.settings.password;\r\n            }\r\n        }\r\n        if (auth) {\r\n            url = auth + '@' + url;\r\n        }\r\n        /*\r\n         if (schema.settings.database) {\r\n         url += '/' + schema.settings.database;\r\n         } else {\r\n         url += '/';\r\n         }\r\n         */\r\n        url = 'http://' + url;\r\n        schema.settings.url = url;\r\n    }\r\n\r\n    var client = new neo4j(schema.settings.url);\r\n    schema.adapter = new Neo4j(schema.settings, client);\r\n    schema.adapter.client = client;\r\n    process.nextTick(callback);\r\n};\r\n\r\nfunction Neo4j(s, client) {\r\n    this.name = 'neo4j';\r\n    this._models = {};\r\n    this.client = client;\r\n    this.cache = {};\r\n    this.settings = s;\r\n}\r\n\r\nNeo4j.prototype.define = function defineModel(descr) {\r\n    // this.mixClassMethods(descr.model, descr.properties);\r\n    // this.mixInstanceMethods(descr.model.prototype, descr.properties);\r\n    this._models[descr.model.modelName] = descr;\r\n};\r\n\r\n/**\r\n * Update existing database collections.\r\n * @param {Function} callback\r\n */\r\nNeo4j.prototype.autoupdate = function (callback) {\r\n    return callback && callback();\r\n};\r\n\r\nNeo4j.prototype.createIndexHelper = function (cls, indexName) {\r\n    var db = this.client;\r\n    var method = 'findBy' + indexName[0].toUpperCase() + indexName.substr(1);\r\n    cls[method] = function (value, cb) {\r\n        db.getIndexedNode(cls.modelName, indexName, value, function (err, node) {\r\n            if (err)\r\n                return cb(err);\r\n            if (node) {\r\n                node.data.id = node.id;\r\n                cb(null, new cls(node.data));\r\n            } else {\r\n                cb(null, null);\r\n            }\r\n        });\r\n    };\r\n};\r\n\r\nNeo4j.prototype.mixClassMethods = function mixClassMethods(cls, properties) {\r\n    var neo = this;\r\n\r\n    Object.keys(properties).forEach(function (name) {\r\n        if (properties[name].index) {\r\n            neo.createIndexHelper(cls, name);\r\n        }\r\n    });\r\n\r\n    cls.setupCypherQuery = function (name, queryStr, rowHandler) {\r\n        cls[name] = function cypherQuery(params, cb) {\r\n            if (typeof params === 'function') {\r\n                cb = params;\r\n                params = [];\r\n            } else if (params.constructor.name !== 'Array') {\r\n                params = [params];\r\n            }\r\n\r\n            var i = 0;\r\n            var q = queryStr.replace(/\\?/g, function () {\r\n                return params[i++];\r\n            });\r\n\r\n            neo.client.query(function (err, result) {\r\n                if (err)\r\n                    return cb(err, []);\r\n                cb(null, result.map(rowHandler));\r\n            }, q);\r\n        };\r\n    };\r\n\r\n    /**\r\n     * @param from - id of object to check relation from\r\n     * @param to - id of object to check relation to\r\n     * @param type - type of relation\r\n     * @param direction - all | incoming | outgoing\r\n     * @param cb - callback (err, rel || false)\r\n     */\r\n    cls.relationshipExists = function relationshipExists(from, to, type, direction, cb) {\r\n        neo.node(from, function (err, node) {\r\n            if (err)\r\n                return cb(err);\r\n            node._getRelationships(direction, type, function (err, rels) {\r\n                if (err && cb) {\r\n                    return cb(err);\r\n                }\r\n                if (err && !cb) {\r\n                    throw err;\r\n                }\r\n                var found = false;\r\n                if (rels && rels.forEach) {\r\n                    rels.forEach(function (r) {\r\n                        if (r.start.id === from && r.end.id === to) {\r\n                            found = true;\r\n                        }\r\n                    });\r\n                }\r\n                cb && cb(err, found);\r\n            });\r\n        });\r\n    };\r\n\r\n    cls.createRelationshipTo = function createRelationshipTo(id1, id2, type, data, cb) {\r\n        var fromNode, toNode;\r\n        neo.node(id1, function (err, node) {\r\n            if (err && cb)\r\n                return cb(err);\r\n            if (err && !cb)\r\n                throw err;\r\n            fromNode = node;\r\n            ok();\r\n        });\r\n        neo.node(id2, function (err, node) {\r\n            if (err && cb)\r\n                return cb(err);\r\n            if (err && !cb)\r\n                throw err;\r\n            toNode = node;\r\n            ok();\r\n        });\r\n        function ok() {\r\n            if (fromNode && toNode) {\r\n                fromNode.createRelationshipTo(toNode, type, cleanup(data), cb);\r\n            }\r\n        }\r\n    };\r\n\r\n    cls.createRelationshipFrom = function createRelationshipFrom(id1, id2, type, data, cb) {\r\n        cls.createRelationshipTo(id2, id1, type, data, cb);\r\n    };\r\n\r\n    // only create relationship if it is not exists\r\n    cls.ensureRelationshipTo = function (id1, id2, type, data, cb) {\r\n        cls.relationshipExists(id1, id2, type, 'outgoing', function (err, exists) {\r\n            if (err && cb)\r\n                return cb(err);\r\n            if (err && !cb)\r\n                throw err;\r\n            if (exists)\r\n                return cb && cb(null);\r\n            cls.createRelationshipTo(id1, id2, type, data, cb);\r\n        });\r\n    };\r\n};\r\n\r\nNeo4j.prototype.mixInstanceMethods = function mixInstanceMethods(proto) {\r\n    var neo = this;\r\n    /**\r\n     * @param obj - Object or id of object to check relation with\r\n     * @param type - type of relation\r\n     * @param cb - callback (err, rel || false)\r\n     * @param {mixed} direction\r\n     */\r\n    proto.isInRelationWith = function isInRelationWith(obj, type, direction, cb) {\r\n        this.constructor.relationshipExists(this.id, obj.id || obj, type, 'all', cb);\r\n    };\r\n};\r\n\r\nNeo4j.prototype.findById = function findById(model, id, callback) {\r\n    var self = this;\r\n    self.client.readNode(id, function (err, node) {\r\n        if (!node) {\r\n            return callback && callback(err, null);\r\n        }\r\n        var id = node._id;\r\n        delete node._id;\r\n        node = self.fromDatabase(model, node);\r\n        node.id = id;\r\n        return callback && callback(err, node);\r\n    }.bind(self));\r\n};\r\n\r\nNeo4j.prototype.create = function create(model, data, callback) {\r\n    var cdata = {};\r\n    cdata.nodeType = model;\r\n    var self = this, props = self._models[model].properties;\r\n    Object.keys(data).forEach(function (key) {\r\n        if (!props[key]) return;\r\n        cdata[key] = self.toDatabase(props[key], data[key]);\r\n    });\r\n\r\n    self.client.insertNode(cdata, model, function (err, node) {\r\n        if (err) {\r\n            return callback(err);\r\n        }\r\n        callback(err, node._id);\r\n    });\r\n};\r\n\r\nNeo4j.prototype.updateIndexes = function updateIndexes(model, node, callback) {\r\n    var props = this._models[model].properties;\r\n    var wait = 1;\r\n    Object.keys(props).forEach(function (key) {\r\n        if (props[key].index && node.data[key]) {\r\n            wait += 1;\r\n            node.index(model, key, node.data[key], done);\r\n        }\r\n    });\r\n\r\n    done();\r\n\r\n    var error = false;\r\n\r\n    function done(err) {\r\n        error = error || err;\r\n        if (--wait === 0) {\r\n            callback(error);\r\n        }\r\n    }\r\n};\r\n\r\nNeo4j.prototype.save = function save(model, data, callback) {\r\n    var self = this, id = data.id;\r\n    self.updateAttributes(model, id, data, function (err, updatedNode) {\r\n        return callback && callback(err, updatedNode);\r\n    }.bind(self));\r\n};\r\n\r\nNeo4j.prototype.exists = function exists(model, id, callback) {\r\n    this.findById(model, id, function (err, data) {\r\n        return callback(err, !err && data)\r\n    }.bind(this));\r\n};\r\n\r\nNeo4j.prototype.destroy = function destroy(model, id, callback) {\r\n    this.client.deleteNode(id, function (err, node) {\r\n        callback(err, node);\r\n    });\r\n};\r\n\r\nNeo4j.prototype.all = function all(model, filter, callback) {\r\n    if ('function' === typeof filter) {\r\n        callback = filter;\r\n        filter = {};\r\n    }\r\n    if (!filter) {\r\n        filter = {};\r\n    }\r\n    var self = this, query = ['MATCH (data:' + model + ')'];\r\n\r\n    query.push('WHERE data.nodeType = \\'' + model + '\\'');\r\n\r\n    if (filter) {\r\n        if (filter.where) {\r\n            var sql = self.buildWhere(filter.where, self, model);\r\n            query.push(sql);\r\n        }\r\n    }\r\n    query.push('RETURN data');\r\n\r\n    if (filter.order) {\r\n        var order = 'data.' + filter.order;\r\n        if (typeof order === 'string') {\r\n            order = [order];\r\n        }\r\n        query.push('ORDER BY ', order.join(', '));\r\n    }\r\n\r\n    if (filter.limit) {\r\n        if (filter.skip) {\r\n            query.push('SKIP ' + (filter.skip || 0));\r\n        }\r\n        query.push('LIMIT ' + filter.limit);\r\n    }\r\n\r\n    self.client.cypherQuery(query.join(' '), function (err, res) {\r\n        var data = (res || {}).data || [];\r\n        data = data.map(function (obj) {\r\n            var cleared = self.fromDatabase(model, obj);\r\n            cleared.id = obj._id;\r\n            return cleared;\r\n        });\r\n        return callback && callback(err, data);\r\n    }.bind(self));\r\n};\r\n\r\nNeo4j.prototype.destroyAll = function destroyAll(model, callback) {\r\n    var query = 'MATCH (data:' + model + ') ' +\r\n        'WHERE data.nodeType = \\'' + model + '\\' ' +\r\n        'DELETE data RETURN count(data)';\r\n    this.client.cypherQuery(query, function (err, res) {\r\n        callback(err, res);\r\n    }.bind(this));\r\n};\r\n\r\nNeo4j.prototype.count = function count(model, callback, filter) {\r\n    var self = this, query = ['MATCH (data:' + model + ')'];\r\n    query.push('WHERE data.nodeType = \\'' + model + '\\'');\r\n    if (filter) {\r\n        if (filter.where) {\r\n            var sql = self.buildWhere(filter.where, self, model);\r\n            query.push(sql);\r\n        }\r\n    }\r\n    query.push('RETURN  count(data) AS count');\r\n    self.client.cypherQuery(query.join(' '), function (err, res) {\r\n        var count = 0;\r\n        if (res && res.data) {\r\n            count = res.data[0] || 0;\r\n        }\r\n        return callback && callback(err, count);\r\n    }.bind(self));\r\n};\r\n\r\nNeo4j.prototype.updateAttributes = function updateAttributes(model, id, data, callback) {\r\n    var self = this, props = self._models[model].properties;\r\n    self.findById(model, id, function (err, node) {\r\n        Object.keys(data).forEach(function (key) {\r\n            data[key] = self.toDatabase(props[key], data[key]);\r\n        });\r\n        var merged = merge(node, data);\r\n        merged.id = id;\r\n        merged.nodeType = model;\r\n        self.client.updateNode(id, merged, function (err, updated) {\r\n            return callback && callback(err, updated);\r\n        });\r\n    }.bind(self));\r\n};\r\n\r\n/**\r\n * Update rows\r\n * @param {String} model\r\n * @param {Object} filter\r\n * @param {Object} data\r\n * @param {Function} callback\r\n */\r\nNeo4j.prototype.update = function (model, filter, data, callback) {\r\n    if ('function' === typeof filter) {\r\n        return filter(new Error(\"Get parametrs undefined\"), null);\r\n    }\r\n    if ('function' === typeof data) {\r\n        return data(new Error(\"Set parametrs undefined\"), null);\r\n    }\r\n    var self = this, cdata = {}, props = self._models[model].properties;\r\n    filter = filter.where ? filter.where : filter;\r\n    Object.keys(data).forEach(function (key) {\r\n        cdata[key] = self.toDatabase(props[key], data[key]);\r\n    });\r\n    self.client.updateNodesWithLabelsAndProperties(model, filter, cdata, [], false, function (err, updatedNodes) {\r\n        return callback && callback(err, updatedNodes);\r\n    });\r\n};\r\n\r\nNeo4j.prototype.toDatabase = function (prop, val, esc) {\r\n    \"use strict\";\r\n    if (val === null) {\r\n        return '';\r\n    }\r\n    if (!prop) {\r\n        return val;\r\n    }\r\n    var type = (prop.type.name || '').toString().toLowerCase();\r\n    if (type === 'number') {\r\n        return val;\r\n    }\r\n    if (type === 'date') {\r\n        if (!val) {\r\n            return 0;\r\n        }\r\n        if (typeof val === 'string') {\r\n            val = Date.parse(val);\r\n        }\r\n        if (val instanceof Date) {\r\n            val = val.getTime();\r\n        }\r\n        return val;\r\n    }\r\n    if (type === \"boolean\") {\r\n        return val ? 1 : 0;\r\n    }\r\n    if (type === \"json\") {\r\n        if (typeof val === 'object') {\r\n            val = JSON.stringify(val);\r\n        }\r\n    }\r\n    return esc ? '\\'' + val.toString() + '\\'' : val.toString();\r\n};\r\n\r\nNeo4j.prototype.fromDatabase = function (model, data) {\r\n    if (!data) {\r\n        return null;\r\n    }\r\n    var clean = {};\r\n    var props = this._models[model].properties;\r\n    Object.keys(data).forEach(function (key) {\r\n        var val = data[key];\r\n        if (!props[key]) {\r\n            return;\r\n        }\r\n        var type = (props[key].type.name || '').toString().toLowerCase();\r\n\r\n        if (type === 'date' && val !== null) {\r\n            if (val !== '') {\r\n                clean[key] = new Date(val);\r\n            } else {\r\n                clean[key] = '';\r\n            }\r\n        } else if (type === 'json') {\r\n            if (typeof val === 'string') {\r\n                try {\r\n                    clean[key] = JSON.parse(val);\r\n                } catch (err) {\r\n                    clean[key] = val;\r\n                }\r\n            } else {\r\n                clean[key] = val;\r\n            }\r\n        } else {\r\n            clean[key] = val;\r\n        }\r\n\r\n    });\r\n    return clean;\r\n};\r\n\r\nNeo4j.prototype.buildWhere = function buildWhere(conds, adapter, model) {\r\n    'use strict';\r\n    var cs = [], or = [],\r\n        self = adapter,\r\n        props = self._models[model].properties;\r\n\r\n    Object.keys(conds).forEach(function (key) {\r\n        if (key !== 'or') {\r\n            cs = parseCond(cs, key, props, conds, self);\r\n        } else {\r\n            conds[key].forEach(function (oconds) {\r\n                Object.keys(oconds).forEach(function (okey) {\r\n                    or = parseCond(or, okey, props, oconds, self);\r\n                });\r\n            });\r\n        }\r\n    });\r\n\r\n    if (cs.length === 0 && or.length === 0) {\r\n        return '';\r\n    }\r\n    var orop = \"\";\r\n    if (or.length) {\r\n        orop = ' (' + or.join(' OR ') + ') ';\r\n    }\r\n    orop += (orop !== \"\" && cs.length > 0) ? ' AND ' : '';\r\n    return 'AND ' + orop + cs.join(' AND ');\r\n};\r\n\r\nvar parseCond = function (cs, key, props, conds, self) {\r\n    'use strict';\r\n    var keyEscaped = 'data.' + key;\r\n    var val = conds[key];\r\n    if (val === null) {\r\n        cs.push(keyEscaped + '\\'\\'');\r\n    } else if (val.constructor.name === 'Object') {\r\n        Object.keys(val).forEach(function (condType) {\r\n            val = self.toDatabase(props[key], val[condType], true);\r\n            var sqlCond = keyEscaped;\r\n            if ((condType === 'inq' || condType === 'nin') && val.length === 0) {\r\n                cs.push(condType === 'inq' ? 0 : 1);\r\n                return true;\r\n            }\r\n            switch (condType.toString().toLowerCase()) {\r\n                case 'gt':\r\n                    sqlCond += ' > ';\r\n                    break;\r\n                case 'gte':\r\n                    sqlCond += ' >= ';\r\n                    break;\r\n                case 'lt':\r\n                    sqlCond += ' < ';\r\n                    break;\r\n                case 'lte':\r\n                    sqlCond += ' <= ';\r\n                    break;\r\n                case 'between':\r\n                    sqlCond += '';\r\n                    break;\r\n                case 'inq':\r\n                case 'in':\r\n                    sqlCond += ' IN ';\r\n                    break;\r\n                case 'nin':\r\n                    sqlCond = ' NOT ( ' + keyEscaped + ' IN [' + val + '])';\r\n                    break;\r\n                case 'neq':\r\n                case 'ne':\r\n                    sqlCond = ' NOT ( ' + keyEscaped + ' = ' + val + ' )';\r\n                    break;\r\n                case 'regex':\r\n                    sqlCond += ' REGEXP ';\r\n                    break;\r\n                case 'like':\r\n                    sqlCond += ' LIKE ';\r\n                    break;\r\n                case 'nlike':\r\n                    sqlCond += ' NOT LIKE ';\r\n                    break;\r\n                default:\r\n                    sqlCond += ' ' + condType + ' ';\r\n                    break;\r\n            }\r\n\r\n            if (condType === 'between') {\r\n                sqlCond = val[0] + ' <= ' + keyEscaped + ' <= ' + val[1];\r\n            } else if (condType === 'in' || condType === 'inq') {\r\n                sqlCond += '[' + val + ']';\r\n            } else if (condType === 'neq' || condType === 'ne' || condType === 'nin') {\r\n\r\n            } else {\r\n                sqlCond += val;\r\n            }\r\n            cs.push(sqlCond);\r\n        });\r\n\r\n    } else if (/^\\//gi.test(conds[key])) {\r\n        var reg = val.toString().split('/');\r\n        cs.push(keyEscaped + ' REGEXP \"' + reg[1] + '\"');\r\n    } else {\r\n        val = self.toDatabase(props[key], val, true);\r\n        cs.push(keyEscaped + ' = ' + val);\r\n    }\r\n    return cs;\r\n};\r\n\r\nvar cleanup = function (data) {\r\n    if (!data) {\r\n        return null;\r\n    }\r\n    var res = {};\r\n    Object.keys(data).forEach(function (key) {\r\n        var v = data[key];\r\n        if (v === null) {\r\n            // skip\r\n            // console.log('skip null', key);\r\n        } else if (v && v.constructor.name === 'Array' && v.length === 0) {\r\n            // skip\r\n            // console.log('skip blank array', key);\r\n        } else if (typeof v !== 'undefined') {\r\n            res[key] = v;\r\n        }\r\n    });\r\n    return res;\r\n};\r\n\r\nvar merge = function (base, update) {\r\n    Object.keys(update).forEach(function (key) {\r\n        base[key] = update[key];\r\n    });\r\n    return base;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/postgres.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar util = require('util');\nvar safeRequire = utils.safeRequire;\nvar pg = safeRequire('pg');\nvar BaseSQL = require('../sql');\nvar url = require('url');\nvar querystring = require('querystring');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!pg) {\n        throw new Error('module pg is not defined, try\\n  npm install pg');\n    }\n    var Client = pg.Client;\n    var s = schema.settings;\n\n    if (s.url) {\n        var uri = url.parse(schema.settings.url);\n        var query = querystring.parse(uri.query);\n        s.host = uri.hostname;\n        s.port = uri.port;\n        s.database = uri.pathname.replace(/^\\//, '');\n        s.username = uri.auth && uri.auth.split(':')[0];\n        s.password = uri.auth && uri.auth.split(':')[1];\n        s.ssl = /(true|require)/.test(query.ssl);\n    }\n    s.host = s.host || 'localhost';\n    s.port = parseInt(s.port || '5432', 10);\n    s.database = s.database || 'test';\n    s.ssl = s.ssl || false;\n\n    schema.client = new Client(s.url ? s.url : {\n        host: s.host || 'localhost',\n        port: s.port || 5432,\n        user: s.username || process.env.USER,\n        password: s.password,\n        database: s.database || process.env.USER,\n        poolIdleTimeout: s.poolIdleTimeout || 5000,\n        poolSize: s.poolSize || s.pool || 25,\n        debug: s.debug,\n        ssl: s.ssl\n    });\n    schema.adapter = new PG(s, schema.client);\n    schema.adapter.connect(schema, callback);\n};\n\nfunction PG(s, client) {\n    this.name = 'postgres';\n    this._models = {};\n    this.client = client;\n    this.settings = s;\n}\n\nutil.inherits(PG, BaseSQL);\n\nPG.prototype.connect = function (schema, callback) {\n    var self = this;\n    createBlankDB(schema, function () {\n        self.client.connect(function (err) {\n            if (!err) {\n                return callback && callback();\n            } else {\n                throw err;\n            }\n        });\n    });\n};\n\nfunction createBlankDB(schema, callback) {\n    var s = schema.settings;\n    pg.connect({\n        host: s.host || 'localhost',\n        port: s.port || 5432,\n        user: s.username,\n        password: s.password,\n        database: s.database || 'postgres',\n        debug: s.debug,\n        ssl: s.ssl\n    }, function (err, client, done) {\n        if (err) {\n            console.log('Error while connecting: ' + err);\n        }\n        client.query('CREATE DATABASE ' + s.database + ' OWNER ' + s.username + ' ENCODING \\'UTF8\\'', function (err) {\n            if (err) {\n                // console.log(err, 'ignoring the error');\n            }\n            client.end();\n            done();\n            return callback && callback();\n        });\n    });\n}\n\nPG.prototype.tableEscaped = function (model) {\n    return this.escapeName(this.table(model));\n};\n\nPG.prototype.query = function (sql, vals, callback) {\n    var self = this, time = Date.now(), log = self.log;\n    if (typeof vals === 'function') {\n        callback = vals;\n        vals = {};\n    }\n    self.client.query(sql, vals, function (err, data) {\n        if (log) {\n            log(time, sql);\n        }\n        callback(err, data ? data.rows : null);\n    });\n};\n\n/**\n * Must invoke callback(err, id)\n * @param {String} model\n * @param {Object} data\n * @param {Function} callback\n */\nPG.prototype.create = function (model, data, callback) {\n    var fields = this.toFields(model, data, true);\n    var sql = 'INSERT INTO ' + this.tableEscaped(model) + '';\n    if (fields) {\n        sql += ' ' + fields;\n    } else {\n        sql += ' VALUES ()';\n    }\n    sql += ' RETURNING id';\n\n    this.query(sql, function (err, info) {\n        if (err) {\n            return callback && callback(err);\n        }\n        return callback && callback(err, info && info[0] && info[0].id);\n    }.bind(this));\n};\n\n/**\n * Update rows\n * @param {String} model\n * @param {Object} filter\n * @param {Object} data\n * @param {Function} callback\n */\nPG.prototype.update = function (model, filter, data, callback) {\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parameters undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parameters undefined\"), null);\n    }\n    filter = filter.where ? filter.where : filter;\n    var self = this;\n    var combined = [];\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key] || key === 'id') {\n            var k = '\"' + key + '\"';\n            var v;\n            if (key !== 'id') {\n                v = self.toDatabase(props[key], data[key]);\n            } else {\n                v = data[key];\n            }\n            combined.push(k + ' = ' + v);\n        }\n    });\n\n    var sql = 'UPDATE ' + self.tableEscaped(model);\n    sql += ' SET ' + combined.join(', ');\n    sql += ' ' + self.buildWhere(filter, self, model);\n    this.query(sql, function (err, affected) {\n        return callback && callback(err, affected);\n    });\n};\n\n/**\n * Must invoke callback(err, data)\n * @param {String} model\n * @param {Object} filter\n * @param {Function} callback\n */\nPG.prototype.all = function all(model, filter, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    var sql = '';\n    if(filter.fields === undefined) {\n        sql = 'SELECT ' + this.getColumns(model) + ' FROM ' +\n            this.tableEscaped(model) + ' ' +\n            this.toFilter(model, filter);\n    } else {\n        sql = 'SELECT ' + filter.fields + ' FROM ' +\n            this.tableEscaped(model) + ' ' +\n            this.toFilter(model, filter);\n    }\n\n    this.query(sql, function (err, data) {\n        if (err) {\n            return callback && callback(err, []);\n        }\n        if (filter && filter.include) {\n            this._models[model].model.include(data, filter.include, callback);\n        } else {\n            return callback && callback(null, data);\n        }\n    }.bind(this));\n};\n\n/**\n * Must invoke callback(err, data)\n * @param {String} model\n * @param {Object} filter\n * @param {Function} callback\n */\nPG.prototype.remove = function remove(model, filter, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    var sql = 'DELETE FROM ' + this.tableEscaped(model) + ' ' + this.toFilter(model, filter);\n    this.query(sql, function (err, data) {\n        if (err) {\n            return callback && callback(err, []);\n        }\n        if (filter && filter.include) {\n            this._models[model].model.include(data, filter.include, callback);\n        } else {\n            return callback && callback(null, data);\n        }\n    }.bind(this));\n};\n\nPG.prototype.toFields = function (model, data, forCreate) {\n    var fields = [];\n    var props = this._models[model].properties;\n\n    if (forCreate) {\n        var columns = [];\n        Object.keys(data).forEach(function (key) {\n            if (props[key]) {\n                if (key === 'id') {\n                    return;\n                }\n                columns.push('\"' + key + '\"');\n                fields.push(this.toDatabase(props[key], data[key]));\n            }\n        }.bind(this));\n        return '(' + columns.join(',') + ') VALUES (' + fields.join(',') + ')';\n    } else {\n        Object.keys(data).forEach(function (key) {\n            if (props[key]) {\n                if (key === 'id') {\n                    return;\n                }\n                fields.push('\"' + key + '\" = ' + this.toDatabase(props[key], data[key]));\n            }\n        }.bind(this));\n        return fields.join(',');\n    }\n};\n\nfunction dateToPostgres(val) {\n    function fz(v) {\n        return v < 10 ? '0' + v : v;\n    }\n    return [\n            val.getFullYear(),\n            fz(val.getMonth() + 1),\n            fz(val.getDate())\n        ].join('-') + ' ' + [\n            fz(val.getHours()),\n            fz(val.getMinutes()),\n            fz(val.getSeconds())\n        ].join(':');\n}\n\nPG.prototype.toDatabase = function (prop, val) {\n    if (val === null) {\n        // Postgres complains with NULLs in not null columns\n        // If we have an autoincrement value, return DEFAULT instead\n        if (prop.autoIncrement) {\n            return 'DEFAULT';\n        }\n        else {\n            return 'NULL';\n        }\n    }\n    var type = (prop.type.name || '').toString().toLowerCase();\n\n    if (val.constructor.name === 'Object' && type !== 'json') {\n        var operator = Object.keys(val)[0];\n        val = val[operator];\n        if (operator === 'in' || operator === 'inq' || operator === 'nin') {\n            if (!(val.propertyIsEnumerable('length')) && typeof val === 'object' && typeof val.length === 'number') { //if value is array\n                for (var i = 0; i < val.length; i++) {\n                    val[i] = escape(val[i]);\n                }\n                return val.join(',');\n            } else {\n                return val;\n            }\n        }\n    }\n\n    if (type === 'number') {\n        if (!val && val !== 0) {\n            if (prop.autoIncrement) {\n                return 'DEFAULT';\n            }\n            else {\n                return 'NULL';\n            }\n        }\n        return val;\n    }\n\n    if (type === 'date') {\n        if (!val) {\n            if (prop.autoIncrement) {\n                return 'DEFAULT';\n            }\n            else {\n                return 'NULL';\n            }\n        }\n        if (!val.toUTCString) {\n            val = new Date(val);\n        }\n        return escape(dateToPostgres(val));\n    }\n\n    if (type === 'json') {\n        return '\\'' + JSON.stringify(val) + '\\'';\n    }\n\n    return /^E(?:\\\\'|.)*?'$/gi.test(val.toString()) ? val : escape(val.toString());\n\n};\n\nPG.prototype.fromDatabase = function (model, data) {\n    if (!data) {\n        return null;\n    }\n\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        var val = data[key];\n        if (props[key]) {\n            if ((props[key].type.name || '').toString().toLowerCase() === 'json' && typeof val == \"string\") {\n                try {\n                    val = JSON.parse(val);\n                } catch (err) {\n\n                }\n            }\n            data[key] = val;\n        }\n    });\n    return data;\n};\n\nPG.prototype.escapeName = escapeName;\n\nPG.prototype.getColumns = function (model) {\n    return '\"' + Object.keys(this._models[model].properties).join('\", \"') + '\"';\n};\n\nPG.prototype.toFilter = function (model, filter) {\n    var self = this, out = '';\n    if (filter && typeof filter.where === 'function') {\n        return filter();\n    }\n    if (!filter) {\n        return '';\n    }\n\n    if (filter.where) {\n        out = self.buildWhere(filter.where, self, model);\n    }\n\n    if (filter.order) {\n        out += self.buildOrderBy(filter.order);\n    }\n\n    if (filter.group) {\n        out += self.buildGroupBy(filter.group);\n    }\n\n    if (filter.limit) {\n        out += self.buildLimit(filter.limit, (filter.offset || filter.skip || '0'));\n    }\n\n    return out;\n};\n\nPG.prototype.autoupdate = function (callback) {\n    var self = this, wait = 0;\n    Object.keys(self._models).forEach(function (model) {\n        wait += 1;\n        var indexes = [];\n        var sql = 'SELECT column_name as \"Field\", udt_name as \"Type\", ' +\n            'is_nullable as \"Null\", column_default as \"Default\" ' +\n            'FROM information_schema.COLUMNS WHERE table_name = \"' + self.table(model) + '\"';\n        self.client.query(sql, function (err, fields) {\n            if(err){\n                // console.log('autoupdate err', wait, err.message, sql);\n                return done && done();\n            }\n            if (!err && fields.length) {\n                fields.forEach(function (field) {\n                    field.Type = mapPostgresDatatypes(field.Type);\n                });\n                self.alterTable(model, fields, indexes, done);\n            } else {\n                self.createTable(model, indexes, done);\n            }\n        });\n    });\n\n    function done(err) {\n        if (err) {\n            console.log(err);\n        }\n        if (--wait === 0) {\n            return callback && callback();\n        }\n    }\n};\n\nPG.prototype.isActual = function (cb) {\n    var self = this;\n    var wait = 0;\n    var changes = [];\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        getTableStatus.call(self, model, function (err, fields) {\n            changes = changes.concat(getPendingChanges.call(self, model, fields));\n            done(err, changes);\n        });\n    });\n\n    function done(err) {\n        if (err) {\n            console.log(err);\n        }\n        if (--wait === 0 && cb) {\n            var actual = (changes.length === 0);\n            return cb && cb(null, actual);\n        }\n    }\n};\n\nPG.prototype.alterTable = function (model, actualFields, indexes, done) {\n    var self = this;\n    var pendingChanges = getPendingChanges.call(self, model, actualFields);\n    applySqlChanges.call(self, model, pendingChanges, done);\n};\n\nfunction getPendingChanges(model, actualFields) {\n    var sql = [], self = this;\n    sql = sql.concat(getColumnsToAdd.call(self, model, actualFields));\n    sql = sql.concat(getPropertiesToModify.call(self, model, actualFields));\n    sql = sql.concat(getColumnsToDrop.call(self, model, actualFields));\n    return sql;\n}\n\nfunction getColumnsToAdd(model, actualFields) {\n    var self = this;\n    var m = self._models[model];\n    var propNames = Object.keys(m.properties);\n    var sql = [];\n    propNames.forEach(function (propName) {\n        if (propName === 'id')\n            return;\n        var found = searchForPropertyInActual.call(self, propName, actualFields);\n        if (!found && propertyHasNotBeenDeleted.call(self, model, propName)) {\n            sql.push(addPropertyToActual.call(self, model, propName));\n        }\n    });\n    return sql;\n}\n\nfunction addPropertyToActual(model, propName) {\n    var self = this, p = self._models[model].properties[propName];\n    var sqlCommand = 'ADD COLUMN \"' + propName + '\" ' + datatype(p) + \" \" + (propertyCanBeNull.call(self, model, propName) ? \"\" : \" NOT NULL\");\n    return sqlCommand;\n}\n\nfunction searchForPropertyInActual(propName, actualFields) {\n    var found = false;\n    actualFields.forEach(function (f) {\n        if (f.Field === propName) {\n            found = f;\n            return;\n        }\n    });\n    return found;\n}\n\nfunction getPropertiesToModify(model, actualFields) {\n    var self = this, sql = [], found, m = self._models[model];\n    var propNames = Object.keys(m.properties);\n    propNames.forEach(function (propName) {\n        if (propName === 'id')\n            return;\n        found = searchForPropertyInActual.call(self, propName, actualFields);\n        if (found && propertyHasNotBeenDeleted.call(self, model, propName)) {\n            if (datatypeChanged(propName, found)) {\n                sql.push(modifyDatatypeInActual.call(self, model, propName));\n            }\n            if (nullabilityChanged(propName, found)) {\n                sql.push(modifyNullabilityInActual.call(self, model, propName));\n            }\n        }\n    });\n\n    function datatypeChanged(propName, oldSettings) {\n        var newSettings = m.properties[propName];\n        if (!newSettings) {\n            return false;\n        }\n        return oldSettings.Type.toLowerCase() !== datatype(newSettings);\n    }\n\n    function nullabilityChanged(propName, oldSettings) {\n        var newSettings = m.properties[propName];\n        if (!newSettings)\n            return false;\n        var changed = false;\n        if (oldSettings.Null === 'YES' && (newSettings.allowNull === false || newSettings.null === false))\n            changed = true;\n        if (oldSettings.Null === 'NO' && !(newSettings.allowNull === false || newSettings.null === false))\n            changed = true;\n        return changed;\n    }\n    return sql;\n}\n\nfunction modifyDatatypeInActual(model, propName) {\n    var self = this;\n    var sqlCommand = 'ALTER COLUMN \"' + propName + '\"  TYPE ' + datatype(self._models[model].properties[propName]);\n    return sqlCommand;\n}\n\nfunction modifyNullabilityInActual(model, propName) {\n    var self = this, sqlCommand = 'ALTER COLUMN \"' + propName + '\" ';\n    if (propertyCanBeNull.call(self, model, propName)) {\n        sqlCommand = sqlCommand + \"DROP \";\n    } else {\n        sqlCommand = sqlCommand + \"SET \";\n    }\n    sqlCommand = sqlCommand + \"NOT NULL\";\n    return sqlCommand;\n}\n\nfunction getColumnsToDrop(model, actualFields) {\n    var self = this, sql = [];\n    actualFields.forEach(function (actualField) {\n        if (actualField.Field === 'id') {\n            return;\n        }\n        if (actualFieldNotPresentInModel(actualField, model)) {\n            sql.push('DROP COLUMN \"' + actualField.Field + '\"');\n        }\n    });\n\n    function actualFieldNotPresentInModel(actualField, model) {\n        return !(self._models[model].properties[actualField.Field]);\n    }\n\n    return sql;\n}\n\nfunction applySqlChanges(model, pendingChanges, done) {\n    var self = this;\n    if (pendingChanges.length) {\n        var thisQuery = 'ALTER TABLE ' + self.tableEscaped(model);\n        var ranOnce = false;\n        pendingChanges.forEach(function (change) {\n            if (ranOnce)\n                thisQuery = thisQuery + ',';\n            thisQuery = thisQuery + ' ' + change;\n            ranOnce = true;\n        });\n        thisQuery = thisQuery + ';';\n        self.query(thisQuery, callback);\n    } else {\n        return done && done();\n    }\n\n    function callback(err) {\n        if (err) {\n            console.log(err);\n        }\n        return done && done();\n    }\n}\n\nfunction getTableStatus(model, done) {\n    function decoratedCallback(err, data) {\n        data.forEach(function(field) {\n            field.Type = mapPostgresDatatypes(field.Type);\n        });\n        return done && done(err, data);\n    }\n    this.query('SELECT column_name as \"Field\", udt_name as \"Type\", ' +\n        'is_nullable as \"Null\", column_default as \"Default\" ' +\n        'FROM information_schema.COLUMNS WHERE table_name = \\'' + this.table(model) + '\\'', decoratedCallback);\n}\n\nPG.prototype.propertiesSQL = function (model) {\n    var self = this, sql = ['\"id\" SERIAL PRIMARY KEY'];\n    Object.keys(this._models[model].properties).forEach(function (prop) {\n        if (prop === 'id') {\n            return;\n        }\n        sql.push('\"' + prop + '\" ' + self.propertySettingsSQL(model, prop));\n    });\n    return sql.join(',\\n  ');\n};\n\nPG.prototype.propertySettingsSQL = function (model, propName) {\n    var self = this, p = self._models[model].properties[propName];\n    var result = datatype(p) + ' ';\n    if (!propertyCanBeNull.call(self, model, propName)) {\n        result = result + 'NOT NULL ';\n    }\n    return result;\n};\n\nfunction propertyCanBeNull(model, propName) {\n    var p = this._models[model].properties[propName];\n    return !(p.allowNull === false || p['null'] === false);\n}\n\nfunction escape(val) {\n    if (val === undefined || val === null) {\n        return 'NULL';\n    }\n\n    switch (typeof val) {\n        case 'boolean':\n            return (val) ? 'true' : 'false';\n        case 'number':\n            return val + '';\n    }\n\n    if (typeof val === 'object') {\n        val = (typeof val.toISOString === 'function')\n            ? val.toISOString()\n            : val.toString();\n    }\n\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\\\'\\\"\\x1a]/g, function (s) {\n        switch (s) {\n            case \"\\0\":\n                return \"\\\\0\";\n            case \"\\n\":\n                return \"\\\\n\";\n            case \"\\r\":\n                return \"\\\\r\";\n            case \"\\b\":\n                return \"\\\\b\";\n            case \"\\t\":\n                return \"\\\\t\";\n            case \"\\x1a\":\n                return \"\\\\Z\";\n            default:\n                return \"\\\\\" + s;\n        }\n    });\n    return \"E'\" + val + \"'\";\n}\n\n\nfunction datatype(p) {\n    switch ((p.type.name || 'string').toLowerCase()) {\n        default:\n        case 'string':\n        case 'varchar':\n            return 'varchar';\n        case 'json':\n            return 'json';\n        case 'text':\n            return 'text';\n        case 'int':\n        case 'integer':\n        case 'number':\n            return 'integer';\n        case 'real':\n            return 'real';\n        case 'float':\n        case 'double':\n            return 'double precision';\n        case 'date':\n            return 'timestamp';\n        case 'boolean':\n            return 'boolean';\n    }\n}\n\nfunction mapPostgresDatatypes(typeName) {\n    //TODO there are a lot of synonymous type names that should go here-- this is just what i've run into so far\n    switch (typeName) {\n        case 'int4':\n            return 'integer';\n        case 'bool':\n            return 'boolean';\n        default:\n            return typeName;\n    }\n}\n\nfunction propertyHasNotBeenDeleted(model, propName) {\n    return !!this._models[model].properties[propName];\n}\n\nPG.prototype.buildWhere = function buildWhere(conds, adapter, model) {\n    var cs = [], or = [],\n        self = adapter,\n        props = self._models[model].properties;\n\n    Object.keys(conds).forEach(function (key) {\n        if (key !== 'or') {\n            cs = parseCond(cs, key, props, conds, self);\n        } else {\n            conds[key].forEach(function (oconds) {\n                Object.keys(oconds).forEach(function (okey) {\n                    or = parseCond(or, okey, props, oconds, self);\n                });\n            });\n        }\n    });\n\n    if (cs.length === 0 && or.length === 0) {\n        return '';\n    }\n    var orop = \"\";\n    if (or.length) {\n        orop = ' (' + or.join(' OR ') + ') ';\n    }\n    orop += (orop !== \"\" && cs.length > 0) ? ' AND ' : '';\n    return 'WHERE ' + orop + cs.join(' AND ');\n};\n\nfunction parseCond(cs, key, props, conds, self) {\n    var keyEscaped = escapeName(key);\n    var val = self.toDatabase(props[key], conds[key]);\n    if (conds[key] === null) {\n        cs.push(keyEscaped + ' IS NULL');\n    } else if (conds[key].constructor.name === 'Object') {\n        Object.keys(conds[key]).forEach(function (condType) {\n            var inq = 'in,inq,nin'.indexOf(condType) > -1 ? 1 : 0;\n            val = self.toDatabase(props[key], conds[key][condType]);\n            var sqlCond = keyEscaped;\n            if (inq === 1 && val.length === 0) {\n                cs.push(condType === 'inq' ? 0 : 1);\n                return true;\n            }\n            switch (condType) {\n                case 'gt':\n                    sqlCond += ' > ';\n                    break;\n                case 'gte':\n                    sqlCond += ' >= ';\n                    break;\n                case 'lt':\n                    sqlCond += ' < ';\n                    break;\n                case 'lte':\n                    sqlCond += ' <= ';\n                    break;\n                case 'between':\n                    sqlCond += ' BETWEEN ';\n                    break;\n                case 'inq':\n                case 'in':\n                    sqlCond += ' IN ';\n                    break;\n                case 'nin':\n                    sqlCond += ' NOT IN ';\n                    break;\n                case 'neq':\n                case 'ne':\n                    sqlCond += ' != ';\n                    break;\n                case 'regex':\n                    sqlCond += ' REGEXP ';\n                    break;\n                case 'like':\n                    sqlCond += ' LIKE ';\n                    break;\n                case 'nlike':\n                    sqlCond += ' NOT LIKE ';\n                    break;\n                default:\n                    sqlCond += ' ' + condType + ' ';\n                    break;\n            }\n            if (condType === 'between') {\n                sqlCond += val[0] + ' AND ' + val[1];\n            } else if (inq === 1) {\n                sqlCond += '(' + val + ')';\n            } else {\n                sqlCond += val;\n            }\n            cs.push(sqlCond);\n        });\n\n    } else if (/^\\//gi.test(conds[key])) {\n        var reg = val.toString().split('/');\n        cs.push(keyEscaped + ' REGEXP \"' + reg[1] + '\"');\n    } else {\n        cs.push(keyEscaped + ' = ' + val);\n    }\n    return cs;\n}\n\nPG.prototype.buildOrderBy = function buildOrderBy(order) {\n    if (typeof order === 'string') {\n        order = [order];\n    }\n    return ' ORDER BY ' + order.join(', ');\n};\n\nPG.prototype.buildLimit = function buildLimit(limit, offset) {\n    return ' LIMIT ' + limit + ' OFFSET ' + (offset || '0');\n};\n\nPG.prototype.buildGroupBy = function buildGroupBy(group) {\n    if (typeof group === 'string') {\n        group = [group];\n    }\n    return ' GROUP BY ' + group.join(', ');\n};\n\nfunction escapeName(name) {\n    return '\"' + name.replace(/\\./g, '\".\"') + '\"';\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/redis.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar redis = safeRequire('redis');\nvar utils = require('../utils');\nvar helpers = utils.helpers;\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!redis) {\n        return;\n    }\n    if (schema.settings.socket) {\n        schema.client = redis.createClient(\n            schema.settings.socket,\n            schema.settings.options\n        );\n    } else if (schema.settings.url) {\n        var url = require('url');\n        var redisUrl = url.parse(schema.settings.url);\n        var redisAuth = (redisUrl.auth || '').split(':');\n        schema.settings.host = redisUrl.hostname;\n        schema.settings.port = redisUrl.port;\n        if (redisAuth.length === 2) {\n            schema.settings.db = redisAuth[0];\n            schema.settings.password = redisAuth[1];\n        }\n    }\n\n    if (!schema.client) {\n        schema.client = redis.createClient(\n            schema.settings.port,\n            schema.settings.host,\n            schema.settings.options\n        );\n\n        if (schema.settings.password) {\n            schema.client.auth(schema.settings.password);\n        }\n    }\n\n    var callbackCalled = false;\n    var database = schema.settings.hasOwnProperty('database') && schema.settings.database;\n    schema.client.on('connect', function () {\n        if (!callbackCalled && database === false) {\n            callbackCalled = true;\n            callback();\n        } else if (database !== false) {\n            if (callbackCalled) {\n                return schema.client.select(schema.settings.database);\n            } else {\n                callbackCalled = true;\n                return schema.client.select(schema.settings.database, callback);\n            }\n        }\n    });\n\n    var clientWrapper = new Client(schema.client);\n    schema.adapter = new BridgeToRedis(schema.settings, clientWrapper);\n    clientWrapper._adapter = schema.adapter;\n};\n\nfunction Client(client) {\n    this._client = client;\n}\n\nvar commands = Object.keys(redis.Multi.prototype).filter(function (n) {\n    return n.match(/^[a-z]/);\n});\n\ncommands.forEach(function (cmd) {\n\n    Client.prototype[cmd] = function (args, callback) {\n        var c = this._client, log;\n        if (typeof args === 'string') {\n            args = [args];\n        }\n        if (!args) {\n            args = [];\n        }\n        var lstr = cmd.toUpperCase() + ' ' + args.map(function (a) {\n                if (typeof a === 'object') {\n                    return JSON.stringify(a);\n                }\n                return a;\n            }).join(' ');\n\n        args.push(function (err, replies) {\n            if (err) {\n                console.log(err);\n            }\n            callback && callback(err, replies);\n        });\n        c[cmd].apply(c, args);\n    };\n});\n\nClient.prototype.multi = function (commands, callback) {\n    if (commands.length === 0)\n        return callback && callback();\n    if (commands.length === 1) {\n        return this[commands[0].shift().toLowerCase()].call(\n            this,\n            commands[0],\n            callback && function (e, r) {\n                callback(e, [r]);\n            });\n    }\n    var lstr = 'MULTI\\n  ' + commands.map(function (x) {\n            return x.join(' ');\n        }).join('\\n  ') + '\\nEXEC';\n\n    this._client.multi(commands).exec(function (err, replies) {\n        if (err) {\n            console.log(err);\n        }\n        callback && callback(err, replies);\n    });\n};\n\nClient.prototype.transaction = function () {\n    return new Transaction(this);\n};\n\nfunction Transaction(client) {\n    this._client = client;\n    this._handlers = [];\n    this._schedule = [];\n}\n\nTransaction.prototype.run = function (cb) {\n    var t = this;\n    var atLeastOneHandler = false;\n    switch (this._schedule.length) {\n        case 0:\n            return cb();\n        case 1:\n            return this._client[this._schedule[0].shift()].call(\n                this._client,\n                this._schedule[0],\n                this._handlers[0] || cb);\n        default:\n            this._client.multi(this._schedule, function (err, replies) {\n                if (err)\n                    return cb(err);\n                replies.forEach(function (r, i) {\n                    if (t._handlers[i]) {\n                        atLeastOneHandler = true;\n                        t._handlers[i](err, r);\n                    }\n                });\n                if (!atLeastOneHandler)\n                    cb(err);\n            });\n    }\n\n};\n\ncommands.forEach(function (k) {\n    Transaction.prototype[k] = function (args, cb) {\n        if (typeof args === 'string') {\n            args = [args];\n        }\n        args.unshift(k);\n        this._schedule.push(args);\n        this._handlers.push(cb || false);\n    };\n});\n\nfunction BridgeToRedis(s, client) {\n    this.name = 'redis';\n    this._models = {};\n    this.client = client;\n    this.indexes = {};\n    this.settings = s;\n}\n\nBridgeToRedis.prototype.define = function (descr) {\n    var self = this;\n    var m = descr.model.modelName;\n    self._models[m] = descr;\n    self.indexes[m] = {\n        id: Number\n    };\n    Object.keys(descr.properties).forEach(function (prop) {\n        if (descr.properties[prop].index) {\n            self.indexes[m][prop] = descr.properties[prop].type;\n        } else if (prop === 'id') {\n            self.indexes[m][prop] = descr.properties[prop].type;\n        }\n    }.bind(this));\n};\n\nBridgeToRedis.prototype.defineForeignKey = function (model, key, cb) {\n    this.indexes[model][key] = Number;\n    cb(null, Number);\n};\n\nBridgeToRedis.prototype.forDatabase = function (model, data) {\n    var p = this._models[model].properties;\n    for (var i in data) {\n        if (!p[i]) {\n            continue;\n        }\n        if (typeof data[i] === 'undefined' || data[i] === null) {\n            if (p[i].default || p[i].default === 0) {\n                if (typeof p[i].default === 'function') {\n                    data[i] = p[i].default();\n                } else {\n                    data[i] = p[i].default;\n                }\n            } else {\n                data[i] = \"\";\n                continue;\n            }\n        }\n\n        switch ((p[i].type.name || '').toString().toLowerCase()) {\n            case \"date\":\n                if (data[i].getTime) {\n                    data[i] = data[i].getTime().toString();\n                } else if (parseInt(data[i]) > 0) {\n                    data[i] = data[i].toString();\n                } else {\n                    data[i] = '0';\n                }\n                break;\n            case \"number\":\n                data[i] = data[i].toString();\n                break;\n            case \"boolean\":\n                data[i] = !!data[i] ? \"1\" : \"0\";\n                break;\n            case \"json\":\n                if (typeof data[i] === 'object') {\n                    data[i] = JSON.stringify(data[i]);\n                }\n                break;\n            default:\n                data[i] = data[i].toString();\n        }\n\n    }\n    return data;\n};\n\nBridgeToRedis.prototype.fromDatabase = function (model, data) {\n    var p = this._models[model].properties, d;\n    for (var i in data) {\n        if (!p[i]) {\n            continue;\n        }\n        var type = (p[i].type.name || '').toString().toLowerCase();\n        if (typeof data[i] === 'undefined' || data[i] === null) {\n            if (p[i].default || p[i].default === 0) {\n                if (typeof p[i].default === 'function') {\n                    data[i] = p[i].default();\n                } else {\n                    data[i] = p[i].default;\n                }\n            } else {\n                data[i] = \"\";\n                continue;\n            }\n        }\n\n        switch (type) {\n            case \"json\":\n                try {\n                    if (typeof data[i] === 'string') {\n                        data[i] = JSON.parse(data[i]);\n                    }\n                } catch (err) {\n                }\n                break;\n            case \"date\":\n                d = new Date(data[i]);\n                d.setTime(data[i]);\n                data[i] = d;\n                break;\n            case \"number\":\n                data[i] = Number(data[i]);\n                break;\n            case \"boolean\":\n                data[i] = data[i] === \"1\";\n                break;\n\n        }\n    }\n    return data;\n};\n\nBridgeToRedis.prototype.save = function (model, data, callback) {\n    var self = this;\n    data = self.forDatabase(model, data);\n    deleteNulls(data);\n    self.client.hgetall(model + ':' + data.id, function (err, prevData) {\n        if (err) {\n            return callback(err);\n        }\n        self.client.hmset([model + ':' + data.id, self.forDatabase(model, data)], function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (prevData) {\n                Object.keys(prevData).forEach(function (k) {\n                    if (data.hasOwnProperty(k)) {\n                        return;\n                    }\n                    data[k] = prevData[k];\n                });\n            }\n            self.updateIndexes(model, data.id, data, callback, self.forDatabase(model, prevData));\n        }.bind(this));\n    }.bind(this));\n};\n\nBridgeToRedis.prototype.updateIndexes = function (model, id, data, callback, prevData) {\n    var p = this._models[model].properties;\n    var i = this.indexes[model];\n    var schedule = [];\n    if (!callback.removed) {\n        schedule.push(['SADD', 's:' + model, id]);\n    }\n    Object.keys(i).forEach(function (key) {\n        if (data.hasOwnProperty(key)) {\n            var val = data[key];\n            schedule.push([\n                'SADD',\n                'i:' + model + ':' + key + ':' + val,\n                id\n            ]);\n        }\n        if (prevData && prevData[key] !== data[key]) {\n            schedule.push([\n                'SREM',\n                'i:' + model + ':' + key + ':' + prevData[key],\n                id\n            ]);\n        }\n    });\n\n    if (schedule.length) {\n        this.client.multi(schedule, function (err) {\n            callback(err, data);\n        });\n    } else {\n        callback(null);\n    }\n};\n\nBridgeToRedis.prototype.create = function (model, data, callback) {\n    if (data.id) {\n        return create.call(this, data.id, true);\n    }\n    this.client.incr('id:' + model, function (err, id) {\n        create.call(this, id);\n    }.bind(this));\n\n    function create(id, upsert) {\n        data.id = id.toString();\n        this.save(model, data, function (err) {\n            if (callback) {\n                callback(err, parseInt(id, 10));\n            }\n        });\n        // push the id to the list of user ids for sorting\n        this.client.sadd(['s:' + model, data.id]);\n    }\n};\n\nBridgeToRedis.prototype.update = function (model, filter, data, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    if (!filter.where) {\n        filter = {where: filter};\n    }\n    var self = this;\n\n    self.all(model, filter, function (err, found) {\n        if (!found || !found.length) {\n            return callback && callback(err);\n        }\n        var dlen = found.length;\n        found.forEach(function (doc) {\n            doc = helpers.merge(doc, data);\n            self.save(model, doc, function (error) {\n                if (--dlen === 0) {\n                    return callback && callback(error, 0);\n                }\n            });\n        });\n    });\n};\n\nBridgeToRedis.prototype.exists = function (model, id, callback) {\n    this.client.exists(model + ':' + id, function (err, exists) {\n        if (callback) {\n            callback(err, exists ? true : false);\n        }\n    });\n};\n\nBridgeToRedis.prototype.findById = function findById(model, id, callback) {\n    var self = this;\n    self.client.hgetall(model + ':' + id, function (err, data) {\n        if (data && Object.keys(data).length > 0) {\n            data.id = id;\n        } else {\n            data = null;\n        }\n        data = self.fromDatabase(model, data);\n        callback(err, data);\n    }.bind(this));\n};\n\nBridgeToRedis.prototype.destroy = function destroy(model, id, callback) {\n    var br = this;\n    var trans = br.client.transaction();\n    br.client.hgetall(model + ':' + id, function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        trans.srem(['s:' + model, id]);\n        trans.del(model + ':' + id);\n        trans.run(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            callback.removed = true;\n            br.updateIndexes(model, id, {}, callback, data);\n        });\n    });\n};\n\nBridgeToRedis.prototype.possibleIndexes = function (model, filter, callback) {\n\n    if (!filter || Object.keys(filter.where || {}).length === 0) {\n        // no index needed\n        callback([[], [], [], true]);\n        return false;\n        /*\n         filter.where = {\n         id: {\n         gt: 0\n         }\n         };\n         */\n    }\n\n    var self = this;\n    var dest = 'where:' + (Date.now() * Math.random());\n    var props = self._models[model].properties;\n    var compIndex = {};\n    var foundIndex = [];\n    var noIndex = [];\n\n    Object.keys(filter.where).forEach(function (key) {\n        var i = self.indexes[model][key];\n\n        if (i && typeof i !== 'undefined') {\n            var val = filter.where[key];\n            if (val && typeof val === 'object' && !val.getTime) {\n                var cin = 'i:' + model + ':' + key + ':';\n                if (!compIndex[key]) {\n                    compIndex[key] = {\n                        conds: []\n                    };\n                }\n                if (i.name === 'Date') {\n                    Object.keys(val).forEach(function (cndkey) {\n                        val[cndkey] = val[cndkey] && val[cndkey].getTime ? val[cndkey].getTime() : 0;\n                    });\n                }\n                compIndex[key].rkey = cin + '*';\n                compIndex[key].fkey = cin;\n                compIndex[key].type = props[key].type.name;\n                compIndex[key].conds.push(val);\n            } else {\n                if (i.name === 'Date') {\n                    val = val && val.getTime ? val.getTime() : 0;\n                }\n                foundIndex.push('i:' + model + ':' + key + ':' + val);\n            }\n        } else {\n            noIndex.push(key);\n        }\n    }.bind(this));\n\n    if (Object.keys(compIndex || {}).length > 0) {\n        var multi = self.client._client.multi();\n        for (var ik in compIndex) {\n            multi.keys(compIndex[ik].rkey);\n        }\n        multi.exec(function (err, mkeys) {\n            if (err) {\n                console.log(err);\n            }\n            var condIndex = [];\n            for (var ic in compIndex) {\n                var kregex = new RegExp('^' + compIndex[ic].fkey + '(.*)');\n                if (mkeys) {\n                    for (var i in mkeys) {\n                        var keys = mkeys[i];\n                        if (keys.length) {\n                            keys.forEach(function (key) {\n                                if (kregex.test(key)) {\n                                    var fkval = RegExp.$1;\n                                    if (compIndex[ic].type === 'Number' || compIndex[ic].type === 'Date') {\n                                        fkval = parseInt(fkval);\n                                    }\n                                    if (helpers.parseCond(fkval, compIndex[ic].conds[0])) {\n                                        condIndex.push(key);\n                                    }\n                                }\n                            }.bind(this));\n                        }\n                    }\n                }\n            }\n            condIndex.unshift(dest);\n            self.client._client.sunionstore(condIndex, function (err, replies) {\n                if (replies > 0) {\n                    foundIndex.push(dest);\n                }\n                callback([foundIndex, noIndex, [dest]]);\n            });\n        }.bind(this));\n    } else {\n        callback([foundIndex, noIndex, [dest]]);\n    }\n};\n\nBridgeToRedis.prototype.all = BridgeToRedis.prototype.find = function all(model, filter, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n\n    var self = this;\n    var dest = 'temp:' + (Date.now() * Math.random());\n\n    if (!filter) {\n        filter = {order: 'id'};\n    }\n\n    // WHERE\n    if (!filter.where || Object.keys(filter.where).length === 0) {\n        dest = 's:' + model;\n        // no filtering, just sort/limit (if any)\n        // but we need where to be an object for possibleIndexes\n        filter.where = {};\n    }\n\n    self.possibleIndexes(model, filter, function (pi) {\n        var client = self.client;\n        var cmd;\n        var sortCmd = [];\n        var props = self._models[model].properties;\n        var allNumeric = true;\n        var trans = self.client.transaction();\n        var indexes = pi[0];\n        var noIndexes = pi[1];\n\n        if (noIndexes.length) {\n            throw new Error(model + ': no indexes found for ' +\n                noIndexes.join(', ') +\n                ' impossible to sort and filter using redis adapter');\n        }\n\n        // indexes needed\n        if (pi.length < 4) {\n            if (indexes && indexes.length > 0) {\n                indexes.unshift(dest);\n                trans.sinterstore(indexes);\n            } else {\n                return callback && callback(null, []);\n            }\n        }\n        // only counting?\n        if (filter.getCount) {\n            trans.scard(dest, callback);\n            return trans.run();\n        }\n\n        // ORDER\n        var reverse = false;\n        if (!filter.order) {\n            filter.order = 'id';\n        }\n        var orders = filter.order;\n        if (typeof filter.order === \"string\") {\n            orders = [filter.order];\n        }\n\n        orders.forEach(function (key) {\n            var m = key.match(/\\s+(A|DE)SC$/i);\n            if (m) {\n                key = key.replace(/\\s+(A|DE)SC/i, '');\n                if (m[1] === 'DE')\n                    reverse = true;\n            }\n            if (props[key].type.name !== 'Number' && props[key].type.name !== 'Date') {\n                allNumeric = false;\n            }\n            sortCmd.push(\"BY\", model + \":*->\" + key);\n        });\n\n        // LIMIT\n        if (filter.limit) {\n            var offset = (filter.offset || filter.skip || 0), limit = filter.limit;\n            sortCmd.push(\"LIMIT\", offset, limit);\n        }\n\n        // we need ALPHA modifier when sorting string values\n        // the only case it's not required - we sort numbers\n        if (!allNumeric) {\n            sortCmd.push('ALPHA');\n        }\n\n        if (reverse) {\n            sortCmd.push('DESC');\n        }\n\n        sortCmd.unshift(dest);\n        sortCmd.push(\"GET\", \"#\");\n        cmd = \"SORT \" + sortCmd.join(\" \");\n\n        trans.sort(sortCmd, function (err, ids) {\n            if (err) {\n                return callback(err, []);\n            }\n            var sortedKeys = ids.map(function (i) {\n                return model + \":\" + i;\n            });\n            handleKeys(err, sortedKeys);\n        }.bind(this));\n\n        if (dest.match(/^temp/)) {\n            trans.del(dest);\n        }\n\n        if (indexes && indexes.length > 0) {\n            indexes.forEach(function (idx) {\n                if (idx.match(/^where/)) {\n                    trans.del(idx);\n                }\n            }.bind(this));\n        }\n\n        function handleKeys(err, keys) {\n            if (err) {\n                console.log(err);\n            }\n            var query = keys.map(function (key) {\n                return ['hgetall', key];\n            });\n            client.multi(query, function (err, replies) {\n                callback(err, (replies || []).map(function (r) {\n                    return self.fromDatabase(model, r);\n                }));\n            }.bind(this));\n        }\n\n        function numerically(a, b) {\n            return a[this[0]] - b[this[0]];\n        }\n\n        function literally(a, b) {\n            return a[this[0]] > b[this[0]];\n        }\n\n        return trans.run(function(err, data){\n            return callback && callback(err, data);\n        });\n    });\n};\n\nBridgeToRedis.prototype.remove = function remove(model, filter, callback) {\n    var self = this;\n    var dest = 'temp:' + (Date.now() * Math.random());\n    self.possibleIndexes(model, filter, function (pi) {\n        var indexes = pi[0];\n        var noIndexes = pi[1];\n        var trans = self.client._client.multi();\n\n        if (noIndexes.length) {\n            throw new Error(model + ': no indexes found for ' +\n                noIndexes.join(', ') +\n                ' impossible to sort and filter using redis adapter');\n        }\n\n        if (indexes && indexes.length > 0) {\n            if (indexes.length === 1) {\n                indexes.unshift(dest);\n                trans.sunionstore(indexes);\n                trans.smembers(dest);\n            } else {\n                indexes.unshift(dest);\n                trans.sinterstore(indexes);\n            }\n        } else {\n            callback(null, null);\n        }\n\n        if (dest.match(/^temp/)) {\n            trans.del(dest);\n        }\n        if (indexes && indexes.length > 0) {\n            indexes.forEach(function (idx) {\n                if (idx.match(/^where/)) {\n                    trans.del(idx);\n                }\n            }.bind(this));\n        }\n\n        trans.exec(function (err, result) {\n            if (err) {\n                console.log(err);\n            }\n            var found = result[1] || [];\n            var query = found.map(function (key) {\n                return ['hgetall', (model + ':' + key)];\n            });\n\n            if (found && found.length > 0) {\n                self.client.multi(query, function (err, replies) {\n                    var schedule = [];\n                    if (replies && replies.length > 0) {\n                        replies.forEach(function (reply) {\n                            if (reply) {\n                                schedule.push([\n                                    'DEL',\n                                    model + ':' + reply.id\n                                ]);\n                                schedule.push([\n                                    'SREM',\n                                    's:' + model,\n                                    reply.id\n                                ]);\n                                Object.keys(reply).forEach(function (replyKey) {\n                                    schedule.push([\n                                        'SREM',\n                                        'i:' + model + ':' + replyKey + ':' + reply[replyKey],\n                                        reply.id\n                                    ]);\n                                }.bind(this));\n                            }\n                        }.bind(this));\n                        self.client.multi(schedule, callback);\n                    } else {\n                        callback(null);\n                    }\n                }.bind(this));\n            } else {\n                callback(null);\n            }\n        });\n    });\n};\n\nBridgeToRedis.prototype.destroyAll = function destroyAll(model, callback) {\n    var br = this;\n    br.client.multi([\n        ['KEYS', model + ':*'],\n        ['KEYS', '*:' + model + ':*']\n    ], function (err, k) {\n        br.client.del(k[0].concat(k[1]).concat('s:' + model), callback);\n    });\n};\n\nBridgeToRedis.prototype.count = function count(model, callback, where) {\n    if (where && Object.keys(where).length) {\n        this.all(model, {where: where, getCount: true}, callback);\n    } else {\n        this.client.scard('s:' + model, callback);\n    }\n};\n\nBridgeToRedis.prototype.updateAttributes = function updateAttrs(model, id, data, callback) {\n    var self = this;\n    data.id = id;\n    self.findById(model, id, function (err, prevData) {\n        self.save(model, data, callback, prevData);\n    });\n};\n\nfunction deleteNulls(data) {\n    Object.keys(data).forEach(function (key) {\n        if (data[key] === null)\n            delete data[key];\n    });\n}\n\nBridgeToRedis.prototype.disconnect = function disconnect() {\n    this.client.quit();\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/rethinkdb.js":"/**\r\n * Module dependencies\r\n */\r\nvar utils = require('../utils');\r\nvar safeRequire = utils.safeRequire;\r\nvar r = safeRequire('rethinkdb');\r\nvar url = require('url');\r\nvar fs = require('fs');\r\nvar moment = require('moment');\r\nvar gpool = require('generic-pool');\r\nvar async = require('async');\r\n\r\nexports.initialize = function initializeSchema(schema, callback) {\r\n    if (!r) {\r\n        return;\r\n    }\r\n    var s = schema.settings;\r\n\r\n    if (schema.settings.rs) {\r\n\r\n        s.rs = schema.settings.rs;\r\n        if (schema.settings.url) {\r\n            var uris = schema.settings.url.split(',');\r\n            s.hosts = [];\r\n            s.ports = [];\r\n            uris.forEach(function (uri) {\r\n                var purl = url.parse(uri);\r\n                s.hosts.push(purl.hostname || 'localhost');\r\n                s.ports.push(parseInt(purl.port || '28015', 10));\r\n                if (!s.database)\r\n                    s.database = purl.pathname.replace(/^\\//, '');\r\n                if (!s.username)\r\n                    s.username = purl.auth && purl.auth.split(':')[0];\r\n                if (!s.password)\r\n                    s.password = purl.auth && purl.auth.split(':')[1];\r\n            });\r\n        }\r\n        s.database = s.database || 'test';\r\n    } else {\r\n        if (schema.settings.url) {\r\n            var purl = url.parse(schema.settings.url);\r\n            s.host = purl.hostname;\r\n            s.port = purl.port;\r\n            s.database = purl.pathname.replace(/^\\//, '');\r\n            s.username = purl.auth && purl.auth.split(':')[0];\r\n            s.password = purl.auth && purl.auth.split(':')[1];\r\n        }\r\n        s.host = s.host || 'localhost';\r\n        s.port = parseInt(s.port || '28015', 10);\r\n        s.database = s.database || 'test';\r\n    }\r\n\r\n    s.safe = s.safe || false;\r\n\r\n    function connect(cb) {\r\n        r.connect({host: s.host, port: s.port, db: s.database}, function (error, client) {\r\n            if (error) {\r\n                return cb(error, null);\r\n            }\r\n            r.db(s.database).tableList().run(client, function (error) {\r\n                if (error && /database(.*)does\\s+not\\s+exist/i.test(error.message)) {\r\n                    r.dbCreate(s.database).run(client, function (error) {\r\n                        client.use(s.database);\r\n                        cb(null, client);\r\n                    });\r\n                } else {\r\n                    client.use(s.database);\r\n                    cb(null, client);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    schema.adapter = new RethinkDB(s, schema);\r\n    schema.adapter.pool = gpool.Pool({\r\n        name: \"caminte-rethink-pool\",\r\n        create: connect,\r\n        destroy: function (client) {\r\n            client.close();\r\n        },\r\n        max: s.poolMax || 10,\r\n        min: s.poolMin || 1,\r\n        idleTimeoutMillis: 30000,\r\n        log: function (what, level) {\r\n            if (level === \"error\") {\r\n                fs.appendFile(\"caminte-rethink-pool.log\", what + \"\\r\\n\");\r\n            }\r\n        }\r\n    });\r\n    process.nextTick(callback);\r\n};\r\n\r\nfunction RethinkDB(s, schema) {\r\n    this.name = 'rethink';\r\n    this._models = {};\r\n    this._foreignKeys = {};\r\n    this.collections = {};\r\n    this.schema = schema;\r\n    this.settings = s;\r\n    this.database = s.database;\r\n}\r\n\r\nRethinkDB.prototype.connect = function (cb) {\r\n    cb(); // connection pooling handles it\r\n};\r\n\r\nRethinkDB.prototype.define = function (descr) {\r\n    if (!descr.settings)\r\n        descr.settings = {};\r\n    this._models[descr.model.modelName] = descr;\r\n    this._foreignKeys[descr.model.modelName] = [];\r\n};\r\n\r\n// creates tables if not exists\r\nRethinkDB.prototype.autoupdate = function (callback) {\r\n    var self = this;\r\n    r.connect({host: self.settings.host, port: self.settings.port}, function (err, client) {\r\n        if (err) {\r\n            return callback && callback(err);\r\n        }\r\n        r.db(self.database).tableList().run(client, function (err, cursor) {\r\n            if (!err && cursor) {\r\n                cursor.toArray(function (err, list) {\r\n                    if (err) {\r\n                        return callback && callback(err);\r\n                    }\r\n                    var timeout = 0;\r\n                    async.eachSeries(Object.keys(self._models), function (model, cb) {\r\n                        var fields = self._models[model].properties;\r\n                        if (list.length === 0 || list.indexOf(model) < 0) {\r\n                            r.db(self.database).tableCreate(model).run(client, function (error) {\r\n                                if (error) {\r\n                                    return cb(error);\r\n                                }\r\n                                timeout = 150;\r\n                                process.nextTick(function() {\r\n                                    self.ensureIndex(model, fields, {}, cb);\r\n                                });\r\n                            });\r\n                        } else {\r\n                            process.nextTick(function() {\r\n                                self.ensureIndex(model, fields, {}, cb);\r\n                            });\r\n                        }\r\n                    }, function (err) {\r\n                        setTimeout(function() {\r\n                            client.close(function() {\r\n                                callback(err);\r\n                            });\r\n                        }, timeout);\r\n                    });\r\n                });\r\n            } else {\r\n                client.close(function() {\r\n                    callback(err);\r\n                });\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.ensureIndex = function (model, fields, params, callback) {\r\n    var self = this, indexes = [];\r\n    var properties = fields || self._models[model].properties;\r\n    if (Object.keys(properties).length > 0) {\r\n        r.connect({host: self.settings.host, port: self.settings.port}, function (err, client) {\r\n            if (err) {\r\n                return callback && callback(err);\r\n            }\r\n            Object.keys(properties).forEach(function (property) {\r\n                if ((properties[property].unique || properties[property].index || self._foreignKeys[model].indexOf(property) >= 0)) {\r\n                    indexes.push(property);\r\n                }\r\n            });\r\n            var len = indexes.length;\r\n            if(len === 0) {\r\n                return callback && callback();\r\n            }\r\n            r.db(self.database).table(model).indexList().run(client, function (err, cursor) {\r\n                if (err || !cursor) {\r\n                    return callback && callback(err);\r\n                }\r\n                cursor.toArray(function (err, list) {\r\n                    if (err) {\r\n                        return callback && callback(err);\r\n                    }\r\n                    indexes.forEach(function(index){\r\n                        if(list.indexOf(index) === -1){\r\n                            r.db(self.database).table(model).indexCreate(index).run(client, function (error) {\r\n                                if (error) {\r\n                                    return callback && callback(error);\r\n                                }\r\n                                if (--len === 0) {\r\n                                    process.nextTick(function() {\r\n                                        client.close(function() {\r\n                                            return callback && callback();\r\n                                        });\r\n                                    });\r\n                                }\r\n                            });\r\n                        } else {\r\n                            if (--len === 0) {\r\n                                process.nextTick(function() {\r\n                                    client.close(function() {\r\n                                        return callback && callback();\r\n                                    });\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    } else {\r\n        return callback && callback();\r\n    }\r\n};\r\n\r\n// drops tables and re-creates them\r\nRethinkDB.prototype.automigrate = function (callback) {\r\n    this.autoupdate(callback);\r\n};\r\n\r\n// checks if database needs to be actualized\r\nRethinkDB.prototype.isActual = function (callback) {\r\n    var self = this;\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        r.db(self.database).tableList().run(client, function (error, cursor) {\r\n            if (!error) {\r\n                if (cursor.next()) {\r\n                    cursor.toArray(function (error, list) {\r\n                        if (error) {\r\n                            self.pool.release(client);\r\n                            return callback(error);\r\n                        }\r\n                        var actual = true;\r\n                        async.each(Object.keys(self._models), function (model, cb) {\r\n                            if (!actual) {\r\n                                return cb();\r\n                            }\r\n                            var properties = self._models[model].properties;\r\n                            if (list.indexOf(model) < 0) {\r\n                                actual = false;\r\n                                cb();\r\n                            } else {\r\n                                r.db(self.database).table(model).indexList().run(client, function (error, cursor) {\r\n                                    if (error) {\r\n                                        return cb(error);\r\n                                    }\r\n                                    cursor.toArray(function (error, list) {\r\n                                        if (error) {\r\n                                            return cb(error);\r\n                                        }\r\n                                        Object.keys(properties).forEach(function (property) {\r\n                                            if ((properties[property].index || self._foreignKeys[model].indexOf(property) >= 0) && list.indexOf(property) < 0) {\r\n                                                actual = false;\r\n                                            }\r\n                                        });\r\n                                        cb();\r\n                                    });\r\n                                });\r\n                            }\r\n                        }, function (err) {\r\n                            self.pool.release(client);\r\n                            callback(err, actual);\r\n                        });\r\n                    });\r\n                } else if (self._models.length > 0) {\r\n                    self.pool.release(client);\r\n                    callback(null, false);\r\n                }\r\n            } else {\r\n                self.pool.release(client);\r\n                callback(error);\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.defineForeignKey = function (name, key, cb) {\r\n    this._foreignKeys[name].push(key);\r\n    cb(null, String);\r\n};\r\n\r\nRethinkDB.prototype.create = function (model, data, callback) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error)\r\n            throw error;\r\n\r\n        if (data.id === null || data.id === undefined) {\r\n            delete data.id;\r\n        }\r\n        Object.keys(data).forEach(function (key) {\r\n            if (data[key] instanceof Date) {\r\n                data[key] = moment(data[key]).unix();\r\n            }\r\n            if (data[key] === undefined) {\r\n                data[key] = null;\r\n            }\r\n        });\r\n        r.db(self.database).table(model).insert(data).run(client, function (err, m) {\r\n            self.pool.release(client);\r\n            err = err || m.first_error && new Error(m.first_error);\r\n            if (m.generated_keys) {\r\n                data.id = m.generated_keys[0];\r\n            }\r\n            callback(err, err ? null : data.id);\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.save = function (model, data, callback) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error)\r\n            throw error;\r\n\r\n        Object.keys(data).forEach(function (key) {\r\n            if (data[key] instanceof Date)\r\n                data[key] = moment(data[key]).unix();\r\n            if (data[key] === undefined)\r\n                data[key] = null;\r\n        });\r\n        r.db(self.database).table(model).insert(data, {conflict: 'replace'}).run(client, function (err, notice) {\r\n            self.pool.release(client);\r\n            err = err || notice.first_error && new Error(notice.first_error);\r\n            callback(err, notice);\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.exists = function (model, id, callback) {\r\n    var self = this;\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        r.db(self.database).table(model).get(id).run(client, function (err, data) {\r\n            self.pool.release(client);\r\n            callback(err, !!(!err && data));\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.findById = function findById(model, id, callback) {\r\n    var self = this;\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        r.db(self.database).table(model).get(id).run(client, function (err, data) {\r\n            if (data)\r\n                Object.keys(data).forEach(function (key) {\r\n                    if (self._models[model].properties[key]['type']['name'] === \"Date\")\r\n                        data[key] = moment.unix(data[key]).toDate();\r\n                }.bind(self));\r\n            self.pool.release(client);\r\n            callback(err, data);\r\n        }.bind(self));\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.updateOrCreate = function updateOrCreate(model, data, callback) {\r\n    var self = this;\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        if (data.id === null || data.id === undefined) {\r\n            delete data.id;\r\n        }\r\n        data.forEach(function (value, key) {\r\n            if (value instanceof Date) {\r\n                data[key] = moment(value).unix();\r\n            }\r\n            if (value === undefined) {\r\n                data[key] = null;\r\n            }\r\n        });\r\n        r.db(self.database).table(model).insert(data, {conflict: 'replace'}).run(client, function (err, m) {\r\n            self.pool.release(client);\r\n            err = err || m.first_error && new Error(m.first_error);\r\n            callback(err, err ? null : m['generated_keys'][0]);\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.destroy = function destroy(model, id, callback) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error)\r\n            throw error;\r\n\r\n        r.db(self.database).table(model).get(id).delete().run(client, function (error, result) {\r\n            self.pool.release(client);\r\n            callback(error);\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.remove = function remove(model, filter, callback) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error)\r\n            throw error;\r\n\r\n        if (!filter) {\r\n            filter = {};\r\n        }\r\n\r\n        var promise = r.db(self.database).table(model);\r\n\r\n        if (filter.where) {\r\n            promise = _processWhere(self, model, filter.where, promise);\r\n        }\r\n\r\n        if (filter.skip) {\r\n            promise = promise.skip(filter.skip);\r\n        } else if (filter.offset) {\r\n            promise = promise.skip(filter.offset);\r\n        }\r\n        if (filter.limit) {\r\n            promise = promise.limit(filter.limit);\r\n        }\r\n\r\n        _keys = self._models[model].properties;\r\n        _model = self._models[model].model;\r\n\r\n        promise.delete().run(client, function (error, cursor) {\r\n            self.pool.release(client);\r\n            callback(error);\r\n        });\r\n    }, 0); // high-priority pooling\r\n};\r\n\r\nRethinkDB.prototype.all = function all(model, filter, callback) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error)\r\n            throw error;\r\n\r\n        if (!filter) {\r\n            filter = {};\r\n        }\r\n\r\n        var promise = r.db(self.database).table(model);\r\n\r\n        if (filter.where) {\r\n            promise = _processWhere(self, model, filter.where, promise);\r\n        }\r\n\r\n        if (filter.order) {\r\n            var keys = filter.order;\r\n            if (typeof keys === 'string') {\r\n                keys = keys.split(',');\r\n            }\r\n            keys.forEach(function (key) {\r\n                var m = key.match(/\\s+(A|DE)SC$/);\r\n                key = key.replace(/\\s+(A|DE)SC$/, '').trim();\r\n                if (m && m[1] === 'DE') {\r\n                    promise = promise.orderBy(r.desc(key));\r\n                } else {\r\n                    promise = promise.orderBy(r.asc(key));\r\n                }\r\n            });\r\n        } else {\r\n            // default sort by id\r\n            promise = promise.orderBy(r.asc(\"id\"));\r\n        }\r\n\r\n        if (filter.skip) {\r\n            promise = promise.skip(filter.skip);\r\n        } else if (filter.offset) {\r\n            promise = promise.skip(filter.offset);\r\n        }\r\n        if (filter.limit) {\r\n            promise = promise.limit(filter.limit);\r\n        }\r\n\r\n        _keys = self._models[model].properties;\r\n        _model = self._models[model].model;\r\n\r\n        promise.run(client, function (error, cursor) {\r\n            if (error) {\r\n                self.pool.release(client);\r\n                callback(error, null);\r\n            }\r\n            cursor.toArray(function (err, data) {\r\n                if (err) {\r\n                    self.pool.release(client);\r\n                    return callback(err);\r\n                }\r\n\r\n                data.forEach(function (element, index) {\r\n                    Object.keys(element).forEach(function (key) {\r\n                        if (!_keys.hasOwnProperty(key))\r\n                            return;\r\n                        if (_keys[key]['type']['name'] === \"Date\")\r\n                            element[key] = moment.unix(element[key]).toDate();\r\n                    });\r\n                    data[index] = element;\r\n                });\r\n\r\n                self.pool.release(client);\r\n\r\n                if (filter && filter.include && filter.include.length > 0) {\r\n                    _model.include(data, filter.include, callback);\r\n                } else {\r\n                    callback(null, data);\r\n                }\r\n            });\r\n        });\r\n    }, 0); // high-priority pooling\r\n};\r\n\r\nRethinkDB.prototype.destroyAll = function destroyAll(model, callback) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error)\r\n            throw error;\r\n        r.db(self.database).table(model).delete().run(client, function (error, result) {\r\n            self.pool.release(client);\r\n            callback(error, result);\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.count = function count(model, callback, where) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        var promise = r.db(self.database).table(model);\r\n\r\n        if (where && typeof where === \"object\") {\r\n            promise = _processWhere(self, model, where, promise);\r\n        }\r\n        promise.count().run(client, function (err, count) {\r\n            self.pool.release(client);\r\n            callback(err, count);\r\n        });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\r\n    var self = this;\r\n\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        data.id = id;\r\n        Object.keys(data).forEach(function (key) {\r\n            if (data[key] instanceof Date) {\r\n                data[key] = moment(data[key]).unix();\r\n            }\r\n            if (data[key] === undefined) {\r\n                data[key] = null;\r\n            }\r\n        });\r\n        r.db(self.database)\r\n            .table(model)\r\n            .update(data)\r\n            .run(client, function (err, object) {\r\n                self.pool.release(client);\r\n                cb(err, data);\r\n            });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.update = function (model, filter, data, cb) {\r\n    var self = this;\r\n    self.pool.acquire(function (error, client) {\r\n        if (error) {\r\n            throw error;\r\n        }\r\n        r.db(self.database).table(model)\r\n            .filter(filter)\r\n            .update(data)\r\n            .run(client, function (err, object) {\r\n                self.pool.release(client);\r\n                cb(err, data);\r\n            });\r\n    });\r\n};\r\n\r\nRethinkDB.prototype.disconnect = function () {\r\n    var self = this;\r\n    self.pool.drain(function () {\r\n        self.pool.destroyAllNow();\r\n    });\r\n};\r\n\r\nfunction _processWhere(self, model, where, promise) {\r\n    //Transform promise (a rethinkdb query) based on the given where clause.\r\n    //Returns the modified promise\r\n    var i, m, keys;\r\n    var indexed = false;\r\n    var queryParts = [];\r\n    var queryExtra = [];\r\n    Object.keys(where).forEach(function (k) {\r\n        var spec, cond = where[k];\r\n        var allConds = [];\r\n        if (cond && cond.constructor.name === 'Object') {\r\n            keys = Object.keys(cond);\r\n            for (i = 0, m = keys.length; i < m; i++) {\r\n                allConds.push([keys[i], cond[keys[i]]]);\r\n            }\r\n        }\r\n        else {\r\n            allConds.push([false, cond]);\r\n        }\r\n        var hasIndex = self._models[model].properties[k].index || self._foreignKeys[model].indexOf(k) >= 0;\r\n        for (i = 0, m = allConds.length; i < m; i++) {\r\n            spec = allConds[i][0];\r\n            cond = allConds[i][1];\r\n            if (cond instanceof Date) {\r\n                cond = moment(cond).unix();\r\n            }\r\n            switch (spec) {\r\n                case false:\r\n                    if (!indexed && hasIndex) {\r\n                        promise = promise.getAll(cond, {index: k});\r\n                        indexed = true;\r\n                    } else {\r\n                        queryParts.push(r.row(k).eq(cond));\r\n                    }\r\n                    break;\r\n                case 'between':\r\n                    queryParts.push(r.row(k).ge(cond[0]).and(r.row(k).le(cond[1])));\r\n                    break;\r\n                case 'in':\r\n                case 'inq':\r\n                    var expr1 = '(function(row) { return ' + JSON.stringify(cond) + '.indexOf(row.' + k + ') >= 0 })';\r\n                    queryExtra.push(r.js(expr1));\r\n                    break;\r\n                case 'nin':\r\n                    var expr2 = '(function(row) { return ' + JSON.stringify(cond) + '.indexOf(row.' + k + ') === -1 })';\r\n                    queryExtra.push(r.js(expr2));\r\n                    break;\r\n                case 'gt':\r\n                    queryParts.push(r.row(k).gt(cond));\r\n                    break;\r\n                case 'gte':\r\n                    queryParts.push(r.row(k).ge(cond));\r\n                    break;\r\n                case 'lt':\r\n                    queryParts.push(r.row(k).lt(cond));\r\n                    break;\r\n                case 'lte':\r\n                    queryParts.push(r.row(k).le(cond));\r\n                    break;\r\n                case 'ne':\r\n                case 'neq':\r\n                    queryParts.push(r.row(k).ne(cond));\r\n                    break;\r\n            }\r\n        }\r\n    });\r\n\r\n    var query;\r\n    queryParts.forEach(function (comp) {\r\n        if (!query) {\r\n            query = comp;\r\n        } else {\r\n            query = query.and(comp);\r\n        }\r\n    });\r\n    if (query) {\r\n        promise = promise.filter(query);\r\n    }\r\n    queryExtra.forEach(function (comp) {\r\n        promise = promise.filter(comp);\r\n    });\r\n\r\n    return promise;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/riak.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar riak = safeRequire('riak-js');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    schema.client = riak.getClient({\n        host: schema.settings.host || '127.0.0.1',\n        port: schema.settings.port || 8098\n    });\n\n    var instrument = {\n        'riak.request.start': function (event) {\n            console.log('[riak-js] ' + event.method.toUpperCase() + ' ' + event.path);\n        }\n    }\n\n    schema.client.registerListener(instrument);\n    schema.adapter = new Riak(schema.settings, schema, callback);\n};\n\nfunction Riak(s, schema, callback) {\n    this.name = 'riak';\n    this._models = {};\n    this._secondaryIndexes = {};\n    this.collections = {};\n    this.client = schema.client;\n    this.schema = schema;\n    this.s = s;\n    this.database = s.database || '';\n    process.nextTick(callback);\n}\n\nRiak.prototype.define = function (descr) {\n    var self = this;\n    var prop = descr.properties || {};\n    for (var key in prop) {\n        if (typeof this._secondaryIndexes[descr.model.modelName] === 'undefined') {\n            this._secondaryIndexes[descr.model.modelName] = {};\n        }\n        if (prop[key].index || prop[key].unique) {\n            this._secondaryIndexes[descr.model.modelName][key] = prop[key].type.name;\n        }\n    }\n    self.client.getBucket(descr.model.modelName, function (err, properties) {\n        self.client.saveBucket(descr.model.modelName, {\n            allow_mult: false,\n            search: true\n        });\n    });\n    self._models[descr.model.modelName] = descr;\n};\n\nRiak.prototype.save = function (model, data, callback) {\n    var self = this;\n    var opts = self.buildIndexes(model, data);\n    if (data.id) {\n        self.client.save(model, data.id, data, opts, callback);\n    } else {\n        self.client.save(model, null, data, function (err, obj, meta) {\n            data.id = meta.key;\n            self.client.save(model, data.id, data, opts, callback);\n        });\n    }\n};\n\nRiak.prototype.create = function (model, data, callback) {\n    this.save(model, data, function (err) {\n        if (callback) {\n            callback(err, data.id);\n        }\n    });\n};\n\nRiak.prototype.exists = function (model, id, callback) {\n    this.client.exists(model, id, function (err, exists, meta) {\n        if (callback) {\n            callback(err, exists);\n        }\n    });\n};\n\nRiak.prototype.findById = function findById(model, id, callback) {\n    this.client.get(model, id, callback);\n};\n\nRiak.prototype.destroy = function destroy(model, id, callback) {\n    this.client.remove(model, id, callback);\n};\n\nRiak.prototype.remove = function (model, filter, callback) {\n    var self = this;\n    self.all(model, filter, function (err, docs) {\n        if (docs) {\n            removeOne();\n            function removeOne(error) {\n                err = err || error;\n                var rec = docs.pop();\n                if (!rec) {\n                    return callback(err && err.statusCode !== '404' ? err : null);\n                }\n                self.client.remove(model, rec.id, removeOne);\n            }\n        } else {\n            callback(err);\n        }\n    });\n};\n\nRiak.prototype.all = function all(model, filter, callback) {\n    var self = this, where;\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n    var opts = {\n        start: 0\n    };\n    if (filter && filter.where) {\n        where = self.buildWhere(model, filter.where);\n    }\n    if (filter && filter.limit) {\n        opts.rows = filter.limit;\n    }\n    if (filter && filter.skip) {\n        opts.start = filter.skip;\n    }\n    if (filter && filter.order && filter.order !== \"\") {\n        var orderOpts = (filter.order || \"\").split(' ');\n        var orderFields = (orderOpts[0] || \"\").split(',');\n        opts.sort = orderFields[0];\n    }\n    self.client.getAll(model, {}, opts, function (err, result, meta) {\n        if (err) {\n            return callback(err, []);\n        }\n\n        /*, result\n         result = (result || []).map(function(row) {\n         // console.log(row);\n         return row;\n         });result\n         */\n        return callback(err, result);\n    }.bind(this));\n};\n\nRiak.prototype.destroyAll = function destroyAll(model, callback) {\n    var self = this;\n    self.all(model, {}, function (err, recs) {\n        if (err) {\n            callback(err);\n        }\n        removeOne();\n\n        function removeOne(error) {\n            err = err || error;\n            var rec = recs.pop();\n            if (!rec) {\n                return callback(err && err.statusCode !== '404' ? err : null);\n            }\n            console.log(rec.id);\n            self.client.remove(model, rec.id, removeOne);\n        }\n    });\n};\n\nRiak.prototype.count = function count(model, callback) {\n    this.client.count(model, callback);\n};\n\nRiak.prototype.updateAttributes = function updateAttrs(model, id, data, callback) {\n    data.id = id;\n    this.save(model, data, callback);\n};\n\nRiak.prototype.buildIndexes = function buildIndexes(model, data) {\n    var idx = this._secondaryIndexes[model], opts = {};\n    for (var key in data) {\n        if (typeof idx[key] !== 'undefined') {\n            var val = data[key];\n            if (idx[key] === 'Number' || idx[key] === 'Date') {\n                val = parseInt(val);\n                if (!isNaN(val)) {\n                    opts[key] = val;\n                }\n            } else {\n                if (val !== null) {\n                    opts[key] = val;\n                }\n            }\n        }\n    }\n    return Object.keys(opts).length ? {index: opts} : {};\n};\n\nRiak.prototype.buildWhere = function buildWhere(model, data) {\n    var idx = this._secondaryIndexes[model], opts = {};\n    for (var key in data) {\n        if (typeof idx[key] !== 'undefined') {\n            var val = data[key];\n            if (idx[key] === 'Number' || idx[key] === 'Date') {\n                if (typeof val === 'object') {\n                    var cond = this.buildCond(key, val);\n                    if (cond[key]) {\n                        opts[key] = cond[key];\n                    }\n                } else {\n                    val = parseInt(val);\n                    if (!isNaN(val)) {\n                        opts[key] = val;\n                    }\n                }\n            } else {\n                if (val !== null) {\n                    opts[key] = val;\n                }\n            }\n        }\n    }\n    return Object.keys(opts).length ? opts : {};\n};\n\nRiak.prototype.buildCond = function buildCond(key, conds) {\n    var outs = {};\n    console.log(conds)\n    Object.keys(conds).forEach(function (condType) {\n        var val = conds[condType];\n        val = (val.getTime) ? val.getTime() : val;\n        switch (condType) {\n            case 'gt':\n                outs[key] = [parseInt(val) + 1, -1];\n                break;\n            case 'gte':\n                outs[key] = [parseInt(val), -1];\n                break;\n            case 'lt':\n                outs[key] = [-1, parseInt(val)];\n                break;\n            case 'lte':\n                outs[key] = [-1, parseInt(val) - 1];\n                break;\n            case 'between':\n                outs[key] = conds[condType];\n                break;\n            case 'inq':\n            case 'in':\n\n                break;\n            case 'nin':\n\n                break;\n            case 'neq':\n            case 'ne':\n\n                break;\n            case 'regex':\n            case 'like':\n\n                break;\n            case 'nlike':\n\n                break;\n            default:\n\n                break;\n        }\n    });\n    return outs;\n};\n\nRiak.prototype.fullModelName = function fullModelName(name) {\n    return this.database + '_' + name;\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/sqlite3.js":"/**\n * Module dependencies\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar sqlite3 = safeRequire('sqlite3');\nvar util = require('util');\nvar BaseSQL = require('../sql');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!sqlite3) {\n        return;\n    }\n    var s = schema.settings;\n    var Database = sqlite3.verbose().Database;\n    var db = new Database(s.database);\n\n    schema.client = db;\n    schema.adapter = new SQLite3(schema, schema.client);\n    schema.client.run('PRAGMA encoding = \"UTF-8\"', function () {\n        if (s.database === ':memory:') {\n            schema.adapter.automigrate(callback);\n        } else {\n            process.nextTick(callback);\n        }\n    });\n};\n\nfunction SQLite3(schema, client) {\n    this.name = 'sqlite3';\n    this._models = {};\n    this.client = client;\n    this.schema = schema;\n}\n\nutil.inherits(SQLite3, BaseSQL);\n\nSQLite3.prototype.query = function (sql, callback) {\n    this.queryAll(sql, callback);\n};\n\nSQLite3.prototype.command = function () {\n    this.run('run', [].slice.call(arguments));\n};\n\nSQLite3.prototype.execSql = function () {\n    this.run('exec', [].slice.call(arguments));\n};\n\nSQLite3.prototype.queryAll = function () {\n    this.run('all', [].slice.call(arguments));\n};\n\nSQLite3.prototype.queryOne = function () {\n    this.run('get', [].slice.call(arguments));\n};\n\nSQLite3.prototype.run = function (method, args) {\n    var time = Date.now();\n    var log = this.log;\n    var cb = args.pop();\n    if (typeof cb === 'function') {\n        args.push(function (err, data) {\n            if (log)\n                log(args[0], time);\n            cb.call(this, err, data);\n        });\n    } else {\n        args.push(cb);\n        args.push(function (err, data) {\n            log(args[0], time);\n        });\n    }\n    this.client[method].apply(this.client, args);\n};\n\nSQLite3.prototype.save = function (model, data, callback) {\n    var queryParams = [];\n    var sql = 'UPDATE ' + this.tableEscaped(model) + ' SET ' +\n        Object.keys(data).map(function (key) {\n            queryParams.push(data[key]);\n            return key + ' = ?';\n        }).join(', ') + ' WHERE id = ' + data.id;\n    this.command(sql, queryParams, function (err) {\n        callback(err);\n    });\n};\n\n/**\n * Must invoke callback(err, id)\n * @param {Object} model\n * @param {Object} data\n * @param {Function} callback\n */\nSQLite3.prototype.create = function (model, data, callback) {\n    data = data || {};\n    var questions = [];\n    var values = Object.keys(data).map(function (key) {\n        questions.push('?');\n        return data[key];\n    });\n    var sql = 'INSERT INTO ' + this.tableEscaped(model) + ' (' + Object.keys(data).join(',') + ') VALUES (';\n    sql += questions.join(',');\n    sql += ')';\n    this.command(sql, values, function (err) {\n        callback(err, this && this.lastID);\n    });\n};\n\nSQLite3.prototype.updateOrCreate = function (model, filter, data, callback) {\n    filter = filter || {};\n    var self = this, Model = self._models[model].model;\n    self.all(model, {where: filter}, function (err, found) {\n        if (err || (found && found.length > 1)) {\n            return callback(err || new Error(\"Found multiple instances\"));\n        }\n        if (found && found.length === 1) {\n            var inst = self.fromDatabase(model, found[0]);\n            var obj = new Model();\n            obj._initProperties(inst, false);\n            obj.updateAttributes(data, function (err) {\n                callback(err, obj);\n            });\n        } else {\n            Object.keys(filter).forEach(function (key) {\n                data[key] = filter[key];\n            });\n            self.create(model, data, callback)\n        }\n    });\n};\n/**\n * Update rows\n * @param {String} model\n * @param {Object} filter\n * @param {Object} data\n * @param {Function} callback\n */\nSQLite3.prototype.update = function (model, filter, data, callback) {\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parametrs undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parametrs undefined\"), null);\n    }\n    filter = filter.where ? filter.where : filter;\n    var self = this;\n    var combined = [];\n    var queryParams = [];\n    var props = self._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key] || key === 'id') {\n            var k = '`' + key + '`';\n            var v;\n            if (key !== 'id') {\n                v = self.toDatabase(props[key], data[key]);\n            } else {\n                v = data[key];\n            }\n            combined.push(k + ' = ' + v);\n        }\n    });\n\n    var sql = 'UPDATE ' + self.tableEscaped(model);\n    sql += ' SET ' + combined.join(', ');\n    sql += ' ' + self.buildWhere(filter, self, model);\n    self.command(sql, queryParams, function (err, affected) {\n        return callback && callback(err, affected || 0);\n    });\n};\n\nSQLite3.prototype.toFields = function (model, data) {\n    var self = this, fields = [];\n    var props = this._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        if (props[key]) {\n            fields.push('`' + key.replace(/\\./g, '`.`') + '` = ' + self.toDatabase(props[key], data[key]));\n        }\n    }.bind(self));\n    return fields.join(',');\n};\n\nSQLite3.prototype.toDatabase = function (prop, val) {\n    if (val === null || val === undefined) {\n        return 'NULL';\n    }\n    if (val.constructor.name === 'Object') {\n        var operator = Object.keys(val)[0];\n        val = val[operator];\n        if (operator === 'between') {\n            if (prop.type.name === 'Date') {\n                return 'strftime(' + this.toDatabase(prop, val[0]) + ')' +\n                    ' AND strftime(' +\n                    this.toDatabase(prop, val[1]) + ')';\n            } else {\n                return this.toDatabase(prop, val[0]) +\n                    ' AND ' +\n                    this.toDatabase(prop, val[1]);\n            }\n        } else if (operator === 'in' || operator === 'inq' || operator === 'nin') {\n            if (!(val.propertyIsEnumerable('length')) && typeof val === 'object' && typeof val.length === 'number') { //if value is array\n                for (var i = 0; i < val.length; i++) {\n                    val[i] = this.escape(val[i]);\n                }\n                return val.join(',');\n            } else {\n                return val;\n            }\n        }\n    }\n    if (!prop)\n        return val;\n    if (prop.type.name === 'Number' || prop.type.name === 'Integer' || prop.type.name === 'Real')\n        return val;\n    if (prop.type.name === 'Date') {\n        if (!val) {\n            return 'NULL';\n        }\n        if (!val.toUTCString) {\n            val = new Date(val).getTime();\n        } else if (val.getTime) {\n            val = val.getTime();\n        }\n        return val;\n    }\n    if (prop.type.name === \"Boolean\") {\n        return val ? 1 : 0;\n    }\n    val = val.toString();\n    return /^\"(?:\\\\\"|.)*?\"$/gi.test(val) ? val : this.escape(val);\n};\n\nSQLite3.prototype.fromDatabase = function (model, data) {\n    var self = this;\n    if (!data) {\n        return null;\n    }\n    var props = self._models[model].properties;\n    Object.keys(data).forEach(function (key) {\n        var val = data[key], type = (props[key].type.name || '').toString().toLowerCase();\n        if (props[key]) {\n            if (type === 'json' && typeof val == \"string\") {\n                if ((props[key].type.name || '').toString().toLowerCase() === 'json' && typeof val == \"string\") {\n                    try {\n                        data[key] = JSON.parse(val);\n                    } catch (err) {\n                        data[key] = val;\n                    }\n                }\n            } else if (type === 'date') {\n                if (!val) {\n                    val = null;\n                }\n                if (typeof val === 'string') {\n                    val = val.split('.')[0].replace('T', ' ');\n                    val = Date.parse(val);\n                }\n                if (typeof val === 'number') {\n                    val = new Date(val);\n                }\n\n                data[key] = val;\n            } else {\n                data[key] = val;\n            }\n        }\n    });\n    return data;\n};\n\nSQLite3.prototype.escape = function (val) {\n    return typeof val === 'string' ? '\"' + val + '\"' : val;\n};\n\nSQLite3.prototype.escapeName = function (name) {\n    return '`' + name + '`';\n};\n\nSQLite3.prototype.exists = function (model, id, callback) {\n    var sql = 'SELECT 1 FROM ' + this.tableEscaped(model) + ' WHERE id = ' + id + ' LIMIT 1';\n    this.queryOne(sql, function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        callback(null, data && data['1'] === 1);\n    });\n};\n\nSQLite3.prototype.findById = function findById(model, id, callback) {\n    var sql = 'SELECT * FROM ' + this.tableEscaped(model) + ' WHERE id = ' + id + ' LIMIT 1';\n    this.queryOne(sql, function (err, data) {\n        if (data) {\n            data.id = id;\n        } else {\n            data = null;\n        }\n        callback(err, this.fromDatabase(model, data));\n    }.bind(this));\n};\n\nSQLite3.prototype.all = function all(model, filter, callback) {\n    if ('function' === typeof filter) {\n        callback = filter;\n        filter = {};\n    }\n    if (!filter) {\n        filter = {};\n    }\n\n    var sql = 'SELECT * FROM ' + this.tableEscaped(model);\n    var self = this, queryParams = [];\n\n    if (filter) {\n        if (filter.where) {\n            sql += ' ' + this.buildWhere(filter.where, self, model);\n        }\n        if (filter.order) {\n            sql += ' ' + this.buildOrderBy(filter.order);\n        }\n\n        if (filter.group) {\n            sql += ' ' + self.buildGroupBy(filter.group);\n        }\n\n        if (filter.limit) {\n            sql += ' ' + this.buildLimit(filter.limit, filter.offset || filter.skip || 0);\n        }\n    }\n    self.queryAll(sql, function (err, data) {\n        if (err) {\n            return callback(err, []);\n        }\n        data = data.map(function (obj) {\n            return self.fromDatabase(model, obj);\n        }.bind(self));\n        return callback && callback(null, data);\n    }.bind(self));\n};\n\nSQLite3.prototype.disconnect = function disconnect() {\n    this.client.close();\n};\n\nSQLite3.prototype.autoupdate = function (cb) {\n    var self = this;\n    var wait = 0;\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.queryAll('PRAGMA TABLE_INFO(' + self.tableEscaped(model) + ');', function (err, fields) {\n            if (err) done(err);\n            self.queryAll('PRAGMA INDEX_LIST(' + self.tableEscaped(model) + ');', function (err, indexes) {\n                if (err) done(err);\n                if (!err && fields.length) {\n                    self.alterTable(model, fields, indexes, done);\n                } else {\n                    self.createTable(model, indexes, done);\n                }\n            });\n        });\n    });\n\n    function done(err) {\n        if (err) {\n            console.log(err);\n        }\n        if (--wait === 0 && cb) {\n            cb(err);\n        }\n    }\n};\n\nSQLite3.prototype.isActual = function (cb) {\n    var ok = false;\n    var self = this;\n    var wait = 0;\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.queryAll('PRAGMA TABLE_INFO(' + self.tableEscaped(model) + ')', function (err, fields) {\n            self.queryAll('PRAGMA INDEX_LIST(' + self.tableEscaped(model) + ')', function (err, indexes) {\n                if (!err && fields.length) {\n                    self.alterTable(model, fields, indexes, done, true);\n                }\n            });\n        });\n    });\n\n    function done(err, needAlter) {\n        if (err) {\n            console.log(err);\n        }\n        ok = ok || needAlter;\n        if (--wait === 0 && cb) {\n            cb(null, !ok);\n        }\n    }\n};\n\nSQLite3.prototype.alterTable = function (model, actualFields, indexes, done, checkOnly) {\n    var self = this, m = self._models[model];\n    var defIndexes = m.settings.indexes;\n    var propNames = Object.keys(m.properties);\n    var sql = [], isql = [], reBuild = false;\n\n    // change/add new fields\n    propNames.forEach(function (propName) {\n        if (propName === 'id') {\n            return;\n        }\n        var found;\n        actualFields.forEach(function (f) {\n            if (f.name === propName) {\n                found = f;\n            }\n        });\n        if (found) {\n            actualize(propName, found);\n        } else {\n            if (m.properties[propName] !== false) {\n                sql.push('ADD COLUMN `' + propName + '` ' + self.propertySettingsSQL(model, propName));\n            }\n        }\n    });\n\n    // drop columns\n    actualFields.forEach(function (f) {\n        var notFound = !~propNames.indexOf(f.name);\n        if (f.name === 'id') {\n            return;\n        }\n        if (notFound || !m.properties[f.name]) {\n            reBuild = true;\n        }\n    });\n\n    for (var fieldName in m.properties) {\n        var idx = m.properties[fieldName];\n        if ('undefined' !== typeof idx['index']\n            || 'undefined' !== typeof idx['unique']) {\n            var foundKey = false, UNIQ = '',\n                kuniq = !idx['unique'] ? 0 : idx['unique'],\n                ikey = (model + '_' + fieldName).toString();\n            kuniq = kuniq === false ? 0 : 1;\n            if (idx['index'] !== false) {\n                indexes.forEach(function (index) {\n                    if (ikey === index.name) {\n                        if (index.unique !== kuniq) {\n                            UNIQ = kuniq === 1 ? ' UNIQUE ' : '';\n                            isql.push('DROP INDEX `' + ikey + '`;');\n                            // isql.push('CREATE ' + UNIQ + ' INDEX `' + ikey + '` ON ' + self.tableEscaped(model) + ' (`' + fieldName + '` ASC);');\n                            reBuild = true;\n                        }\n                        foundKey = index.name;\n                    }\n                });\n\n                if (!foundKey) {\n                    UNIQ = 'undefined' !== typeof m.properties[fieldName]['unique'] ? ' UNIQUE ' : '';\n                    isql.push('CREATE ' + UNIQ + ' INDEX `' + ikey + '` ON ' + self.tableEscaped(model) + ' (`' + fieldName + '` ASC);');\n                }\n            } else {\n                reBuild = true;\n            }\n        }\n    }\n\n    if (defIndexes) {\n        for (var fieldName in defIndexes) {\n            var foundKey = false, ikey = (model + '_' + fieldName).toString();\n            indexes.forEach(function (index) {\n                if (ikey === index.name) {\n                    foundKey = index.name;\n                }\n            });\n\n            if (!foundKey) {\n                var fields = [], columns = defIndexes[fieldName]['columns'] || [];\n                if (Object.prototype.toString.call(columns) === '[object Array]') {\n                    fields = columns;\n                } else if (typeof columns === 'string') {\n                    columns = (columns || '').replace(/,/g,' ').split(/\\s+/);\n                }\n                if (columns.length) {\n                    columns = columns.map(function (column) {\n                        return '`'+column.replace(/,/g,'') + '` ASC';\n                    });\n                    var UNIQ = 'undefined' !== typeof defIndexes[fieldName]['unique'] ? ' UNIQUE ' : '';\n                    isql.push('CREATE ' + UNIQ + ' INDEX `' + ikey + '` ON ' + self.tableEscaped(model) + ' (' + columns.join(',') + ');');\n                }\n            }\n        }\n    }\n\n    var tSql = [];\n    if (sql.length) {\n        tSql.push('ALTER TABLE ' + self.tableEscaped(model) + ' ' + sql.join(',\\n'));\n    }\n    if (isql.length) {\n        tSql = tSql.concat(isql);\n    }\n\n    if (tSql.length) {\n        if (checkOnly) {\n            return done(null, true, {\n                statements: tSql,\n                query: ''\n            });\n        } else {\n            var tlen = tSql.length;\n            tSql.forEach(function (tsql) {\n                return self.command(tsql, function (err) {\n                    if (err) console.log(err, tsql);\n                    if (--tlen === 0) {\n                        if (reBuild) {\n                            return rebuid(model, m.properties, actualFields, indexes, done);\n                        } else {\n                            return done();\n                        }\n                    }\n                });\n            });\n        }\n    } else {\n        if (checkOnly) {\n            return done(null, reBuild, {\n                statements: tSql,\n                query: ''\n            });\n        } else {\n            if (reBuild) {\n                return rebuid(model, m.properties, actualFields, indexes, done);\n            } else {\n                return done && done();\n            }\n        }\n    }\n\n    function actualize(propName, oldSettings) {\n        var newSettings = m.properties[propName];\n        if (newSettings && changed(newSettings, oldSettings)) {\n            reBuild = true;\n        }\n    }\n\n    function changed(newSettings, oldSettings) {\n        var dflt_value = (newSettings.default || null);\n        var notnull = (newSettings.null === false ? 1 : 0);\n        if (oldSettings.notnull !== notnull\n            || oldSettings.dflt_value !== dflt_value) {\n            return true;\n        }\n        if (oldSettings.type.toUpperCase() !== datatype(newSettings)) {\n            return true;\n        }\n        return false;\n    }\n\n    function rebuid(model, oldSettings, newSettings, indexes, done) {\n        var nsst = [];\n        if (newSettings) {\n            newSettings.forEach(function (newSetting) {\n                if (oldSettings[newSetting.name] !== false) {\n                    nsst.push(newSetting.name);\n                }\n            });\n        }\n        var rbSql = 'ALTER TABLE `' + model + '` RENAME TO `tmp_' + model + '`;';\n        var inSql = 'INSERT INTO `' + model + '` (' + nsst.join(',') + ') '\n            + 'SELECT ' + nsst.join(',') + ' FROM `tmp_' + model + '`;';\n        var dpSql = 'DROP TABLE `tmp_' + model + '`;';\n\n        return self.command(rbSql, function (err) {\n            if (err) console.log(err, rbSql);\n            return self.createTable(model, indexes, function (err) {\n                if (err) console.log('createTable', err);\n                return self.command(inSql, function (err) {\n                    if (err) console.log(err, inSql);\n                    return self.command(dpSql, function () {\n                        if (err) console.log(err, dpSql);\n                        self.createIndexes(model, self._models[model], done)\n                    });\n                });\n            });\n        });\n    }\n};\n\n/**\n * Create multi column index callback(err, index)\n * @param {Object} model\n * @param {Object} fields\n * @param {Object} params\n * @param {Function} callback\n */\nSQLite3.prototype.ensureIndex = function (model, fields, params, done) {\n    var self = this, sql = \"\", keyName = params.name || null, afld = [], kind = \"\";\n    Object.keys(fields).forEach(function (field) {\n        if (!keyName) {\n            keyName = model + '_' + field;\n        }\n        afld.push('`' + field + '` ASC');\n    });\n    if (params.unique) {\n        kind = \"UNIQUE\";\n    }\n    sql += 'CREATE ' + kind + ' INDEX `' + keyName + '` ON ' + self.tableEscaped(model) + ' (' + afld.join(', ') + ')';\n    self.command(sql, done);\n};\n\n/**\n * Create index callback(err, index)\n * @param {Object} model\n * @param {Object} fields\n * @param {Object} params\n * @param {Function} callback\n */\nSQLite3.prototype.createIndexes = function (model, props, done) {\n    var self = this, sql = [], m = props, s = m.settings;\n    for (var fprop in m.properties) {\n        var idx = m.properties[fprop];\n        if ('undefined' !== typeof idx['index']\n            || 'undefined' !== typeof idx['unique']) {\n            if (idx['index'] !== false) {\n                var UNIQ = 'undefined' !== typeof m.properties[fprop]['unique'] ? ' UNIQUE ' : '';\n                sql.push('CREATE ' + UNIQ + ' INDEX `' + model + '_' + fprop + '` ON ' + self.tableEscaped(model) + ' (`' + fprop + '` ASC)');\n            }\n        }\n    }\n\n    if (s.indexes) {\n        for (var tprop in s.indexes) {\n            var fields = [], columns = s.indexes[tprop]['columns'] || [];\n            if (Object.prototype.toString.call(columns) === '[object Array]') {\n                fields = columns;\n            } else if (typeof columns === 'string') {\n                columns = (columns || '').replace(',', ' ').split(/\\s+/);\n            }\n            if (columns.length) {\n                columns = columns.map(function (column) {\n                    return '`' + column + '` ASC';\n                });\n                var UNIQ = 'undefined' !== typeof s.indexes[tprop]['unique'] ? ' UNIQUE ' : '';\n                sql.push(' CREATE ' + UNIQ + ' INDEX `' + model + '_' + tprop + '` ON ' + self.tableEscaped(model) + ' (' + columns.join(', ') + ')');\n            }\n        }\n    }\n\n    if (sql.length) {\n        var tsqls = sql.length;\n        sql.forEach(function (query) {\n            self.command(query, function () {\n                if (--tsqls === 0) done();\n            });\n        });\n    } else {\n        done();\n    }\n};\n\nSQLite3.prototype.propertiesSQL = function (model) {\n    var self = this, id = false, sql = [], props = Object.keys(self._models[model].properties);\n    var primaryKeys = this._models[model].settings.primaryKeys || [];\n    primaryKeys = primaryKeys.slice(0);\n    props.forEach(function (prop) {\n        if (prop === 'id') {\n            return;\n        }\n        if (self._models[model].properties[prop] !== false) {\n            return sql.push('`' + prop + '` ' + self.propertySettingsSQL(model, prop));\n        }\n    });\n\n    if (primaryKeys.length) {\n        for (var i = 0, length = primaryKeys.length; i < length; i++) {\n            if (props.indexOf(primaryKeys[i]) === -1) {\n                if (primaryKeys[i] === 'id') {\n                    id = true;\n                    sql.push('`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL');\n                } else {\n                    sql.push('`' + primaryKeys[i].toString().replace(/,\\s|,/,'`,`') + '` ' + self.propertySettingsSQL(model, primaryKeys[i]));\n                }\n            }\n        }\n        if (!id) {\n            sql.push('PRIMARY KEY (`' + primaryKeys.join('`,`') + '`)');\n        }\n    } else {\n        if (!id) {\n            sql.push('`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL');\n        }\n    }\n    return sql.join(',\\n  ');\n};\n\nSQLite3.prototype.propertySettingsSQL = function (model, prop) {\n    'use strict';\n    var p = this._models[ model ].properties[ prop ], field = [];\n\n    field.push( datatype( p ) );\n    field.push( p.allowNull === false || (typeof p[ 'default' ] !== 'undefined' && acceptedDefaults( p )) ? 'NOT NULL' : 'NULL' );\n    if ( typeof p[ 'default' ] !== 'undefined' && acceptedDefaults( p ) && typeof p[ 'default' ] !== 'function' ) {\n        field.push( 'DEFAULT ' + getDefaultValue( p ) );\n    }\n    if ( p.unique === true ) {\n        field.push( 'UNIQUE' );\n    }\n\n    return field.join( \" \" );\n};\n\nfunction acceptedDefaults(prop) {\n    'use strict';\n    if ( /^INT|^BIGINT|^VAR|^TINY/i.test( datatype( prop ) ) ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction getDefaultValue(prop) {\n    'use strict';\n    if ( /^INT|^BIGINT/i.test( prop.Type || datatype( prop ) ) ) {\n        return parseInt( prop[ 'default' ] || prop[ 'Default' ] || 0 );\n    } else if ( /^TINY/i.test( prop.Type || datatype( prop ) ) ) {\n        return prop[ 'default' ] || prop[ 'Default' ] ? 1 : 0;\n    } else {\n        return \"'\" + (prop[ 'default' ] || prop[ 'Default' ] || '') + \"'\";\n    }\n}\n\nfunction datatype(p) {\n    switch ((p.type.name || 'string').toLowerCase()) {\n        case 'string':\n        case 'varchar':\n            return 'VARCHAR(' + (p.limit || 255) + ')';\n        case 'int':\n        case 'integer':\n        case 'number':\n            return 'INTEGER(' + (p.limit || 11) + ')';\n        case 'real':\n        case 'float':\n        case 'double':\n            return 'REAL';\n        case 'date':\n        case 'timestamp':\n            return 'DATETIME';\n        case 'boolean':\n        case 'bool':\n            return 'BOOL';\n        default:\n            return 'TEXT';\n    }\n}\n\nSQLite3.prototype.buildWhere = function buildWhere(conds, adapter, model) {\n    var cs = [], or = [],\n        self = adapter,\n        props = self._models[model].properties;\n\n    Object.keys(conds).forEach(function (key) {\n        if (key !== 'or') {\n            cs = parseCond(cs, key, props, conds, self);\n        } else {\n            conds[key].forEach(function (oconds) {\n                Object.keys(oconds).forEach(function (okey) {\n                    or = parseCond(or, okey, props, oconds, self);\n                });\n            });\n        }\n    });\n\n    if (cs.length === 0 && or.length === 0) {\n        return '';\n    }\n    var orop = \"\";\n    if (or.length) {\n        orop = ' (' + or.join(' OR ') + ') ';\n    }\n    orop += (orop !== \"\" && cs.length > 0) ? ' AND ' : '';\n    return 'WHERE ' + orop + cs.join(' AND ');\n};\n\nfunction parseCond(cs, key, props, conds, self) {\n    var keyEscaped = '`' + key.replace(/\\./g, '`.`') + '`';\n    var val = self.toDatabase(props[key], conds[key]);\n    if (conds[key] === null || conds[key] === undefined) {\n        cs.push(keyEscaped + ' IS NULL');\n    } else if (conds[key].constructor.name === 'Object') {\n        Object.keys(conds[key]).forEach(function (condType) {\n            var inq = 'in,inq,nin'.indexOf(condType) > -1 ? 1 : 0;\n            val = self.toDatabase(props[key], conds[key][condType]);\n            var sqlCond = keyEscaped;\n            if (inq === 1 && val.length === 0) {\n                cs.push(condType === 'inq' ? 0 : 1);\n                return true;\n            }\n            switch (condType) {\n                case 'gt':\n                    sqlCond += ' > ';\n                    break;\n                case 'gte':\n                    sqlCond += ' >= ';\n                    break;\n                case 'lt':\n                    sqlCond += ' < ';\n                    break;\n                case 'lte':\n                    sqlCond += ' <= ';\n                    break;\n                case 'between':\n                    sqlCond += ' BETWEEN ';\n                    val = self.toDatabase(props[key], conds[key]);\n                    break;\n                case 'inq':\n                case 'in':\n                    sqlCond += ' IN ';\n                    break;\n                case 'nin':\n                    sqlCond += ' NOT IN ';\n                    break;\n                case 'neq':\n                case 'ne':\n                    sqlCond += ' != ';\n                    break;\n                case 'regex':\n                    sqlCond += ' REGEXP ';\n                    break;\n                case 'like':\n                    val = (val || '').replace(new RegExp('%25', 'gi'), '%');\n                    sqlCond += ' LIKE ';\n                    break;\n                case 'nlike':\n                    val = (val || '').replace(new RegExp('%25', 'gi'), '%');\n                    sqlCond += ' NOT LIKE ';\n                    break;\n                default:\n                    sqlCond += ' ' + condType + ' ';\n                    break;\n            }\n            sqlCond += inq === 1 ? '(' + val + ')' : val;\n            cs.push(sqlCond);\n        });\n    } else {\n        cs.push(keyEscaped + ' = ' + val);\n    }\n    return cs;\n}\n\nSQLite3.prototype.buildOrderBy = function buildOrderBy(order) {\n    if (typeof order === 'string') {\n        order = [order];\n    }\n    return 'ORDER BY ' + order.join(', ');\n};\n\nSQLite3.prototype.buildLimit = function buildLimit(limit, offset) {\n    return 'LIMIT ' + (offset ? (offset + ', ' + limit) : limit);\n};\n\nSQLite3.prototype.buildGroupBy = function buildGroupBy(group) {\n    if (typeof group === 'string') {\n        group = [group];\n    }\n    return 'GROUP BY ' + group.join(', ');\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/adapters/tingodb.js":"/**\n * Module dependencies\n * mongodb adapter with a few tweaks to run tingodb\n */\nvar utils = require('../utils');\nvar safeRequire = utils.safeRequire;\nvar tingodb = safeRequire('tingodb');\nvar fs = require('fs');\n\nexports.initialize = function initializeSchema(schema, callback) {\n    if (!tingodb) {\n        return;\n    }\n    var s = schema.settings;\n    s.database = s.database || './db/data';\n    s.nativeObjectID = s.nativeObjectID || false;\n    s.cacheSize = s.cacheSize || 1000;\n    s.cacheMaxObjSize = s.cacheMaxObjSize || 1024;\n    s.searchInArray = s.searchInArray || false;\n\n    if (!fs.existsSync(s.database)) {\n        console.log('Database directory not exists ' + s.database + ', please create!');\n    }\n\n    schema.adapter = new TingoDB(s, schema, callback);\n};\n\nfunction TingoDB(s, schema, callback) {\n    this.name = 'tingodb';\n    this._models = {};\n    this.collections = {};\n    this.settings = s;\n    var Db = tingodb().Db;\n    this.db = new Db(s.database, s);\n    this.db.open(function (err, client) {\n        if (err) {\n            throw err;\n        }\n        if (client) {\n            this.client = client;\n            schema.client = client;\n            callback();\n        } else {\n            throw new Error('client not loaded');\n        }\n    }.bind(this));\n}\n\nTingoDB.prototype.define = function (descr) {\n    if (!descr.settings) {\n        descr.settings = {};\n    }\n    var self = this;\n    self._models[descr.model.modelName] = descr;\n    self.collections[descr.model.modelName] = self.db.collection(descr.model.modelName);\n    setTimeout(function () {\n        Object.keys(descr.properties).forEach(function (k) {\n            if (typeof descr.properties[k].index !== 'undefined' || typeof descr.properties[k].unique !== 'undefined') {\n                var fields = {}, params = {};\n                fields[k] = 1;\n                params['name'] = '_' + k + '_';\n                if (typeof descr.properties[k].unique !== 'undefined') {\n                    params['unique'] = true;\n                }\n                self.collection(descr.model.modelName).ensureIndex(fields, params);\n            }\n        });\n    }, 1000);\n};\n\nTingoDB.prototype.autoupdate = function (callback) {\n    var self = this;\n    var settings = self.settings;\n    if (!fs.existsSync(settings.database)) {\n        console.log('Database directory not exists ' + settings.database + ', please create!');\n        return callback && callback();\n    } else {\n        setTimeout(function () {\n            return callback && callback();\n        }, 1000);\n    }\n};\n\nTingoDB.prototype.defineProperty = function (model, prop, params) {\n    this._models[model].properties[prop] = params;\n};\n\nTingoDB.prototype.collection = function (name) {\n    var self = this;\n    if (!self.collections[name]) {\n        self.collections[name] = self.client.collection(self.client, name);\n    }\n    return self.collections[name];\n};\n\nTingoDB.prototype.ensureIndex = function (model, fields, params, callback) {\n    this.collection(model).ensureIndex(fields, params);\n    return callback(null);\n};\n\nTingoDB.prototype.create = function (model, data, callback) {\n    if (data.id === null) {\n        delete data.id;\n    }\n    this.collection(model).insert(data, {}, function (err, m) {\n        return callback && callback(err, err ? null : m[0]._id);\n    });\n};\n\nTingoDB.prototype.save = function (model, data, callback) {\n    var id = data.id;\n    this.collection(model).update({_id: id}, data, function (err) {\n        callback(err);\n    });\n};\n\nTingoDB.prototype.update = function (model, filter, data, callback) {\n    if ('function' === typeof filter) {\n        return filter(new Error(\"Get parametrs undefined\"), null);\n    }\n    if ('function' === typeof data) {\n        return data(new Error(\"Set parametrs undefined\"), null);\n    }\n    filter = filter.where ? filter.where : filter;\n    this.collection(model).update(filter, data, function (err) {\n        callback(err);\n    });\n};\n\nTingoDB.prototype.exists = function (model, id, callback) {\n    this.collection(model).findOne({_id: id}, function (err, data) {\n        callback(err, !err && data);\n    });\n};\n\nTingoDB.prototype.findById = function findById(model, id, callback) {\n    this.collection(model).findOne({_id: id}, function (err, data) {\n        if (data) {\n            data.id = id;\n        }\n        callback(err, data);\n    });\n};\n\nTingoDB.prototype.updateOrCreate = function updateOrCreate(model, data, callback) {\n    var adapter = this;\n    if (!data.id) {\n        return this.create(data, callback);\n    }\n    this.findById(model, data.id, function (err, inst) {\n        if (err)\n            return callback(err);\n        if (inst) {\n            adapter.updateAttributes(model, data.id, data, callback);\n        } else {\n            delete data.id;\n            adapter.create(model, data, function (err, id) {\n                if (err)\n                    return callback(err);\n                if (id) {\n                    data.id = id;\n                    delete data._id;\n                    callback(null, data);\n                } else {\n                    callback(null, null); // wtf?\n                }\n            });\n        }\n    });\n};\n\nTingoDB.prototype.destroy = function destroy(model, id, callback) {\n    this.collection(model).remove({_id: id}, callback);\n};\n\nTingoDB.prototype.remove = function remove(model, filter, callback) {\n    var cond = buildWhere(filter.where);\n    this.collection(model).remove(cond, callback);\n};\n\nTingoDB.prototype.all = function all(model, filter, callback) {\n    if (!filter) {\n        filter = {};\n    }\n    var query = {};\n    if (filter.where) {\n        query = buildWhere(filter.where);\n    }\n    var cursor = this.collection(model).find(query);\n\n    if (filter.order) {\n        var keys = filter.order;\n        if (typeof keys === 'string') {\n            keys = keys.split(',');\n        }\n        var args = {};\n        for (var index in keys) {\n            var m = keys[index].match(/\\s+(A|DE)SC$/);\n            var key = keys[index];\n            key = key.replace(/\\s+(A|DE)SC$/, '').trim();\n            if (m && m[1] === 'DE') {\n                args[key] = -1;\n            } else {\n                args[key] = 1;\n            }\n        }\n        cursor.sort(args);\n    }\n    if (filter.limit) {\n        cursor.limit(filter.limit);\n    }\n    if (filter.skip) {\n        cursor.skip(filter.skip);\n    } else if (filter.offset) {\n        cursor.skip(filter.offset);\n    }\n    cursor.toArray(function (err, data) {\n        if (err)\n            return callback(err);\n        callback(null, data.map(function (o) {\n            o.id = o._id;\n            return o;\n        }));\n    });\n};\n\nTingoDB.prototype.destroyAll = function destroyAll(model, callback) {\n    this.collection(model).remove({}, callback);\n};\n\nTingoDB.prototype.count = function count(model, callback, filter) {\n    var cond = buildWhere(filter);\n    this.collection(model).count(cond, callback);\n};\n\nTingoDB.prototype.updateAttributes = function updateAttrs(model, id, data, callback) {\n    this.collection(model).findAndModify({_id: id}, [['_id', 'asc']], {$set: data}, {}, callback);\n};\n\nTingoDB.prototype.disconnect = function () {\n    this.client.close();\n};\n\nfunction buildWhere(filter) {\n    var query = {};\n    Object.keys(filter).forEach(function (k) {\n        var cond = filter[k];\n        var spec = false;\n        if (k === 'id') {\n            k = '_id';\n        }\n        if (cond && cond.constructor.name === 'Object') {\n            spec = Object.keys(cond)[0];\n            cond = cond[spec];\n        }\n        if (spec) {\n            if (spec === 'between') {\n                query[k] = {$gte: cond[0], $lte: cond[1]};\n            } else {\n                query[k] = {};\n                spec = spec === 'inq' ? 'in' : spec;\n                spec = spec === 'like' ? 'regex' : spec;\n                if (spec === 'nlike') {\n                    query[k]['$not'] = new RegExp(cond, 'i');\n                } else {\n                    query[k]['$' + spec] = cond;\n                }\n            }\n        } else {\n            if (cond === null) {\n                query[k] = {$type: 10};\n            } else {\n                query[k] = cond;\n            }\n        }\n    });\n    return query;\n}\n"}