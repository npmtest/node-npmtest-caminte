{"/home/travis/build/npmtest/node-npmtest-caminte/test.js":"/* istanbul instrument in package npmtest_caminte */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-caminte/lib.npmtest_caminte.js":"/* istanbul instrument in package npmtest_caminte */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_caminte = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_caminte = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-caminte/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-caminte && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_caminte */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_caminte\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_caminte.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_caminte.rollup.js'] =\n            local.assetsDict['/assets.npmtest_caminte.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_caminte.__dirname +\n                    '/lib.npmtest_caminte.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/index.js":"/**\n * Module dependencies\n */\nvar schema = require('./lib/schema');\nvar pkg = require('./package');\nvar abc = require('./lib/abstract-class');\nvar vld = require('./lib/validatable');\nvar Schema = schema.Schema;\n\nexports.schema = {models:{}};\nexports.Schema = Schema;\nexports.AbstractClass = abc.AbstractClass;\nexports.Validatable = vld.Validatable;\nexports.__defineGetter__('BaseSQL', function () {\n    return require('./lib/sql');\n});\n\nexports.init = function (trinte) {\n    if (global.trinte) {\n        global.trinte.orm = exports;\n    } else {\n        trinte.orm = {Schema: exports.Schema, AbstractClass: exports.AbstractClass};\n    }\n};\n\nexports.model = function (name){\n    return this.schema.models[name.toLowerCase()];\n};\n\nexports.version = pkg.version;\n\nexports.__defineGetter__('test', function () {\n    return require('./tmp/tests/common_test');\n});\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/schema.js":"/**\r\n * Module dependencies\r\n */\r\nvar utils = require('./utils');\r\nvar ainst = require('./abstract-class');\r\nvar AbstractClass = ainst.AbstractClass;\r\nvar getState = utils.getState;\r\nvar util = require('util');\r\nvar path = require('path');\r\nvar events = require('events');\r\nvar fs = require('fs');\r\nvar existsSync = fs.existsSync || path.existsSync;\r\n\r\n/**\r\n * Export public API\r\n */\r\nexports.Schema = Schema;\r\n\r\n/**\r\n * Helpers\r\n */\r\nvar slice = Array.prototype.slice;\r\n\r\n/**\r\n * Schema - adapter-specific classes factory.\r\n *\r\n * All classes in single schema shares same adapter type and\r\n * one database connection\r\n *\r\n * @param name - type of schema adapter (mysql, mongoose, sequelize, redis)\r\n * @param settings - any database-specific settings which we need to\r\n * establish connection (of course it depends on specific adapter)\r\n *\r\n * - host\r\n * - port\r\n * - username\r\n * - password\r\n * - database\r\n * - debug {Boolean} = false\r\n *\r\n * @example Schema creation, waiting for connection callback\r\n * ```\r\n * var schema = new Schema('mysql', { database: 'myapp_test' });\r\n * schema.define(...);\r\n * schema.on('connected', function () {\r\n *     // work with database\r\n * });\r\n * ```\r\n */\r\nfunction Schema(name, settings) {\r\n    var schema = this;\r\n\r\n    name = name ? name.toLowerCase() : \"\";\r\n    switch (name) {\r\n        case 'sqlite':\r\n            name = 'sqlite3';\r\n            break;\r\n        case 'mysqldb':\r\n        case 'mariadb':\r\n            name = 'mysql';\r\n            break;\r\n        case 'mongo':\r\n            name = 'mongodb';\r\n            break;\r\n        case 'couchdb':\r\n        case 'couch':\r\n            name = 'nano';\r\n            break;\r\n        case 'rethinkdb':\r\n        case 'rethink':\r\n            name = 'rethinkdb';\r\n            break;\r\n    }\r\n\r\n    // just save everything we get\r\n    schema.name = name;\r\n    schema.settings = settings;\r\n\r\n    // Disconnected by default\r\n    schema.connected = false;\r\n\r\n    // create blank models pool\r\n    schema.models = {};\r\n    schema.definitions = {};\r\n\r\n    // define schema types\r\n    schema.Text = function Text() {\r\n    };\r\n    schema.JSON = schema.Json = function JSON() {\r\n    };\r\n    schema.Float = function Float() {\r\n    };\r\n    schema.Real = schema.Double = function Real() {\r\n    };\r\n    schema.Int = schema.Integer = function Integer() {\r\n    };\r\n    schema.UUID = schema.Uuid = function UUID() {\r\n    };\r\n    schema.TimeUUID = schema.TimeUuid = function TimeUUID() {\r\n    };\r\n    schema.CounterColumn = function CounterColumn() {\r\n    };\r\n    schema.Blob = schema.Bytes = function Blob() {\r\n    };\r\n\r\n    schema.Date = schema.Timestamp = Date;\r\n    schema.Boolean = schema.Tinyint = Boolean;\r\n    schema.Number = Number;\r\n    schema.String = schema.Varchar = String;\r\n    // and initialize schema using adapter\r\n    // this is only one initialization entry point of adapter\r\n    // this module should define `adapter` member of `this` (schema)\r\n    var adapter;\r\n    if (typeof name === 'object') {\r\n        adapter = name;\r\n        schema.name = adapter.name;\r\n    } else if (name.match(/^\\//)) {\r\n        // try absolute path\r\n        adapter = require(name);\r\n    } else if (existsSync(__dirname + '/adapters/' + name + '.js')) {\r\n        // try built-in adapter\r\n        adapter = require('./adapters/' + name);\r\n    } else {\r\n        try {\r\n            adapter = require('caminte-' + name);\r\n        } catch (e) {\r\n            throw new Error('Adapter ' + name + ' is not defined, try\\n  npm install ' + name);\r\n        }\r\n    }\r\n\r\n    adapter.initialize(schema, function () {\r\n\r\n        // we have an adaper now?\r\n        if (!schema.adapter) {\r\n            throw new Error('Adapter is not defined correctly: it should create `adapter` member of schema');\r\n        }\r\n\r\n        schema.adapter.log = function (query, start) {\r\n            schema.log(query, start);\r\n        };\r\n\r\n        schema.adapter.logger = function (query) {\r\n            'use strict';\r\n            var t1 = Date.now();\r\n            var log = schema.log;\r\n            return function (q) {\r\n                log(q || query, t1);\r\n            };\r\n        };\r\n        var res = getState(schema);\r\n        if (util.isError(res)) {\r\n            schema.emit('error', res);\r\n        } else {\r\n            schema.connected = true;\r\n            schema.emit('connected');\r\n        }\r\n    }.bind(schema));\r\n}\r\n\r\nutil.inherits(Schema, events.EventEmitter);\r\n\r\nSchema.Text = function Text() {\r\n};\r\nSchema.JSON = function JSON() {\r\n};\r\n/**\r\n * Define class\r\n *\r\n * @param {String} className\r\n * @param {Object} properties - hash of class properties in format\r\n *   `{property: Type, property2: Type2, ...}`\r\n *   or\r\n *   `{property: {type: Type}, property2: {type: Type2}, ...}`\r\n * @param {Object} settings - other configuration of class\r\n * @return newly created class\r\n *\r\n * @example simple case\r\n * ```\r\n * var User = schema.define('User', {\r\n *     email: String,\r\n *     password: String,\r\n *     birthDate: Date,\r\n *     activated: Boolean\r\n * });\r\n * ```\r\n * @example more advanced case\r\n * ```\r\n * var User = schema.define('User', {\r\n *     email: { type: String, limit: 150, index: true },\r\n *     password: { type: String, limit: 50 },\r\n *     birthDate: Date,\r\n *     registrationDate: {type: Date, default: function () { return new Date }},\r\n *     activated: { type: Boolean, default: false }\r\n * });\r\n * ```\r\n */\r\nSchema.prototype.define = function defineClass(className, properties, settings) {\r\n    'use strict';\r\n    var schema = this;\r\n    var args = slice.call(arguments);\r\n\r\n    if (!className) {\r\n        throw new Error('Class name required');\r\n    }\r\n    if (args.length === 1) {\r\n        properties = {}, args.push(properties);\r\n    }\r\n    if (args.length === 2) {\r\n        settings = {}, args.push(settings);\r\n    }\r\n\r\n    standartize(properties, settings);\r\n\r\n    // every class can receive hash of data as optional param\r\n    var NewClass = function ModelConstructor(data) {\r\n        if (!(this instanceof ModelConstructor)) {\r\n            return new ModelConstructor(data);\r\n        }\r\n        AbstractClass.call(this, data);\r\n    };\r\n\r\n    hiddenProperty(NewClass, 'schema', schema);\r\n    hiddenProperty(NewClass, 'modelName', className);\r\n    hiddenProperty(NewClass, 'cache', {});\r\n    hiddenProperty(NewClass, 'mru', []);\r\n    hiddenProperty(NewClass, 'relations', {});\r\n\r\n    // inherit AbstractClass methods\r\n    for (var i in AbstractClass) {\r\n        NewClass[i] = AbstractClass[i];\r\n    }\r\n    for (var j in AbstractClass.prototype) {\r\n        NewClass.prototype[j] = AbstractClass.prototype[j];\r\n    }\r\n\r\n    NewClass.getter = {};\r\n    NewClass.setter = {};\r\n\r\n    // store class in model pool\r\n    this.models[className] = NewClass;\r\n    this.definitions[className] = {\r\n        properties: properties,\r\n        settings: settings\r\n    };\r\n\r\n    // pass controll to adapter\r\n    this.adapter.define({\r\n        model: NewClass,\r\n        properties: properties,\r\n        settings: settings\r\n    });\r\n\r\n    if (!settings.primaryKeys) {\r\n        NewClass.prototype.__defineGetter__('id', function () {\r\n            return this.__data.id;\r\n        });\r\n        properties.id = properties.id || {type: Number};\r\n    }\r\n\r\n    NewClass.forEachProperty = function (cb) {\r\n        Object.keys(properties).forEach(cb);\r\n    };\r\n\r\n    NewClass.registerProperty = function (attr) {\r\n        Object.defineProperty(NewClass.prototype, attr, {\r\n            get: function () {\r\n                'use strict';\r\n                if (NewClass.getter[attr]) {\r\n                    return NewClass.getter[attr].call(this);\r\n                } else {\r\n                    return this.__data[attr];\r\n                }\r\n            },\r\n            set: function (value) {\r\n                'use strict';\r\n                if (NewClass.setter[attr]) {\r\n                    NewClass.setter[attr].call(this, value);\r\n                } else {\r\n                    this.__data[attr] = value;\r\n                }\r\n            },\r\n            configurable: true,\r\n            enumerable: true\r\n        });\r\n\r\n        NewClass.prototype.__defineGetter__(attr + '_was', function () {\r\n            return this.__dataWas[attr];\r\n        });\r\n\r\n        Object.defineProperty(NewClass.prototype, '_' + attr, {\r\n            get: function () {\r\n                return this.__data[attr];\r\n            },\r\n            set: function (value) {\r\n                this.__data[attr] = value;\r\n            },\r\n            configurable: true,\r\n            enumerable: false\r\n        });\r\n    };\r\n\r\n    NewClass.forEachProperty(NewClass.registerProperty);\r\n\r\n    return NewClass;\r\n};\r\n\r\nfunction standartize(properties, settings) {\r\n    Object.keys(properties).forEach(function (key) {\r\n        var v = properties[key];\r\n        if (\r\n            typeof v === 'function' ||\r\n            typeof v === 'object' && v && v.constructor.name === 'Array'\r\n        ) {\r\n            properties[key] = {type: v};\r\n        }\r\n    });\r\n    // TODO: add timestamps fields\r\n    // when present in settings: {timestamps: true}\r\n    // or {timestamps: {created: 'created_at', updated: false}}\r\n    // by default property names: createdAt, updatedAt\r\n}\r\n/**\r\n * Define single property named `prop` on `model`\r\n *\r\n * @param {String} model - name of model\r\n * @param {String} prop - name of propery\r\n * @param {Object} params - property settings\r\n */\r\nSchema.prototype.defineProperty = function (model, prop, params) {\r\n    this.definitions[model].properties[prop] = params;\r\n    this.models[model].registerProperty(prop);\r\n    if (this.adapter.defineProperty) {\r\n        this.adapter.defineProperty(model, prop, params);\r\n    }\r\n};\r\n\r\n/**\r\n * Extend existing model with bunch of properties\r\n *\r\n * @param {String} model - name of model\r\n * @param {Object} props - hash of properties\r\n *\r\n * Example:\r\n *\r\n *     // Instead of doing this:\r\n *\r\n *     // amend the content model with competition attributes\r\n *     db.defineProperty('Content', 'competitionType', { type: String });\r\n *     db.defineProperty('Content', 'expiryDate', { type: Date, index: true });\r\n *     db.defineProperty('Content', 'isExpired', { type: Boolean, index: true });\r\n *\r\n *     // schema.extend allows to\r\n *     // extend the content model with competition attributes\r\n *     db.extendModel('Content', {\r\n *       competitionType: String,\r\n *       expiryDate: { type: Date, index: true },\r\n *       isExpired: { type: Boolean, index: true }\r\n *     });\r\n */\r\nSchema.prototype.extendModel = function (model, props) {\r\n    var t = this;\r\n    standartize(props, {});\r\n    Object.keys(props).forEach(function (propName) {\r\n        var definition = props[propName];\r\n        t.defineProperty(model, propName, definition);\r\n    });\r\n};\r\n\r\n/**\r\n * Drop each model table and re-create.\r\n * This method make sense only for sql adapters.\r\n * @param {Function} cb\r\n *\r\n * @warning All data will be lost! Use autoupdate if you need your data.\r\n */\r\nSchema.prototype.automigrate = function (cb) {\r\n    this.freeze();\r\n    if (this.adapter.automigrate) {\r\n        this.adapter.automigrate(cb);\r\n    } else if (cb) {\r\n        cb();\r\n    }\r\n};\r\n\r\n/**\r\n * Update existing database tables.\r\n * This method make sense only for sql adapters.\r\n * @param {Function} cb\r\n */\r\nSchema.prototype.autoupdate = function (cb) {\r\n    this.freeze();\r\n    if (this.adapter.autoupdate) {\r\n        this.adapter.autoupdate(cb);\r\n    } else if (cb) {\r\n        cb();\r\n    }\r\n};\r\n\r\n/**\r\n * Check whether migrations needed\r\n * This method make sense only for sql adapters.\r\n * @param {Function} cb\r\n */\r\nSchema.prototype.isActual = function (cb) {\r\n    this.freeze();\r\n    if (this.adapter.isActual) {\r\n        this.adapter.isActual(cb);\r\n    } else if (cb) {\r\n        cb(null, true);\r\n    }\r\n};\r\n\r\n/**\r\n * Log benchmarked message. Do not redefine this method, if you need to grab\r\n * chema logs, use `schema.on('log', ...)` emitter event\r\n * @param {String} sql\r\n * @param {Date} t\r\n *\r\n * @private used by adapters\r\n */\r\nSchema.prototype.log = function (sql, t) {\r\n    this.emit('log', sql, t);\r\n};\r\n\r\n/**\r\n * Freeze schema. Behavior depends on adapter\r\n */\r\nSchema.prototype.freeze = function freeze() {\r\n    if (this.adapter.freezeSchema) {\r\n        this.adapter.freezeSchema();\r\n    }\r\n};\r\n\r\n/**\r\n * Return table name for specified `modelName`\r\n * @param {String} modelName\r\n */\r\nSchema.prototype.tableName = function (modelName) {\r\n    return this.definitions[modelName].settings.table = this.definitions[modelName].settings.table || modelName;\r\n};\r\n\r\n/**\r\n * Define foreign key\r\n * @param {String} className\r\n * @param {String} key - name of key field\r\n */\r\nSchema.prototype.defineForeignKey = function defineForeignKey(className, key) {\r\n    // quit if key already defined\r\n    if (this.definitions[className].properties[key])\r\n        return;\r\n\r\n    if (this.adapter.defineForeignKey) {\r\n        this.adapter.defineForeignKey(className, key, function (err, keyType) {\r\n            if (err)\r\n                throw err;\r\n            this.definitions[className].properties[key] = {type: keyType};\r\n        }.bind(this));\r\n    } else {\r\n        this.definitions[className].properties[key] = {type: Number};\r\n    }\r\n    this.models[className].registerProperty(key);\r\n};\r\n\r\n/**\r\n * Start transaction\r\n *\r\n * @param {Object} params\r\n * @param {Function} callback\r\n */\r\nSchema.prototype.begin = function begin(params, callback) {\r\n    if (typeof callback === 'undefined') {\r\n        callback = function (err) {\r\n            return err;\r\n        };\r\n    }\r\n\r\n    if (typeof this.adapter.begin === 'undefined') {\r\n        callback(new Error('TRANSACTION::begin method not defined for this adapter'));\r\n    } else {\r\n        this.adapter.begin(params, callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Commit transaction\r\n *\r\n * @param {Object} params\r\n * @param {Function} callback\r\n */\r\nSchema.prototype.commit = function commit(params, callback) {\r\n    if (typeof callback === 'undefined') {\r\n        callback = function (err) {\r\n            return err;\r\n        };\r\n    }\r\n\r\n    if (typeof this.adapter.commit === 'undefined') {\r\n        callback(new Error('TRANSACTION::commit method not defined for this adapter'));\r\n    } else {\r\n        this.adapter.commit(params, callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Rollback transaction\r\n *\r\n * @param {Object} params\r\n * @param {Function} callback\r\n */\r\nSchema.prototype.rollback = function rollback(params, callback) {\r\n    if (typeof callback === 'undefined') {\r\n        callback = function (err) {\r\n            return err;\r\n        };\r\n    }\r\n\r\n    if (typeof this.adapter.rollback === 'undefined') {\r\n        callback(new Error('TRANSACTION::rollback method not defined for this adapter'));\r\n    } else {\r\n        this.adapter.rollback(params, callback);\r\n    }\r\n};\r\n\r\n/**\r\n * Close database connection\r\n */\r\nSchema.prototype.disconnect = function disconnect() {\r\n    if (typeof this.adapter.disconnect === 'function') {\r\n        this.connected = false;\r\n        this.adapter.disconnect();\r\n    }\r\n};\r\n\r\n/**\r\n * Returns an array of model names created on this instance of Schema.\r\n *\r\n * ####Note:\r\n *\r\n * _Does not include names of models created using `connection.model()`._\r\n *\r\n * @api public\r\n * @return {Array}\r\n */\r\n\r\nSchema.prototype.modelNames = function () {\r\n    var names = Object.keys(this.models);\r\n    return names;\r\n};\r\n\r\n/**\r\n * Defines a model or retrieves it.\r\n *\r\n * Models defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.\r\n *\r\n * ####Example:\r\n *\r\n *     var mongoose = require('mongoose');\r\n *\r\n *     // define an Actor model with this mongoose instance\r\n *     mongoose.model('Actor', new Schema({ name: String }));\r\n *\r\n *     // create a new connection\r\n *     var conn = mongoose.createConnection(..);\r\n *\r\n *     // retrieve the Actor model\r\n *     var Actor = conn.model('Actor');\r\n *\r\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\r\n *\r\n * ####Example:\r\n *\r\n *     var schema = new Schema({ name: String }, { collection: 'actor' });\r\n *\r\n *     // or\r\n *\r\n *     schema.set('collection', 'actor');\r\n *\r\n *     // or\r\n *\r\n *     var collectionName = 'actor'\r\n *     var M = mongoose.model('Actor', schema, collectionName)\r\n *\r\n * @param {String} name model name\r\n * @param {Schema} [schema]\r\n * @param {String} [collection] name (optional, induced from model name)\r\n * @param {Boolean} [skipInit] whether to skip initialization (defaults to false)\r\n * @api public\r\n */\r\n\r\nSchema.prototype.model = function (name, schema) {\r\n    if ('string' === typeof schema) {\r\n        schema = false;\r\n    }\r\n\r\n    if (typeof schema === 'object') {\r\n        schema = new Schema(schema);\r\n    }\r\n\r\n    var model;\r\n\r\n    // connection.model() may be passing a different schema for\r\n    // an existing model name. in this case don't read from cache.\r\n    if (this.models[name]) {\r\n        model = this.models[name];\r\n    }\r\n\r\n    return model;\r\n};\r\n\r\n/**\r\n * Define hidden property\r\n * @param {Object} where\r\n * @param {String} property\r\n * @param {mixed} value\r\n */\r\nfunction hiddenProperty(where, property, value) {\r\n    Object.defineProperty(where, property, {\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false,\r\n        value: value\r\n    });\r\n}\r\n\r\n/**\r\n * Define readonly property on object\r\n *\r\n * @param {Object} obj\r\n * @param {String} key\r\n * @param {Mixed} value\r\n */\r\nfunction defineReadonlyProp(obj, key, value) {\r\n    Object.defineProperty(obj, key, {\r\n        writable: false,\r\n        enumerable: true,\r\n        configurable: true,\r\n        value: value\r\n    });\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/utils.js":"exports.inherits = function(newClass, baseClass) {\r\n    Object.keys(baseClass).forEach(function(classMethod) {\r\n        newClass[classMethod] = baseClass[classMethod];\r\n    });\r\n    Object.keys(baseClass.prototype).forEach(function(instanceMethod) {\r\n        newClass.prototype[instanceMethod] = baseClass.prototype[instanceMethod];\r\n    });\r\n};\r\n\r\nexports.safeRequire = function safeRequire(module) {\r\n    try {\r\n        return require(module);\r\n    } catch (e) {\r\n        var str = module;\r\n        if(module === 'rethinkdb') { str = module + ' generic-pool moment async'; }\r\n        console.log('Run \"npm install ' + str + '\" command to using ' + module + ' database engine');\r\n        process.exit(1);\r\n    }\r\n};\r\n\r\nexports.getState = function getState(orm) {\r\n    switch (orm.name) {\r\n        case 'mysql':\r\n        case 'mariadb':\r\n            if (orm.client) {\r\n                if (orm.client._protocol) {\r\n                    if (orm.client._protocol._fatalError) {\r\n                        if (orm.client._protocol._fatalError.fatal) {\r\n                            return orm.client._protocol._fatalError;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return true;\r\n};\r\n\r\nexports.helpers = {\r\n    __slice: [].slice,\r\n    __bind: function(fn, me) {\r\n        return function() {\r\n            return fn.apply(me, arguments);\r\n        };\r\n    },\r\n    merge: function(base, update) {\r\n        var k, v;\r\n        if (!base) {\r\n            return update;\r\n        }\r\n        for (k in update) {\r\n            v = update[k];\r\n            base[k] = update[k];\r\n        }\r\n        return base;\r\n    },\r\n    reverse: function(key) {\r\n        var hasOrder = key.match(/\\s+(A|DE)SC$/i);\r\n        if (hasOrder) {\r\n            if (hasOrder[1] === \"DE\") {\r\n                return -1;\r\n            }\r\n        }\r\n        return 1;\r\n    },\r\n    inArray: function(p_val, arr) {\r\n        for (var i = 0, l = arr.length; i < l; i++) {\r\n            if (arr[i] === p_val) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    stripOrder: function(key) {\r\n        return key.replace(/\\s+(A|DE)SC/i, \"\");\r\n    },\r\n    savePrep: function(data) {\r\n        var id = data.id;\r\n        if (id) {\r\n            data._id = id.toString();\r\n        }\r\n        delete data.id;\r\n        if (data._rev === null) {\r\n            return delete data._rev;\r\n        }\r\n    },\r\n    applyFilter: function(filter) {\r\n        var self = this;\r\n        if (typeof filter.where === 'function') {\r\n            return filter.where;\r\n        }\r\n        var keys = Object.keys(filter.where);\r\n        return function(obj) {\r\n            var pass = true;\r\n            keys.forEach(function(key) {\r\n                if (typeof filter.where[key] === 'object' && !filter.where[key].getTime) {\r\n                    pass = self.parseCond(obj[key], filter.where[key]);\r\n                } else {\r\n                    if (!self.testString(filter.where[key], obj[key])) {\r\n                        pass = false;\r\n                    }\r\n                }\r\n            });\r\n            return pass;\r\n        };\r\n    },\r\n    testString: function(example, value) {\r\n        if (typeof value === 'string' && example && example.constructor.name === 'RegExp') {\r\n            return value.match(example);\r\n        }\r\n        // not strict equality\r\n        return (example !== null ? example.toString() : example) === (value !== null ? value.toString() : value);\r\n    },\r\n    parseCond: function(val, conds) {\r\n        var outs = false;\r\n        Object.keys(conds).forEach(function(condType) {\r\n            switch (condType) {\r\n                case 'gt':\r\n                    outs = val > conds[condType] ? true : false;\r\n                    break;\r\n                case 'gte':\r\n                    outs = val >= conds[condType] ? true : false;\r\n                    break;\r\n                case 'lt':\r\n                    outs = val < conds[condType] ? true : false;\r\n                    break;\r\n                case 'lte':\r\n                    outs = val <= conds[condType] ? true : false;\r\n                    break;\r\n                case 'between':\r\n                    var bt = conds[condType];\r\n                    outs = (val >= bt[0] && val <= bt[1]) ? true : false;\r\n                    break;\r\n                case 'inq':\r\n                case 'in':\r\n                    conds[condType].forEach(function(cval) {\r\n                        if (val === cval) {\r\n                            outs = true;\r\n                        }\r\n                    });\r\n                    break;\r\n                case 'nin':\r\n                    outs = true;\r\n                    conds[condType].forEach(function(cval) {\r\n                        if (val === cval) {\r\n                            outs = false;\r\n                        }\r\n                    });\r\n                    break;\r\n                case 'neq':\r\n                case 'ne':\r\n                    outs = val !== conds[condType] ? true : false;\r\n                    break;\r\n                case 'regex':\r\n                case 'like':\r\n                    outs = new RegExp(conds[condType]).test(val);\r\n                    break;\r\n                case 'nlike':\r\n                    outs = !new RegExp(conds[condType]).test(val);\r\n                    break;\r\n                default:\r\n                    outs = val === conds[condType] ? true : false;\r\n                    break;\r\n            }\r\n        });\r\n        return outs;\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/abstract-class.js":"/**\n * Module dependencies\n */\nvar Bluebird = require(\"bluebird\");\nvar vld = require('./validatable');\nvar hkb = require('./hookable');\nvar util = require('util');\nvar utils = require('./utils');\nvar helpers = utils.helpers;\nvar Query = require('./query');\nvar Validatable = vld.Validatable;\nvar List = require('./list');\nvar Hookable = hkb.Hookable;\n// var DEFAULT_CACHE_LIMIT = 1000;\nvar BASE_TYPES = ['String', 'Boolean', 'Number', 'Date', 'Text', 'JSON', 'UUID'];\n\n/**\n * Defer Promise\n * @returns {{resolve: *, reject: *, promise}}\n */\nfunction deferPromise() {\n    var resolve = null, reject = null;\n    var promise = new Bluebird(function () {\n        resolve = arguments[0];\n        reject = arguments[1];\n    });\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise\n    };\n}\n\nexports.AbstractClass = AbstractClass;\n\nif (!Object.prototype.hasOwnProperty('extend')) {\n    Object.defineProperty(Object.prototype, \"extend\", {\n        enumerable: false,\n        writable: true,\n        value: function (from) {\n            var props = Object.getOwnPropertyNames(from);\n            var dest = this;\n            props.forEach(function (name) {\n                if (name in dest) {\n                    var destination = Object.getOwnPropertyDescriptor(from, name);\n                    Object.defineProperty(dest, name, destination);\n                }\n            });\n            return this;\n        }\n    });\n}\n\nAbstractClass.__proto__ = Validatable;\nAbstractClass.prototype.__proto__ = Validatable.prototype;\nutils.inherits(AbstractClass, Hookable);\n\n/**\n * Abstract class - base class for all persist objects\n * provides **common API** to access any database adapter.\n * This class describes only abstract behavior layer, refer to `lib/adapters/*.js`\n * to learn more about specific adapter implementations\n *\n * `AbstractClass` mixes `Validatable` and `Hookable` classes methods\n *\n * @constructor\n * @param {Object} data - initial object data\n */\nfunction AbstractClass(data) {\n    this._initProperties(data, true);\n}\n\nAbstractClass.prototype._initProperties = function (data, applySetters) {\n    var self = this;\n    var ctor = this.constructor;\n    var ds = ctor.schema.definitions[ctor.modelName];\n    var properties = ds.properties;\n    data = data || {};\n\n    Object.defineProperty(this, '__cachedRelations', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__data', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__query', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    Object.defineProperty(this, '__dataWas', {\n        writable: true,\n        enumerable: false,\n        configurable: true,\n        value: {}\n    });\n\n    if (data['__cachedRelations']) {\n        this.__cachedRelations = data['__cachedRelations'];\n    }\n\n    for (var i in data) {\n        this.__data[i] = this.__dataWas[i] = data[i];\n    }\n    if (applySetters && ctor.setter) {\n        Object.keys(ctor.setter).forEach(function (attr) {\n            if (self.__data.hasOwnProperty(attr)) {\n                ctor.setter[attr].call(self, self.__data[attr]);\n            }\n        });\n    }\n\n    ctor.forEachProperty(function (attr) {\n        if (!self.__data.hasOwnProperty(attr)) {\n            self.__data[attr] = self.__dataWas[attr] = getDefault(attr);\n        } else {\n            self.__dataWas[attr] = self.__data[attr];\n        }\n    });\n\n    ctor.forEachProperty(function (attr) {\n        if (properties[attr].type === undefined) {\n            properties[attr].type = String;\n        }\n        var type = properties[attr].type;\n        if (BASE_TYPES.indexOf(type.name) === -1) {\n            if (typeof self.__data[attr] !== 'object' && self.__data[attr]) {\n                try {\n                    self.__data[attr] = JSON.parse(self.__data[attr] + '');\n                } catch (e) {\n                    console.log(type.name, attr, self.__data[attr], e);\n                }\n            }\n            if (type.name === 'Array' || typeof type === 'object' && type.constructor.name === 'Array') {\n                self.__data[attr] = new List(self.__data[attr], type, self);\n            }\n        }\n    });\n\n    function getDefault(attr) {\n        var def = properties[attr]['default'];\n        if (isdef(def)) {\n            if (typeof def === 'function') {\n                return def();\n            } else {\n                return def;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    this.trigger(\"initialize\");\n};\n\n/**\n * @param {String} prop - property name\n * @param {Object} params - various property configuration\n */\nAbstractClass.defineProperty = function (prop, params) {\n    this.schema.defineProperty(this.modelName, prop, params);\n};\n\nAbstractClass.whatTypeName = function (propName) {\n    var ds = this.schema.definitions[this.modelName];\n    return ds.properties[propName] && ds.properties[propName].type.name;\n};\n\nAbstractClass.clone = function clone(o) {\n    var ret = {};\n    Object.keys(o).forEach(function (val) {\n        ret[val] = o[val];\n    });\n    return ret;\n};\n\nAbstractClass._forDB = function (data) {\n    var res = {}, YesSQL = ['mysql', 'sqlite', 'sqlite3', 'firebird', 'memory'];\n    Object.keys(data).forEach(function (propName) {\n        if ((this.whatTypeName(propName) || '').toString().toLowerCase() === 'json'\n            || data[propName] instanceof Array) {\n            if (YesSQL.indexOf(this.schema.adapter.name || this.schema.name) !== -1) {\n                res[propName] = JSON.stringify(data[propName]);\n            } else {\n                res[propName] = data[propName];\n            }\n        } else {\n            res[propName] = data[propName];\n        }\n    }.bind(this));\n    return res;\n};\nAbstractClass.promise = deferPromise;\nAbstractClass.q = {\n    conditions: {},\n    params: {},\n    pkey: false,\n    fields: false\n};\n\nAbstractClass.prototype.whatTypeName = function (propName) {\n    return this.constructor.whatTypeName(propName);\n};\n\nAbstractClass.query = function (data, callback) {\n    if (typeof this.schema.adapter.query === 'undefined') {\n        callback(new Error('Model::query not defined for this adapter'));\n    } else {\n        var p = deferPromise();\n        this.schema.adapter.query(data, function (err, data) {\n            if (err) {\n                p.reject(err);\n            } else {\n                p.resolve(data);\n            }\n            return callback && callback(err, data);\n        });\n        return p.promise;\n    }\n};\n/**\n * Create new instance of Model class, saved in database\n *\n * @param data [optional]\n * @param {Function} callback - callback called with (err, obj)\n * callback called with arguments:\n *\n *   - err (null or Error)\n *   - instance (null or Model)\n */\nAbstractClass.create = function (data, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var modelName = this.modelName;\n    var p = deferPromise();\n\n    if (typeof data === 'function') {\n        callback = data;\n        data = {};\n    }\n\n    if (typeof callback !== 'function') {\n        callback = function () {\n        };\n    }\n\n    var obj = null;\n    // if we come from save\n    if (data instanceof this && !data.id) {\n        obj = data;\n        data = obj.toObject(true);\n        obj._initProperties(data, false);\n        create();\n    } else {\n        obj = new this(data);\n        // validation required\n        obj.isValid(function (valid) {\n            if (!valid) {\n                var err = new Error(modelName + ' validation error');\n                p.reject(err);\n                return callback && callback(err, obj);\n            } else {\n                return create();\n            }\n        });\n    }\n\n    function create() {\n        obj.trigger('create', function (done) {\n            var data = this.toObject(true);  // Added this to fix the beforeCreate trigger not fire.\n            // The fix is per issue #72 and the fix was found by by5739.\n            this._adapter().create(modelName, this.constructor._forDB(data), function (err, id, rev) {\n                if (id) {\n                    obj.__data.id = id;\n                    obj.__dataWas.id = id;\n                    defineReadonlyProp(obj, 'id', id);\n                }\n                if (rev) {\n                    obj._rev = rev;\n                }\n                done.call(this, function () {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(obj);\n                    }\n                    return callback && callback(err, obj);\n                });\n            }.bind(this));\n        });\n    }\n\n    return p.promise;\n};\n\nfunction stillConnecting(schema, obj, args) {\n    if (schema.connected) {\n        return false;\n    }\n    var method = args.callee;\n    schema.on('connected', function () {\n        method.apply(obj, [].slice.call(args));\n    });\n    return true;\n}\n\n/**\n * Update or insert (create)\n * @param {Object} query - object.\n * @param {Object} data - object to find or create.\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.upsert = AbstractClass.updateOrCreate = function upsert(query, data, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        console.log('++++  stillConnecting')\n        return;\n    }\n    if (arguments.length === 1) {\n        return;\n    }\n    if ('function' === typeof data) {\n        callback = data;\n        data = {};\n    }\n    var p = deferPromise();\n    var Model = this;\n\n    if (query.id) {\n        this.findById(query.id, function (err, inst) {\n            if (err) {\n                p.reject(err);\n                return callback && callback(err);\n            }\n            if (inst) {\n                inst.updateAttributes(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(inst);\n                    }\n                    return callback && callback(err);\n                });\n            } else {\n                data = helpers.merge(data, query);\n                var obj = new Model(data);\n                obj.save(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(obj);\n                    }\n                    return callback && callback(err);\n                });\n            }\n        });\n    } else {\n        Model.all({\n            where: query\n        }, function (err, insts) {\n            if (err || (insts && insts.length > 1)) {\n                if (insts.length > 1) {\n                    err = new Error('Found more than one record');\n                    p.reject(err);\n                    return callback && callback(err, insts);\n                }\n                if (err.message && !/NotFound/gi.test(err.message)) {\n                    p.reject(err);\n                    return callback && callback(err, insts);\n                }\n            }\n            if (insts[0]) {\n                var inst = insts[0];\n                inst.updateAttributes(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(inst);\n                    }\n                    return callback && callback(err, inst);\n                });\n            } else {\n                data = helpers.merge(data, query);\n                var obj = new Model(data);\n                obj.save(data, function (err) {\n                    if (err) {\n                        p.reject(err);\n                    } else {\n                        p.resolve(obj);\n                    }\n                    return callback && callback(err, obj);\n                });\n            }\n        });\n    }\n    return p.promise;\n};\n\n/**\n * Find one record, same as `all`, limited by 1 and return object, not collection,\n * if not found, create using data provided as second argument\n *\n * @param {Object} query - search conditions: {where: {test: 'me'}}.\n * @param {Object} data - object to create.\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.findOrCreate = function findOrCreate(query, data, callback) {\n    if (stillConnecting(this.schema, this, arguments))\n        return;\n    if (arguments.length === 1) {\n        return;\n    }\n    if ('function' === typeof data) {\n        callback = data;\n        data = {};\n    }\n    var self = this, p = deferPromise();\n    self.findOne({where: query}, function (err, record) {\n        if (err) {\n            p.reject(err);\n            return callback && callback(err);\n        } else if (record) {\n            p.resolve(record);\n            return callback && callback(null, record);\n        } else {\n            data = helpers.merge(query, data);\n            self.create(data).then(function (record) {\n                p.resolve(record);\n                return callback && callback(null, record);\n            }).catch(function (err) {\n                p.reject(err);\n                return callback && callback(err, null);\n            });\n        }\n    });\n    return p.promise;\n};\n\n/**\n * Check whether object exitst in database\n *\n * @param {id} id - identifier of object (primary key value)\n * @param {Function} callback - callbacl called with (err, exists: Bool)\n */\nAbstractClass.exists = function exists(id, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    if (id) {\n        id = getInstanceId(id);\n        this.schema.adapter.exists(this.modelName, id, function (err, data) {\n            if (err) {\n                p.reject(err);\n            } else {\n                p.resolve(data);\n            }\n            return callback && callback(err, data);\n        });\n    } else {\n        var err = new Error('Model::exists requires positive id argument');\n        p.reject(err);\n        return callback && callback(err);\n    }\n    return p.promise;\n};\n\n/**\n * Find all instances of Model, matched by query\n * make sure you have marked as `index: true` fields for filter or sort\n *\n * @param {Object} params (optional)\n *\n * - where: Object `{ key: val, key2: {gt: 'val2'}}`\n * - include: String, Object or Array. See AbstractClass.include documentation.\n * - order: String\n * - limit: Number\n * - skip: Number\n *\n * @param {Function} callback (required) called with arguments:\n *\n * - err (null or Error)\n * - Array of instances\n */\nAbstractClass.find = AbstractClass.exec = AbstractClass.run = AbstractClass.all = function all(params, callback) {\n    if ('function' === typeof params) {\n        callback = params;\n        params = {};\n    }\n    params = params ? params : {};\n    if (typeof callback === 'undefined' && !params.where && !params.order && !params.limit) {\n        return new Query(this.schema.models[this.modelName], 'all', params);\n    } else {\n        if (stillConnecting(this.schema, this, arguments)) {\n            return null;\n        }\n        var p = deferPromise();\n        params = buildQuery(params, this);\n        var Constr = this;\n        this.schema.adapter.all(this.modelName, params, function (err, data) {\n            if (!err && data && data.map) {\n                data.forEach(function (d, i) {\n                    var obj = new Constr();\n                    obj._initProperties(d, false);\n                    data[i] = obj;\n                });\n                // if (data && data.countBeforeLimit) {\n                //     data['countBeforeLimit'] = data.countBeforeLimit;\n                // }\n                p.resolve(data);\n                return callback && callback(err, data);\n            } else {\n                p.reject(err);\n                return callback && callback(err, []);\n            }\n        });\n        return p.promise;\n    }\n};\n\n/**\n * Find object by id\n *\n * @param {id} id - primary key value\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.findById = function findById(id, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    id = getInstanceId(id);\n    var p = deferPromise();\n    this.schema.adapter.findById(this.modelName, id, function (err, data) {\n        var obj = null;\n        if (data) {\n            if (!data.id) {\n                data.id = id;\n            }\n            obj = new this();\n            obj._initProperties(data, false);\n        }\n        if (err) {\n            p.reject(err);\n        } else {\n            p.resolve(obj);\n        }\n        return callback && callback(err, obj);\n    }.bind(this));\n    return p.promise;\n};\n\n/**\n * Find one record, same as `all`, limited by 1 and return object, not collection\n *\n * @param {Object} params - search conditions: {where: {test: 'me'}}\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.findOne = function findOne(params, callback) {\n    if ('function' === typeof params) {\n        callback = params;\n        params = {};\n    }\n    if (typeof callback === 'undefined' && !(params || {}).where) {\n        return new Query(this.schema.models[this.modelName], 'findOne', params);\n    } else {\n        if (stillConnecting(this.schema, this, arguments)) {\n            return null;\n        }\n        var self = this;\n        if (typeof params === 'undefined') {\n            self.q.params.limit = 1;\n            return self;\n        } else {\n            var p = deferPromise();\n            if (typeof params === 'function') {\n                callback = params;\n                params = {};\n            }\n            params = buildQuery(params, self);\n            params.limit = 1;\n            self\n                .all(params)\n                .then(function (collection) {\n                    p.resolve(collection[0]);\n                    return callback && callback(null, collection[0] || null);\n                })\n                .catch(function (err) {\n                    p.reject(err);\n                    return callback && callback(err, null);\n                });\n            return p.promise;\n        }\n    }\n};\n\nfunction substractDirtyAttributes(object, data) {\n    Object.keys(object.toObject()).forEach(function (attr) {\n        if (data.hasOwnProperty(attr) && object.propertyChanged(attr)) {\n            delete data[attr];\n        }\n    });\n}\n\n/**\n * Destroy all records\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.destroyAll = function destroyAll(callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    this.schema.adapter.destroyAll(this.modelName, function (err) {\n        if (err) {\n            p.reject(err);\n        } else {\n            p.resolve(null);\n        }\n        return callback && callback(err);\n    }.bind(this));\n    return p.promise;\n};\n\n/**\n * Return count of matched records\n *\n * @param {Object} params - search conditions (optional)\n * @param {Function} callback - callback, called with (err, count)\n */\nAbstractClass.count = function (params, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    if (typeof params === 'function') {\n        callback = params;\n        params = null;\n    }\n    var p = deferPromise();\n    params = buildQuery(params, this);\n    this.schema.adapter.count(this.modelName, function (err, count) {\n        if (err) {\n            p.reject(err);\n        } else {\n            p.resolve(count);\n        }\n        return callback && callback(err, count);\n    }, params);\n    return p.promise;\n};\n\n/**\n * Allows you to load relations of several objects and optimize numbers of requests.\n *\n * @param {Array} objects - array of instances\n * @param {String|Object|Array} include - which relations you want to load.\n * @param {Function} callback - Callback called when relations are loaded\n *\n * Examples:\n *\n * - User.include(users, 'posts', function() {}); will load all users posts with only one additional request.\n * - User.include(users, ['posts'], function() {}); // same\n * - User.include(users, ['posts', 'passports'], function() {}); // will load all users posts and passports with two\n *     additional requests.\n * - Passport.include(passports, {owner: 'posts'}, function() {}); // will load all passports owner (users), and all\n *     posts of each owner loaded\n * - Passport.include(passports, {owner: ['posts', 'passports']}); // ...\n * - Passport.include(passports, {owner: [{posts: 'images'}, 'passports']}); // ...\n */\nAbstractClass.include = function (objects, include, callback) {\n    var self = this;\n\n    if (\n        (include.constructor.name === 'Array' && include.length === 0) ||\n        (include.constructor.name === 'Object' && Object.keys(include).length === 0)\n    ) {\n        callback(null, objects);\n        return;\n    }\n\n    include = processIncludeJoin(include);\n\n    var keyVals = {};\n    var objsByKeys = {};\n\n    var nbCallbacks = 0;\n    for (var i = 0; i < include.length; i++) {\n        var cb = processIncludeItem(objects, include[i], keyVals, objsByKeys);\n        if (cb !== null) {\n            nbCallbacks++;\n            cb(function () {\n                if (--nbCallbacks === 0) {\n                    callback(null, objects);\n                }\n            });\n        } else {\n            callback(null, objects);\n        }\n    }\n\n    function processIncludeJoin(ij) {\n        if (typeof ij === 'string') {\n            ij = [ij];\n        }\n        if (ij.constructor.name === 'Object') {\n            var newIj = [];\n            for (var key in ij) {\n                var obj = {};\n                obj[key] = ij[key];\n                newIj.push(obj);\n            }\n            return newIj;\n        }\n        return ij;\n    }\n\n    function processIncludeItem(objs, include, keyVals, objsByKeys) {\n        var relations = self.relations, relationName, subInclude;\n\n        if (include.constructor.name === 'Object') {\n            relationName = Object.keys(include)[0];\n            subInclude = include[relationName];\n        } else {\n            relationName = include;\n            subInclude = [];\n        }\n        var relation = relations[relationName];\n\n        var req = {\n            'where': {}\n        };\n\n        if (!keyVals[relation.keyFrom]) {\n            objsByKeys[relation.keyFrom] = {};\n            for (var j = 0; j < objs.length; j++) {\n                if (!objsByKeys[relation.keyFrom][objs[j][relation.keyFrom]]) {\n                    objsByKeys[relation.keyFrom][objs[j][relation.keyFrom]] = [];\n                }\n                objsByKeys[relation.keyFrom][objs[j][relation.keyFrom]].push(objs[j]);\n            }\n            keyVals[relation.keyFrom] = Object.keys(objsByKeys[relation.keyFrom]);\n        }\n\n        if (keyVals[relation.keyFrom].length > 0) {\n            // deep clone is necessary since inq seems to change the processed array\n            var keysToBeProcessed = {};\n            var inValues = [];\n            for (var f = 0; f < keyVals[relation.keyFrom].length; f++) {\n                keysToBeProcessed[keyVals[relation.keyFrom][f]] = true;\n                if (keyVals[relation.keyFrom][f] !== 'null') {\n                    inValues.push(keyVals[relation.keyFrom][f]);\n                }\n            }\n\n            req['where'][relation.keyTo] = {\n                inq: inValues\n            };\n            req['include'] = subInclude;\n\n            return function (clbk) {\n                relation.modelTo.all(req, function (err, objsIncluded) {\n                    for (var i = 0; i < objsIncluded.length; i++) {\n                        delete keysToBeProcessed[objsIncluded[i][relation.keyTo]];\n                        var objectsFrom = objsByKeys[relation.keyFrom][objsIncluded[i][relation.keyTo]];\n                        for (var j = 0; j < objectsFrom.length; j++) {\n                            if (!objectsFrom[j].__cachedRelations) {\n                                objectsFrom[j].__cachedRelations = {};\n                            }\n                            if (relation.multiple) {\n                                if (!objectsFrom[j].__cachedRelations[relationName]) {\n                                    objectsFrom[j].__cachedRelations[relationName] = [];\n                                }\n                                objectsFrom[j].__cachedRelations[relationName].push(objsIncluded[i]);\n                            } else {\n                                objectsFrom[j].__cachedRelations[relationName] = objsIncluded[i];\n                            }\n                        }\n                    }\n\n                    // No relation have been found for these keys\n                    for (var key in keysToBeProcessed) {\n                        var objectsFromRelation = objsByKeys[relation.keyFrom][key];\n                        for (var n = 0; n < objectsFromRelation.length; n++) {\n                            if (!objectsFromRelation[n].__cachedRelations) {\n                                objectsFromRelation[n].__cachedRelations = {};\n                            }\n                            objectsFromRelation[n].__cachedRelations[relationName] = relation.multiple ? [] : null;\n                        }\n                    }\n                    clbk(err, objsIncluded);\n                });\n            };\n        }\n        return null;\n    }\n};\n\n/**\n * Return string representation of class\n * @override default toString method\n */\nAbstractClass.toString = function () {\n    return '[Model ' + this.modelName + ']';\n};\n\n/**\n * Save instance. When instance haven't id, create method called instead.\n * Triggers: validate, save, update | create\n * @param {Object} options {validate: true, throws: false} [optional]\n * @param {Function} callback - (err, obj)\n */\nAbstractClass.prototype.save = function (options, callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n\n    callback = callback || function () {\n        };\n    options = options || {};\n\n    if (!('validate' in options)) {\n        options.validate = true;\n    }\n    if (!('throws' in options)) {\n        options['throws'] = false;\n    }\n\n    if (options.validate) {\n        this.isValid(function (valid) {\n            if (valid) {\n                save.call(this);\n            } else {\n                var err = new Error('Validation error');\n                // throws option is dangerous for async usage\n                if (options['throws']) {\n                    throw err;\n                }\n                callback(err, this);\n            }\n        }.bind(this));\n    } else {\n        save.call(this);\n    }\n\n    function save() {\n        this.trigger('save', function (saveDone) {\n            var modelName = this.constructor.modelName;\n            var data = this.toObject(true);\n            var inst = this;\n\n            if (inst.id) {\n                data.id = inst.id;\n                inst.trigger('update', function (updateDone) {\n                    inst._adapter().save(modelName, inst.constructor._forDB(data), function (err) {\n                        if (err) {\n                            console.log(err);\n                        } else {\n                            inst._initProperties(data, false);\n                        }\n                        updateDone.call(inst, function () {\n                            saveDone.call(inst, function () {\n                                callback(err, inst);\n                            });\n                        });\n                    });\n                }, data);\n            } else {\n                inst.constructor.create(inst, function (err) {\n                    saveDone.call(inst, function () {\n                        callback(err, inst);\n                    });\n                });\n            }\n        });\n    }\n};\n\nAbstractClass.prototype.isNewRecord = function () {\n    return !this.id;\n};\n\n/**\n * Return adapter of current record\n * @private\n */\nAbstractClass.prototype._adapter = function () {\n    return this.constructor.schema.adapter;\n};\n\n/**\n * Convert instance to Object\n *\n * @param {Boolean} onlySchema - restrict properties to schema only, default false\n * when onlySchema == true, only properties defined in schema returned,\n * otherwise all enumerable properties returned\n * @returns {Object} - canonical object representation (no getters and setters)\n */\nAbstractClass.prototype.toObject = function (onlySchema) {\n    var data = {}, self = this;\n    this.constructor.forEachProperty(function (attr) {\n        if (self[attr] instanceof List) {\n            data[attr] = self[attr].toObject();\n        } else if (self.__data.hasOwnProperty(attr)) {\n            data[attr] = self[attr];\n        } else {\n            data[attr] = null;\n        }\n    });\n\n    if (!onlySchema) {\n        Object.keys(self).forEach(function (attr) {\n            if (!data.hasOwnProperty(attr)) {\n                data[attr] = this[attr];\n            }\n        });\n    }\n\n    return data;\n};\n\n// AbstractClass.prototype.hasOwnProperty = function (prop) {\n//     return this.__data && this.__data.hasOwnProperty(prop) ||\n//         Object.getOwnPropertyNames(this).indexOf(prop) !== -1;\n// };\n\nAbstractClass.prototype.toJSON = function () {\n    return this.toObject();\n};\n\n/**\n * Delete object from persistence\n * @param {Function} callback called with (error)\n * @triggers `destroy` hook (async) before and after destroying object\n */\nAbstractClass.prototype.destroy = function (callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    this.trigger('destroy', function (destroyed) {\n        this._adapter().destroy(this.constructor.modelName, this.id, function (err) {\n            destroyed(function () {\n                return callback && callback(err);\n            });\n        }.bind(this));\n    });\n};\n\n/**\n * Destroy records\n * @param {Object|String|Number} id - remove conditions\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.destroyById = function destroyById(id, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    id = getInstanceId(id);\n    this.findById(id, function (err, inst) {\n        if (inst) {\n            inst.destroy(function (err) {\n                if (err) {\n                    p.reject(err);\n                } else {\n                    p.resolve(null);\n                }\n                return callback && callback(err);\n            });\n        } else {\n            p.reject(err);\n            return callback && callback(err);\n        }\n    });\n    return p.promise;\n};\n\n/**\n * Destroy records\n * @param {Object} params - remove conditions\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.remove = function remove(params, callback) {\n    if (typeof callback === 'undefined') {\n        return new Query(this.schema.models[this.modelName], 'remove', params);\n    } else {\n        if (stillConnecting(this.schema, this, arguments)) {\n            return;\n        }\n        this.schema.adapter.remove(this.modelName, params, function (err) {\n            // clearCache(this);\n            callback(err);\n        }.bind(this));\n    }\n};\n\n/**\n * Update single attribute\n *\n * equals to `updateAttributes({name: value}, cb)\n *\n * @param {String} name - name of property\n * @param {Mixed} value - value of property\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.prototype.updateAttribute = function updateAttribute(name, value, callback) {\n    var data = {};\n    data[name] = value;\n    this.updateAttributes(data, callback);\n};\n\n/**\n * Update set of attributes\n *\n * this method performs validation before updating\n *\n * @trigger `validation`, `save` and `update` hooks\n * @param {Object} data - data to update\n * @param {Function} callback - callback called with (err, instance)\n */\nAbstractClass.prototype.updateAttributes = function updateAttributes(data, callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    var inst = this;\n    var model = this.constructor.modelName;\n\n    if (!data) {\n        data = {};\n    }\n\n    // update instance's properties\n    Object.keys(data).forEach(function (key) {\n        inst[key] = data[key];\n    });\n\n    inst.isValid(function (valid) {\n        if (!valid) {\n            if (callback) {\n                callback(new Error('Validation error'), inst);\n            }\n        } else {\n            update();\n        }\n    });\n\n    function update() {\n        inst.trigger('save', function (saveDone) {\n            inst.trigger('update', function (done) {\n                Object.keys(data).forEach(function (key) {\n                    data[key] = inst[key];\n                });\n                inst._adapter().updateAttributes(model, inst.id, inst.constructor._forDB(data), function (err) {\n                    if (!err) {\n                        // update _was attrs\n                        Object.keys(data).forEach(function (key) {\n                            inst.__dataWas[key] = inst.__data[key];\n                        });\n                    }\n                    done.call(inst, function () {\n                        saveDone.call(inst, function () {\n                            callback(err, inst);\n                        });\n                    });\n                });\n            }, data);\n        });\n    }\n};\n\n/**\n * Update records\n * @param {Object} filter - update conditions\n * @param {Object} data - data to update\n * @param {Object} options - data to update\n * @param {Function} callback - callback called with (err)\n */\nAbstractClass.update = function update(filter, data, options, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    var p = deferPromise();\n    if (this.schema.adapter.update) {\n        var args = [this.modelName, filter, data];\n        if (options && typeof options !== 'function') args.push(options);\n        else if (typeof options === 'function') callback = options;\n        args.push(function (err, affected) {\n            affected = {affected: affected || 0};\n            if (err) {\n                p.reject(err);\n            } else {\n                p.resolve(affected);\n            }\n            return callback && callback(err, affected);\n        });\n        this.schema.adapter.update.apply(this.schema.adapter, args);\n    } else {\n        var err = new Error('Method update undefined for this adapter');\n        p.reject(err);\n        callback && callback(err);\n    }\n    return p.promise;\n};\n\nAbstractClass.prototype.fromObject = function (obj) {\n    Object.keys(obj).forEach(function (key) {\n        this[key] = obj[key];\n    }.bind(this));\n};\n\n/**\n * Checks is property changed based on current property and initial value\n *\n * @param {String} attr - property name\n * @return Boolean\n */\nAbstractClass.prototype.propertyChanged = function propertyChanged(attr) {\n    return this.__data[attr] !== this.__dataWas[attr];\n};\n\n/**\n * Reload object from persistence\n *\n * @requires `id` member of `object` to be able to call `find`\n * @param {Function} callback - called with (err, instance) arguments\n */\nAbstractClass.prototype.reload = function reload(callback) {\n    if (stillConnecting(this.constructor.schema, this, arguments)) {\n        return;\n    }\n    this.constructor.findById(this.id, callback);\n};\n\n/**\n * Reset dirty attributes\n *\n * this method does not perform any database operation it just reset object to it's\n * initial state\n */\nAbstractClass.prototype.reset = function () {\n    var obj = this;\n    Object.keys(obj).forEach(function (k) {\n        if (k !== 'id' && !obj.constructor.schema.definitions[obj.constructor.modelName].properties[k]) {\n            delete obj[k];\n        }\n        if (obj.propertyChanged(k)) {\n            obj[k] = obj[k + '_was'];\n        }\n    });\n};\n\n/**\n * Declare hasMany relation\n *\n * @param {Class} anotherClass - class to has many\n * @param {Object} params - configuration {as:, foreignKey:}\n * @example `User.hasMany(Post, {as: 'posts', foreignKey: 'authorId'});`\n */\nAbstractClass.hasMany = function hasMany(anotherClass, params) {\n    var methodName = params.as || pluralize(anotherClass.modelName);\n    var fk = params.foreignKey;\n\n    this.relations[methodName] = {\n        type: 'hasMany',\n        keyFrom: 'id',\n        keyTo: fk,\n        modelTo: anotherClass,\n        multiple: true\n    };\n\n    // each instance of this class should have method named\n    // which is actually just anotherClass.all({where: {thisModelNameId: this.id}}, cb);\n    defineScope(this.prototype, anotherClass, methodName, function () {\n        var x = {}, id;\n        if (this.id && typeof this.id === 'object') {\n            id = this.id.toString();\n        } else {\n            id = this.id;\n        }\n        x[fk] = id;\n        return {\n            where: x\n        };\n    }, {\n        find: find,\n        update: update,\n        destroy: destroy,\n        remove: remove\n    });\n\n    // obviously, anotherClass should have attribute called `fk`\n    anotherClass.schema.defineForeignKey(anotherClass.modelName, fk);\n\n    function find(query, callback) {\n        if (!callback && typeof query === 'function') {\n            callback = query;\n            query = {\n                where: {}\n            };\n        } else {\n            if (!query.where) {\n                query.where = {};\n            }\n        }\n        query.where[fk] = typeof this.id === 'object' ? this.id.toString() : this.id;\n        anotherClass.all(query, function (err, inst) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, inst);\n        }.bind(this));\n    }\n\n    function update(query, data, callback) {\n        if (!query.where) {\n            query.where = {};\n        }\n        query.where[fk] = typeof this.id === 'object' ? this.id.toString() : this.id;\n        anotherClass.update(query, data, function (err, inst) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, inst);\n        }.bind(this));\n    }\n\n    function remove(query, callback) {\n        if (!callback && typeof query === 'function') {\n            callback = query;\n            query = {\n                where: {}\n            };\n        } else {\n            if (!query.where) {\n                query.where = {};\n            }\n        }\n        query.where[fk] = typeof this.id === 'object' ? this.id.toString() : this.id;\n        anotherClass.remove(query, function (err, inst) {\n            if (err) {\n                return callback(err);\n            }\n            callback(null, inst);\n        }.bind(this));\n    }\n\n    function destroy(id, callback) {\n        id = typeof id === 'object' ? id.toString() : id;\n        this.findById(id, function (err, inst) {\n            if (err)\n                return callback(err);\n            if (inst) {\n                inst.destroy(callback);\n            } else {\n                callback(new Error('Not found'));\n            }\n        });\n    }\n};\n\n/**\n * Declare belongsTo relation\n *\n * @param {Class} anotherClass - class to belong\n * @param {Object} params - configuration {as: 'propertyName', foreignKey: 'keyName'}\n *\n * **Usage examples**\n * Suppose model Post have a *belongsTo* relationship with User (the author of the post). You could declare it this way:\n * Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});\n *\n * When a post is loaded, you can load the related author with:\n * post.author(function(err, user) {\n *     // the user variable is your user object\n * });\n *\n * The related object is cached, so if later you try to get again the author, no additional request will be made.\n * But there is an optional boolean parameter in first position that set whether or not you want to reload the cache:\n * post.author(true, function(err, user) {\n *     // The user is reloaded, even if it was already cached.\n * });\n *\n * This optional parameter default value is false, so the related object will be loaded from cache if available.\n */\nAbstractClass.belongsTo = function (anotherClass, params) {\n    var modelName = this.modelName;\n    var methodName = params.as;\n    var fk = params.foreignKey;\n\n    this.relations[params['as']] = {\n        type: 'belongsTo',\n        keyFrom: params['foreignKey'],\n        keyTo: 'id',\n        modelTo: anotherClass,\n        multiple: false\n    };\n\n    this.schema.defineForeignKey(modelName, fk);\n    this.prototype['__finders__'] = this.prototype['__finders__'] || {};\n\n    this.prototype['__finders__'][methodName] = function (id, cb) {\n        if (id === null) {\n            cb(null, null);\n            return;\n        }\n        anotherClass.findById(id, function (err, inst) {\n            if (!inst) {\n                return cb(new Error(modelName + ' belongsTo ' + anotherClass.modelName + ' via foreign key ' + fk + ' error'));\n            }\n            var sid = typeof inst.id === 'object' ? inst.id.toString() : inst.id;\n            var fid = typeof this[fk] === 'object' ? this[fk].toString() : this[fk];\n            if (err) {\n                return cb(err);\n            }\n            if (!inst)\n                return cb(null, null);\n            if (sid === fid) {\n                cb(null, inst);\n            } else {\n                cb(new Error('Permission denied'));\n            }\n        }.bind(this));\n    };\n\n    this.prototype[methodName] = function (refresh, p) {\n        if (arguments.length === 1) {\n            p = refresh;\n            refresh = false;\n        } else if (arguments.length > 2) {\n            throw new Error('Method can\\'t be called with more than two arguments');\n        }\n        var self = this;\n        var cachedValue;\n        if (!refresh && this.__cachedRelations && (typeof this.__cachedRelations[methodName] !== 'undefined')) {\n            cachedValue = this.__cachedRelations[methodName];\n        }\n        if (p instanceof AbstractClass) { // acts as setter\n            this[fk] = p.id;\n            this.__cachedRelations[methodName] = p;\n        } else if (typeof p === 'function') { // acts as async getter\n            if (typeof cachedValue === 'undefined') {\n                this.__finders__[methodName].apply(self, [this[fk], function (err, inst) {\n                    if (!err) {\n                        self.__cachedRelations[methodName] = inst;\n                    }\n                    p(err, inst);\n                }]);\n                return this[fk];\n            } else {\n                p(null, cachedValue);\n                return cachedValue;\n            }\n        } else if (typeof p === 'undefined') { // acts as sync getter\n            return this[fk];\n        } else { // setter\n            this[fk] = p;\n            delete this.__cachedRelations[methodName];\n        }\n    };\n};\n\n/**\n * Define scope\n * TODO: describe behavior and usage examples\n *\n * @param {String} name - scope name\n * @param {Object} params - scope condition\n */\nAbstractClass.scope = function (name, params) {\n    defineScope(this, this, name, params);\n};\n\nfunction defineScope(cls, targetClass, name, params, methods) {\n\n    // collect meta info about scope\n    if (!cls._scopeMeta) {\n        cls._scopeMeta = {};\n    }\n\n    // only makes sence to add scope in meta if base and target classes\n    // are same\n    if (cls === targetClass) {\n        cls._scopeMeta[name] = params;\n    } else {\n        if (!targetClass._scopeMeta) {\n            targetClass._scopeMeta = {};\n        }\n    }\n\n    Object.defineProperty(cls, name, {\n        enumerable: false,\n        configurable: true,\n        get: function () {\n            var f = function caller(condOrRefresh, cb) {\n                var actualCond = {};\n                var actualRefresh = false;\n                var saveOnCache = true;\n                if (arguments.length === 1) {\n                    cb = condOrRefresh;\n                } else if (arguments.length === 2) {\n                    if (typeof condOrRefresh === 'boolean') {\n                        actualRefresh = condOrRefresh;\n                    } else {\n                        actualCond = condOrRefresh;\n                        actualRefresh = true;\n                        saveOnCache = false;\n                    }\n                } else {\n                    throw new Error('Method can be only called with one or two arguments');\n                }\n\n                if (!this.__cachedRelations || (typeof this.__cachedRelations[name] === 'undefined') || actualRefresh) {\n                    var self = this;\n                    return targetClass.all(mergeParams(actualCond, caller._scope), function (err, data) {\n                        if (!err && saveOnCache) {\n                            self.__cachedRelations[name] = data;\n                        }\n                        cb(err, data);\n                    });\n                } else {\n                    cb(null, this.__cachedRelations[name]);\n                }\n            };\n\n            f._scope = typeof params === 'function' ? params.call(this) : params;\n            f.build = build;\n            f.create = create;\n            f.destroy = destroy;\n            f.destroyAll = destroyAll;\n            for (var i in methods) {\n                f[i] = methods[i].bind(this);\n            }\n\n            // define sub-scopes\n            Object.keys(targetClass._scopeMeta).forEach(function (name) {\n                Object.defineProperty(f, name, {\n                    enumerable: false,\n                    get: function () {\n                        mergeParams(f._scope, targetClass._scopeMeta[name]);\n                        return f;\n                    }\n                });\n            }.bind(this));\n            return f;\n        }\n    });\n\n    // and it should have create/build methods with binded thisModelNameId param\n    function build(data) {\n        return new targetClass(mergeParams(this._scope, {\n            where: data || {}\n        }).where);\n    }\n\n    function create(data, cb) {\n        if (typeof data === 'function') {\n            cb = data;\n            data = {};\n        }\n        this.build(data).save(cb);\n    }\n\n    function destroy(id, callback) {\n        if (callback) {\n            // TODO: impement\n            callback();\n        }\n    }\n\n    /*\n     Callback\n     - The callback will be called after all elements are destroyed\n     - For every destroy call which results in an error\n     - If fetching the Elements on which destroyAll is called results in an error\n     */\n    function destroyAll(callback) {\n        targetClass.all(this._scope, function (err, data) {\n            if (err) {\n                callback(err);\n            } else {\n                (function loopOfDestruction(data) {\n                    if (data.length > 0) {\n                        data.shift().destroy(function (err) {\n                            if (err && callback)\n                                callback(err);\n                            loopOfDestruction(data);\n                        });\n                    } else {\n                        if (callback)\n                            callback();\n                    }\n                }(data));\n            }\n        });\n    }\n\n    function mergeParams(base, update) {\n        if (update && !update.where) {\n            update = {\n                where: update\n            };\n        }\n        if (update.where) {\n            base.where = helpers.merge(base.where, update.where);\n        }\n        // overwrite order\n        if (update.order) {\n            base.order = update.order;\n        }\n        return base;\n    }\n}\n\nAbstractClass.prototype.inspect = function () {\n    return util.inspect(this.__data, false, 4, true);\n};\n\n/**\n * Create index in collection\n *\n * @param {String|Object} fields - index name\n * @param {Object} params - indexed fields list { name : 1, created : -1 }\n * @param {Function} callback - callbacl called with (err, exists: Bool)\n */\nAbstractClass.ensureIndex = function ensureIndex(fields, params, callback) {\n    if (stillConnecting(this.schema, this, arguments)) {\n        return;\n    }\n    if (typeof callback === 'undefined') {\n        callback = function (err) {\n            return err;\n        };\n    }\n\n    if (typeof params === 'object') {\n        if (typeof this.schema.adapter.ensureIndex === 'undefined') {\n            callback(new Error('Model::ensureIndex not defined for this adapter'));\n        } else {\n            this.schema.adapter.ensureIndex(this.modelName, fields, params, callback);\n        }\n    } else {\n        callback(new Error('Model::ensureIndex requires params argument'));\n    }\n};\n\nfunction buildQuery(opts, model) {\n\n    for (var okey in model.q.conditions) {\n        if (typeof opts.where === 'undefined') {\n            opts.where = {};\n        }\n        opts.where[okey] = model.q.conditions[okey];\n    }\n    model.q.conditions = {};\n\n    for (var pkey in model.q.params) {\n        if (typeof opts[pkey] === 'undefined') {\n            opts[pkey] = {};\n        }\n        opts[pkey] = model.q.params[pkey];\n    }\n    model.q.params = {};\n    model.q.pkey = false;\n    return opts;\n}\n\n/**\n * Check whether `s` is not undefined\n * @param {Mixed} s\n * @return {Boolean} s is undefined\n */\nfunction isdef(s) {\n    var undef;\n    return s !== undef;\n}\n\n/**\n * Define readonly property on object\n *\n * @param {Object} obj\n * @param {String} key\n * @param {Mixed} value\n */\nfunction defineReadonlyProp(obj, key, value) {\n    Object.defineProperty(obj, key, {\n        writable: false,\n        enumerable: true,\n        configurable: true,\n        value: value\n    });\n}\n\n/**\n * Normalize id\n *\n * @param {Mixed} id\n */\nfunction getInstanceId(id) {\n    if (typeof id === 'object' && id.constructor === Array) {\n        id = id[0];\n    }\n    return id;\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/validatable.js":"exports.Validatable = Validatable;\n\n/**\n * Validation encapsulated in this abstract class.\n *\n * Basically validation configurators is just class methods, which adds validations\n * configs to AbstractClass._validations. Each of this validations run when\n * `obj.isValid()` method called.\n *\n * Each configurator can accept n params (n-1 field names and one config). Config\n * is {Object} depends on specific validation, but all of them has one common part:\n * `message` member. It can be just string, when only one situation possible,\n * e.g. `Post.validatesPresenceOf('title', { message: 'can not be blank' });`\n *\n * In more complicated cases it can be {Hash} of messages (for each case):\n * `User.validatesLengthOf('password', { min: 6, max: 20, message: {min: 'too short', max: 'too long'}});`\n */\nfunction Validatable() {\n    // validatable class\n};\n\n/**\n * Validate presence. This validation fails when validated field is blank.\n *\n * Default error message \"can't be blank\"\n *\n * @example presence of title\n * ```\n * Post.validatesPresenceOf('title');\n * ```\n * @example with custom message\n * ```\n * Post.validatesPresenceOf('title', {message: 'Can not be blank'});\n * ```\n *\n * @sync\n *\n * @nocode\n * @see helper/validatePresence\n */\nValidatable.validatesPresenceOf = getConfigurator('presence');\n\n/**\n * Validate length. Three kinds of validations: min, max, is.\n *\n * Default error messages:\n *\n * - min: too short\n * - max: too long\n * - is:  length is wrong\n *\n * @example length validations\n * ```\n * User.validatesLengthOf('password', {min: 7});\n * User.validatesLengthOf('email', {max: 100});\n * User.validatesLengthOf('state', {is: 2});\n * User.validatesLengthOf('nick', {min: 3, max: 15});\n * ```\n * @example length validations with custom error messages\n * ```\n * User.validatesLengthOf('password', {min: 7, message: {min: 'too weak'}});\n * User.validatesLengthOf('state', {is: 2, message: {is: 'is not valid state name'}});\n * ```\n *\n * @sync\n * @nocode\n * @see helper/validateLength\n */\nValidatable.validatesLengthOf = getConfigurator('length');\n\n/**\n * Validate numericality.\n *\n * @example\n * ```\n * User.validatesNumericalityOf('age', { message: { number: '...' }});\n * User.validatesNumericalityOf('age', {int: true, message: { int: '...' }});\n * ```\n *\n * Default error messages:\n *\n * - number: is not a number\n * - int: is not an integer\n *\n * @sync\n * @nocode\n * @see helper/validateNumericality\n */\nValidatable.validatesNumericalityOf = getConfigurator('numericality');\n\n/**\n * Validate inclusion in set\n *\n * @example\n * ```\n * User.validatesInclusionOf('gender', {in: ['male', 'female']});\n * User.validatesInclusionOf('role', {\n *     in: ['admin', 'moderator', 'user'], message: 'is not allowed'\n * });\n * ```\n *\n * Default error message: is not included in the list\n *\n * @sync\n * @nocode\n * @see helper/validateInclusion\n */\nValidatable.validatesInclusionOf = getConfigurator('inclusion');\n\n/**\n * Validate exclusion\n *\n * @example `Company.validatesExclusionOf('domain', {in: ['www', 'admin']});`\n *\n * Default error message: is reserved\n *\n * @nocode\n * @see helper/validateExclusion\n */\nValidatable.validatesExclusionOf = getConfigurator('exclusion');\n\n/**\n * Validate format\n *\n * Default error message: is invalid\n *\n * @nocode\n * @see helper/validateFormat\n */\nValidatable.validatesFormatOf = getConfigurator('format');\n\n/**\n * Validate using custom validator\n *\n * Default error message: is invalid\n *\n * Example:\n *\n *     User.validate('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err) {\n *         if (this.name === 'bad') err();\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // true\n *     user.name = 'bad';\n *     user.isValid(); // false\n *\n * @nocode\n * @see helper/validateCustom\n */\nValidatable.validate = getConfigurator('custom');\n\n/**\n * Validate using custom async validator\n *\n * Default error message: is invalid\n *\n * Example:\n *\n *     User.validateAsync('name', customValidator, {message: 'Bad name'});\n *     function customValidator(err, done) {\n *         process.nextTick(function () {\n *             if (this.name === 'bad') err();\n *             done();\n *         });\n *     });\n *     var user = new User({name: 'Peter'});\n *     user.isValid(); // false (because async validation setup)\n *     user.isValid(function (isValid) {\n *         isValid; // true\n *     })\n *     user.name = 'bad';\n *     user.isValid(); // false\n *     user.isValid(function (isValid) {\n *         isValid; // false\n *     })\n *\n * @async\n * @nocode\n * @see helper/validateCustom\n */\nValidatable.validateAsync = getConfigurator('custom', {async: true});\n\n/**\n * Validate uniqueness\n *\n * Default error message: is not unique\n *\n * @async\n * @nocode\n * @see helper/validateUniqueness\n */\nValidatable.validatesUniquenessOf = getConfigurator('uniqueness', {async: true});\n\n// implementation of validators\n\n/**\n * Presence validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validatePresence(attr, conf, err) {\n    if (blank(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Length validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateLength(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    var len = this[attr].length;\n    if (conf.min && len < conf.min) {\n        err('min');\n    }\n    if (conf.max && len > conf.max) {\n        err('max');\n    }\n    if (conf.is && len !== conf.is) {\n        err('is');\n    }\n}\n\n/**\n * Numericality validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateNumericality(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (typeof this[attr] !== 'number') {\n        return err('number');\n    }\n    if (conf.int && this[attr] !== Math.round(this[attr])) {\n        return err('int');\n    }\n}\n\n/**\n * Inclusion validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateInclusion(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (!~conf.in.indexOf(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Exclusion validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateExclusion(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n\n    if (~conf.in.indexOf(this[attr])) {\n        err();\n    }\n}\n\n/**\n * Format validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n */\nfunction validateFormat(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n    if (typeof this[attr] === 'string') {\n        if (!this[attr].match(conf['with'])) {\n            err();\n        }\n    } else {\n        err();\n    }\n}\n\n/**\n * Custom validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n * @param {Function} done\n */\nfunction validateCustom(attr, conf, err, done) {\n    conf.customValidator.call(this, err, done);\n}\n\n/**\n * Uniqueness validator\n * @param {mixed} attr\n * @param {mixed} conf\n * @param {mixed} err\n * @param {Function} done\n */\nfunction validateUniqueness(attr, conf, err, done) {\n    var cond = {where: {}};\n    cond.where[attr] = this[attr];\n    this.constructor.all(cond, function (error, found) {\n        if (found.length > 1) {\n            err();\n        } else if (found.length === 1 && (!this.id || !found[0].id || found[0].id.toString() !== this.id.toString())) {\n            err();\n        }\n        done();\n    }.bind(this));\n}\n\nvar validators = {\n    presence: validatePresence,\n    length: validateLength,\n    numericality: validateNumericality,\n    inclusion: validateInclusion,\n    exclusion: validateExclusion,\n    format: validateFormat,\n    custom: validateCustom,\n    uniqueness: validateUniqueness\n};\n\nfunction getConfigurator(name, opts) {\n    return function () {\n        configure(this, name, arguments, opts);\n    };\n}\n\n/**\n * This method performs validation, triggers validation hooks.\n * Before validation `obj.errors` collection cleaned.\n * Each validation can add errors to `obj.errors` collection.\n * If collection is not blank, validation failed.\n *\n * @warning This method can be called as sync only when no async validation\n * configured. It's strongly recommended to run all validations as asyncronous.\n *\n * @param {Function} callback called with (valid)\n * @return {Boolean} true if no async validation configured and all passed\n *\n * @example ExpressJS controller: render user if valid, show flash otherwise\n * ```\n * user.isValid(function (valid) {\n *     if (valid) res.render({user: user});\n *     else res.flash('error', 'User is not valid'), console.log(user.errors), res.redirect('/users');\n * });\n * ```\n */\nValidatable.prototype.isValid = function (callback) {\n    var valid = true, inst = this, wait = 0, async = false;\n\n    // exit with success when no errors\n    if (!this.constructor._validations) {\n        cleanErrors(this);\n        if (callback) {\n            callback(valid);\n        }\n        return valid;\n    }\n\n    Object.defineProperty(this, 'errors', {\n        enumerable: false,\n        configurable: true,\n        value: new Errors\n    });\n\n    this.trigger('validation', function (validationsDone) {\n        var inst = this;\n        this.constructor._validations.forEach(function (v) {\n            if (v[2] && v[2].async) {\n                async = true;\n                wait += 1;\n                validationFailed(inst, v, done);\n            } else {\n                if (validationFailed(inst, v)) {\n                    valid = false;\n                }\n            }\n        });\n\n        if (!async) {\n            validationsDone();\n        }\n\n        var asyncFail = false;\n\n        function done(fail) {\n            asyncFail = asyncFail || fail;\n            if (--wait === 0 && callback) {\n                validationsDone.call(inst, function () {\n                    if (valid && !asyncFail) cleanErrors(inst);\n                    callback(valid && !asyncFail);\n                });\n            }\n        }\n\n    });\n\n    if (!async) {\n        if (valid) cleanErrors(this);\n        if (callback) callback(valid);\n        return valid;\n    } else {\n        // in case of async validation we should return undefined here,\n        // because not all validations are finished yet\n        return;\n    }\n\n};\n\nfunction cleanErrors(inst) {\n    Object.defineProperty(inst, 'errors', {\n        enumerable: false,\n        configurable: true,\n        value: false\n    });\n}\n// 43903\n// 44471\nfunction validationFailed(inst, v, cb) {\n    var attr = v[0];\n    var conf = v[1];\n    var opts = v[2] || {};\n\n    if (typeof attr !== 'string') return false;\n\n    // here we should check skip validation conditions (if, unless)\n    // that can be specified in conf\n    if (skipValidation(inst, conf, 'if')) return false;\n    if (skipValidation(inst, conf, 'unless')) return false;\n\n    var fail = false;\n    var validator = validators[conf.validation];\n    var validatorArguments = [];\n    validatorArguments.push(attr);\n    validatorArguments.push(conf);\n    validatorArguments.push(function onerror(kind) {\n        var message;\n        if (conf.message) {\n            message = conf.message;\n        }\n        if (!message && defaultMessages[conf.validation]) {\n            message = defaultMessages[conf.validation];\n        }\n        if (!message) {\n            message = 'is invalid';\n        }\n        if (kind) {\n            if (message[kind]) {\n                // get deeper\n                message = message[kind];\n            } else if (defaultMessages.common[kind]) {\n                message = defaultMessages.common[kind];\n            }\n        }\n        inst.errors.add(attr, message);\n        fail = true;\n        if (cb) {\n            return cb && cb(fail);\n        }\n    });\n    if (cb) {\n        validatorArguments.push(function onsuccess() {\n            return cb && cb(fail);\n        });\n    }\n    validator.apply(inst, validatorArguments);\n    return fail;\n}\n\nfunction skipValidation(inst, conf, kind) {\n    var doValidate = true;\n    if (typeof conf[kind] === 'function') {\n        doValidate = conf[kind].call(inst);\n        if (kind === 'unless') doValidate = !doValidate;\n    } else if (typeof conf[kind] === 'string') {\n        if (typeof inst[conf[kind]] === 'function') {\n            doValidate = inst[conf[kind]].call(inst);\n            if (kind === 'unless') doValidate = !doValidate;\n        } else if (inst.__data.hasOwnProperty(conf[kind])) {\n            doValidate = inst[conf[kind]];\n            if (kind === 'unless') doValidate = !doValidate;\n        } else {\n            doValidate = kind === 'if';\n        }\n    }\n    return !doValidate;\n}\n\nvar defaultMessages = {\n    presence: 'can\\'t be blank',\n    length: {\n        min: 'too short',\n        max: 'too long',\n        is: 'length is wrong'\n    },\n    common: {\n        blank: 'is blank',\n        'null': 'is null'\n    },\n    numericality: {\n        'int': 'is not an integer',\n        'number': 'is not a number'\n    },\n    inclusion: 'is not included in the list',\n    exclusion: 'is reserved',\n    uniqueness: 'is not unique'\n};\n\nfunction nullCheck(attr, conf, err) {\n    var isNull = this[attr] === null || !(attr in this);\n    if (isNull) {\n        if (!conf.allowNull) {\n            err('null');\n        }\n        return true;\n    } else {\n        if (blank(this[attr])) {\n            if (!conf.allowBlank) {\n                err('blank');\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Return true when v is undefined, blank array, null or empty string\n * otherwise returns false\n *\n * @param {Mix} v\n * @returns {Boolean} whether `v` blank or not\n */\nfunction blank(v) {\n    if (typeof v === 'undefined') return true;\n    if (v instanceof Array && v.length === 0) return true;\n    if (v === null) return true;\n    if (typeof v === 'string' && v === '') return true;\n    return false;\n}\n\nfunction configure(cls, validation, args, opts) {\n    if (!cls._validations) {\n        Object.defineProperty(cls, '_validations', {\n            writable: true,\n            configurable: true,\n            enumerable: false,\n            value: []\n        });\n    }\n    args = [].slice.call(args);\n    var conf;\n    if (typeof args[args.length - 1] === 'object') {\n        conf = args.pop();\n    } else {\n        conf = {};\n    }\n    if (validation === 'custom' && typeof args[args.length - 1] === 'function') {\n        conf.customValidator = args.pop();\n    }\n    conf.validation = validation;\n    args.forEach(function (attr) {\n        cls._validations.push([attr, conf, opts]);\n    });\n}\n\nfunction Errors() {\n}\n\nErrors.prototype.add = function (field, message) {\n    if (!this[field]) {\n        this[field] = [message];\n    } else {\n        this[field].push(message);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/hookable.js":"exports.Hookable = Hookable;\n\nfunction Hookable() {\n// hookable class\n};\n\nHookable.afterInitialize = null;\nHookable.beforeValidation = null;\nHookable.afterValidation = null;\nHookable.beforeSave = null;\nHookable.afterSave = null;\nHookable.beforeCreate = null;\nHookable.afterCreate = null;\nHookable.beforeUpdate = null;\nHookable.afterUpdate = null;\nHookable.beforeDestroy = null;\nHookable.afterDestroy = null;\n\nHookable.prototype.trigger = function trigger(actionName, work, data) {\n    var capitalizedName = capitalize(actionName);\n    var afterHook = this.constructor[\"after\" + capitalizedName];\n    var beforeHook = this.constructor[\"before\" + capitalizedName];\n    var inst = this;\n\n    // we only call \"before\" hook when we have actual action (work) to perform\n    if (work) {\n        if (beforeHook) {\n            // before hook should be called on instance with one param: callback\n            beforeHook.call(inst, function () {\n                // actual action also have one param: callback\n                work.call(inst, next);\n            }, data);\n        } else {\n            work.call(inst, next);\n        }\n    } else {\n        next();\n    }\n\n    function next(done) {\n        if (afterHook) {\n            afterHook.call(inst, done);\n        } else if (done) {\n            done.call(this);\n        }\n    }\n};\n\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/query.js":"/*\n * Copyright 2013 Aelxey Gordeyev <aleksej@gordejev.lv>.\n */\n\n/**\n * Module dependencies.\n */\nvar utils = require('./utils');\nvar helpers = utils.helpers;\n\n/**\n * Query class\n *\n * @api private\n *\n * @param {Object} model\n * @param {String} action\n * @param {mixed} conditions\n */\nfunction Query(model, action, conditions) {\n    var self = this;\n    self.model = model;\n    self.action = action || 'all';\n    self.q = {\n        conditions: {},\n        params: {},\n        pkey: false,\n        fields: false\n    };\n    if (typeof conditions === 'object') {\n        self.q.conditions = helpers.merge(self.q.conditions, conditions);\n    }\n\n    ['all', 'run', 'exec'].forEach(function(method) {\n        self[method] = function(params, callback) {\n            if (arguments.length === 1) {\n                callback = params;\n                params = {};\n            }\n            params = buildQuery(params, this);\n            var action = self.action ? self.action : 'all';\n            self.model[action](params, callback);\n        };\n    });\n\n    ['find', 'findOne'].forEach(function(method) {\n        self[method] = function(params, callback) {\n            if (arguments.length === 1) {\n                callback = params;\n                params = {};\n            }\n            params = buildQuery(params, this);\n            self.model[method](params, callback);\n        };\n    });\n\n    ['skip', 'limit', 'order', 'sort', 'group'].forEach(function(method) {\n        self[method] = function(key, value) {\n            this.q.pkey = false;\n            if (method === 'sort') {\n                method = 'order';\n            }\n            if (typeof value === 'undefined') {\n                if (/^-/.test(key)) {\n                    this.q.params[method] = key.replace(/^-/, \"\") + ' DESC';\n                } else {\n                    this.q.params[method] = key;\n                }\n            } else {\n                this.q.params[method] = key + ' ' + value;\n            }\n            return this;\n        };\n    });\n\n    self.asc = function(value) {\n        this.q.pkey = false;\n        this.q.params['order'] = value + ' ASC';\n        return this;\n    };\n\n    self.desc = function(value) {\n        this.q.pkey = false;\n        this.q.params['order'] = value + ' DESC';\n        return this;\n    };\n\n    self.where = function(key, value) {\n        if (typeof value === 'undefined') {\n            this.q.pkey = key;\n        } else {\n            this.q.pkey = false;\n            this.q.conditions[key] = value;\n        }\n        return this;\n    };\n\n    self.or = function(values) {\n        if (Array.isArray(values)) {\n            this.q.conditions['or'] = values;\n        }\n        return this;\n    };\n\n    self.range = function(key, from, to) {\n        if (typeof to === 'undefined') {\n            if (this.q.pkey) {\n                to = from;\n                from = key;\n                if (typeof this.q.conditions[this.q.pkey] === 'undefined') {\n                    this.q.conditions[this.q.pkey] = {};\n                }\n                this.q.conditions[this.q.pkey].gt = from;\n                this.q.conditions[this.q.pkey].lt = to;\n            }\n        } else {\n            this.q.pkey = false;\n            if (typeof this.q.conditions[key] === 'undefined') {\n                this.q.conditions[key] = {};\n            }\n            this.q.conditions[key].gt = from;\n            this.q.conditions[key].lt = to;\n        }\n        return this;\n    };\n\n    ['gt', 'gte', 'lt', 'lte', 'in', 'inq', 'ne', 'neq', 'nin', 'regex', 'like', 'nlike', 'between'].forEach(function(method) {\n        self[method] = function(key, value) {\n            if (typeof value === 'undefined') {\n                if (this.q.pkey) {\n                    if (typeof this.q.conditions[this.q.pkey] === 'undefined') {\n                        this.q.conditions[this.q.pkey] = {};\n                    }\n                    this.q.conditions[this.q.pkey][method] = key;\n                }\n            } else {\n                this.q.pkey = false;\n                if (typeof this.q.conditions[key] === 'undefined') {\n                    this.q.conditions[key] = {};\n                }\n                this.q.conditions[key][method] = value;\n            }\n            return this;\n        };\n    });\n\n    self.slice = function(values) {\n        if (Array.isArray(values)) {\n            if (typeof values[1] === 'undefined') {\n                this.q.params['limit'] = values[0];\n            } else {\n                this.q.params['skip'] = values[0];\n                this.q.params['limit'] = values[1];\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Destroy records\n     * @param {Object} params\n     * @param {Function} callback\n     */\n    self.remove = function(params, callback) {\n        if (arguments.length === 1) {\n            callback = params;\n            params = {};\n        }\n        params = buildQuery(params, this);\n        self.model.remove(params, callback);\n    };\n\n    function buildQuery(opts, query) {\n        if (typeof opts.where === 'undefined') {\n            opts.where = {};\n        }\n        opts.where = helpers.merge(opts.where, query.q.conditions);\n        query.q.conditions = {};\n\n        for (var pkey in query.q.params) {\n            if (typeof opts[pkey] === 'undefined') {\n                opts[pkey] = {};\n            }\n            opts[pkey] = query.q.params[pkey];\n        }\n\n        query.q.params = {};\n        query.q.pkey = false;\n        return opts;\n    }\n}\n\n/**\n * Exports.\n */\n\nmodule.exports = exports = Query;","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/list.js":"\nmodule.exports = List;\n\nfunction List(data, type, parent) {\n    var list = this;\n\n    Object.defineProperty(list, 'parent', {\n        writable: false,\n        enumerable: false,\n        configurable: false,\n        value: parent\n    });\n\n    Object.defineProperty(list, 'nextid', {\n        writable: true,\n        enumerable: false,\n        value: 1\n    });\n\n    data = list.items = data || [];\n    var Item = list.ItemType = ListItem;\n\n    if (typeof type === 'object' && type.constructor.name === 'Array') {\n        list.ItemType = type[0] || ListItem;\n    }\n\n    data.forEach(function (item, i) {\n        data[i] = new Item(item, list);\n        Object.defineProperty(list, data[i].id, {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value:  data[i]\n        });\n        if (list.nextid <= data[i].id) {\n            list.nextid = data[i].id + 1;\n        }\n    });\n\n    Object.defineProperty(list, 'length', {\n        enumerable: false,\n        configurable: true,\n        get: function () {\n            return list.items.length;\n        }\n    });\n\n    return list;\n}\n\nvar _;\ntry {\n    _ = require('underscore');\n} catch (e) {\n    _ = false;\n}\n\nif (_) {\n    var _import = [\n    // collection methods\n    'each',\n    'map',\n    'reduce',\n    'reduceRight',\n    'find',\n    'filter',\n    'reject',\n    'all',\n    'any',\n    'include',\n    'invoke',\n    'pluck',\n    'max',\n    'min',\n    'sortBy',\n    'groupBy',\n    'sortedIndex',\n    'shuffle',\n    'toArray',\n    'size',\n    // array methods\n    'first',\n    'initial',\n    'last',\n    'rest',\n    'compact',\n    'flatten',\n    'without',\n    'union',\n    'intersection',\n    'difference',\n    'uniq',\n    'zip',\n    'indexOf',\n    'lastIndexOf',\n    'range'\n    ];\n\n    _import.forEach(function (name) {\n        List.prototype[name] = function () {\n            var args = [].slice.call(arguments);\n            args.unshift(this.items);\n            return _[name].apply(_, args);\n        };\n    });\n}\n\nList.prototype.toObject = function () {\n    return this.items;\n};\n\nList.prototype.toJSON = function () {\n    return this.items;\n};\n\nList.prototype.toString = function () {\n    return JSON.stringify(this.items);\n};\n\nList.prototype.autoincrement = function () {\n    return this.nextid++;\n};\n\nList.prototype.push = function (obj) {\n    var item = new ListItem(obj, this);\n    this.items.push(item);\n    return item;\n};\n\nList.prototype.remove = function (obj) {\n    var id = obj.id ? obj.id : obj;\n    var found = false;\n    this.items.forEach(function (o, i) {\n        if (id && o.id === id) {\n            found = i;\n            if (o.id !== id) {\n                console.log('WARNING! Type of id not matched');\n            }\n        }\n    });\n    if (found !== false) {\n        delete this[id];\n        this.items.splice(found, 1);\n    }\n};\n\nList.prototype.forEach = function (cb) {\n    this.items.forEach(cb);\n};\n\nList.prototype.sort = function (cb) {\n    return this.items.sort(cb);\n};\n\nList.prototype.map = function (cb) {\n    if (typeof cb === 'function') return this.items.map(cb);\n    if (typeof cb === 'string') return this.items.map(function (el) {\n        if (typeof el[cb] === 'function') return el[cb]();\n        if (el.hasOwnProperty(cb)) return el[cb];\n    });\n};\n\nfunction ListItem(data, parent) {\n    for (var i in data) this[i] = data[i];\n    Object.defineProperty(this, 'parent', {\n        writable: false,\n        enumerable: false,\n        configurable: true,\n        value: parent\n    });\n    if (!this.id) {\n        this.id = parent.autoincrement();\n    }\n    if (parent.ItemType) {\n        this.__proto__ = parent.ItemType.prototype;\n        if (parent.ItemType !== ListItem) {\n            parent.ItemType.apply(this);\n        }\n    }\n\n    this.save = function (c) {\n        parent.parent.save(c);\n    };\n}","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/sql.js":"module.exports = BaseSQL;\n\n/**\n * Base SQL class\n */\nfunction BaseSQL() {\n}\n\nBaseSQL.prototype.query = function () {\n    throw new Error('query method should be declared in adapter');\n};\n\nBaseSQL.prototype.command = function (sql, callback) {\n    return this.query(sql, callback);\n};\n\nBaseSQL.prototype.queryOne = function (sql, callback) {\n    return this.query(sql, function (err, data) {\n        if (err) {\n            return callback && callback(err);\n        }\n        return callback && callback(err, data[0]);\n    });\n};\n\nBaseSQL.prototype.table = function (model) {\n    return this._models[model].model.schema.tableName(model);\n};\n\nBaseSQL.prototype.escapeName = function (name) {\n    throw new Error('escapeName method should be declared in adapter');\n};\n\nBaseSQL.prototype.tableEscaped = function (model) {\n    return this.escapeName(this.table(model));\n};\n\nBaseSQL.prototype.define = function (descr) {\n    if (!descr.settings) {\n        descr.settings = {};\n    }\n    this._models[descr.model.modelName] = descr;\n};\n\nBaseSQL.prototype.defineProperty = function (model, prop, params) {\n    this._models[model].properties[prop] = params;\n};\n\nBaseSQL.prototype.save = function (model, data, callback) {\n    var sql = 'UPDATE ' + this.tableEscaped(model) + ' SET ' + this.toFields(model, data) + ' WHERE ' + this.escapeName('id') + ' = ' + data.id;\n    this.query(sql, function (err) {\n        return callback && callback(err);\n    });\n};\n\nBaseSQL.prototype.exists = function (model, id, callback) {\n    id = getInstanceId(id);\n    var sql = 'SELECT 1 FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + id + ' LIMIT 1';\n\n    this.query(sql, function (err, data) {\n        if (err) {\n            return callback(err);\n        }\n        return callback && callback(null, data.length === 1);\n    });\n};\n\nBaseSQL.prototype.findById = function findById(model, id, callback) {\n    id = getInstanceId(id);\n    var self = this;\n    var sql = 'SELECT * FROM ' +\n        self.tableEscaped(model) + ' WHERE ' +\n        self.escapeName('id') + ' = ' + id + ' LIMIT 1';\n\n    self.query(sql, function (err, data) {\n        if (data && data.length === 1) {\n            data[0].id = id;\n        } else {\n            data = [null];\n        }\n        return callback && callback(err, self.fromDatabase(model, data[0]));\n    }.bind(self));\n};\n\nBaseSQL.prototype.remove = function remove(model, cond, callback) {\n    var self = this, sql = 'DELETE FROM ' + this.tableEscaped(model) + ' ';\n    if (!cond) {\n        cond = {};\n    }\n    if (cond.where) {\n        sql += self.buildWhere(cond.where, self, model);\n        self.command(sql, function (err) {\n            return callback && callback(err);\n        });\n    } else {\n        return callback && callback('Undefined cond.where');\n    }\n};\n\nBaseSQL.prototype.destroy = function destroy(model, id, callback) {\n    var sql = 'DELETE FROM ' +\n        this.tableEscaped(model) + ' WHERE ' + this.escapeName('id') + ' = ' + getInstanceId(id);\n    this.command(sql, function (err) {\n        return callback && callback(err);\n    });\n};\n\nBaseSQL.prototype.destroyAll = function destroyAll(model, callback) {\n    this.command('DELETE FROM ' + this.tableEscaped(model), function (err) {\n        if (err) {\n            return callback && callback(err, []);\n        }\n        return callback && callback(err, []);\n    }.bind(this));\n};\n\nBaseSQL.prototype.count = function count(model, callback, cond) {\n    var self = this, sql = 'SELECT count(*) as cnt FROM ' + self.tableEscaped(model) + ' ';\n    if (cond && cond.where) {\n        sql += self.buildWhere(cond.where, self, model);\n    }\n    self.queryOne(sql, function (err, res) {\n        if (err) {\n            return callback && callback(err);\n        }\n        var cnt = parseInt(res && res.cnt || 0);\n        return callback && callback(err, cnt);\n    });\n};\n\nBaseSQL.prototype.updateAttributes = function updateAttrs(model, id, data, cb) {\n    data.id = getInstanceId(id);\n    this.save(model, data, cb);\n};\n\nBaseSQL.prototype.disconnect = function disconnect() {\n    this.client.end();\n};\n/**\n * Re create existing database tables.\n * @param {Function} cb\n */\nBaseSQL.prototype.automigrate = function (cb) {\n    var self = this;\n    var wait = 0;\n\n    Object.keys(this._models).forEach(function (model) {\n        wait += 1;\n        self.dropTable(model, function (err) {\n            if (err) {\n                console.log(err);\n            }\n            self.createTable(model, function (err) {\n                if (err) {\n                    console.log(err);\n                }\n                return done && done();\n            });\n        });\n    });\n    if (wait === 0) {\n        cb();\n    }\n    function done() {\n        if (--wait === 0 && cb) {\n            cb();\n        }\n    }\n};\n\nBaseSQL.prototype.dropTable = function (model, cb) {\n    this.command('DROP TABLE IF EXISTS ' + this.tableEscaped(model), cb);\n};\n\nBaseSQL.prototype.createTable = function (model, indexes, cb) {\n    var self = this, m = self._models[model];\n    if ('function' === typeof indexes) {\n        cb = indexes;\n    }\n    var sql = 'CREATE TABLE ' + self.tableEscaped(model) +\n        ' (\\n  ' + self.propertiesSQL(model) + '\\n)';\n    if (self.name === 'mysql') {\n        sql += ' CHARSET=utf8;';\n    } else if (self.name === 'pg') {\n        // TODO\n        // sql = 'PRAGMA encoding = \"UTF-8\"; ' + sql;\n    } else if (self.name === 'cassandra') {\n        // add sorting indexes\n        if (m.settings.orderBy && m.settings.orderBy.columns) {\n            var oda = m.settings.orderBy;\n            var odd = oda.direction ? oda.direction.toUpperCase() : 'ASC';\n            sql += ' WITH CLUSTERING ORDER BY (' + oda.columns + ' ' + odd + ')';\n        }\n    }\n\n    try {\n        self.command(sql, function (err) {\n            if (err) {\n                // console.log('ERROR CREATE TABLE 1: ', model, sql, err);\n            }\n            //  || self.name === 'cassandra'\n            if (self.name === 'sqlite3' || self.name === 'mysql') {\n                self.createIndexes(model, self._models[model], cb);\n            } else {\n                return cb && cb();\n            }\n        });\n    } catch (err) {\n        // console.log('ERROR CREATE TABLE 2: ', model, sql, err);\n        return cb && cb();\n    }\n};\n\n/**\n * Normalize id\n *\n * @param {Mixed} id\n */\nfunction getInstanceId(id) {\n    if (typeof id === 'object' && id.constructor === Array) {\n        id = id[0];\n    }\n    return id;\n}\n","/home/travis/build/npmtest/node-npmtest-caminte/node_modules/caminte/lib/solr.js":"/**\n * Created by Alex on 5/24/2014.\n */\n\nexports.toSolr = function toSolr(params) {\n    params = params ? params : {};\n\n    Object.keys(params).forEach(function(key){\n        console.log(key);\n    });\n\n    try {\n\n    } catch (e) {\n        // console.log(e)\n\n    }\n};\n\nexports.fromSolr = function fromSolr(str) {\n\n};\n\nexports.__applyFilter = function(filter) {\n    var self = this;\n    if (typeof filter.where === 'function') {\n        return filter.where;\n    }\n    var keys = Object.keys(filter.where);\n    return function(obj) {\n        var pass = [];\n        keys.forEach(function(key) {\n            if (typeof filter.where[key] === 'object' && !filter.where[key].getTime) {\n                pass.push(self.parseCond(obj[key], filter.where[key]));\n            } else {\n                pass.push(key + ':' + filter.where[key]);\n            }\n        });\n        return pass;\n    };\n};\n\nexports.__parseCond = function(val, conds) {\n    var outs = false;\n    Object.keys(conds).forEach(function(condType) {\n        switch (condType) {\n            case 'gt':\n                outs = val > conds[condType] ? true : false;\n                break;\n            case 'gte':\n                outs = val >= conds[condType] ? true : false;\n                break;\n            case 'lt':\n                outs = val < conds[condType] ? true : false;\n                break;\n            case 'lte':\n                outs = val <= conds[condType] ? true : false;\n                break;\n            case 'between':\n                // need\n                outs = val !== conds[condType] ? true : false;\n                break;\n            case 'inq':\n            case 'in':\n                conds[condType].forEach(function(cval) {\n                    if (val === cval) {\n                        outs = true;\n                    }\n                });\n                break;\n            case 'nin':\n                conds[condType].forEach(function(cval) {\n                    if (val === cval) {\n                        outs = false;\n                    }\n                });\n                break;\n            case 'neq':\n            case 'ne':\n                outs = val !== conds[condType] ? true : false;\n                break;\n            case 'regex':\n            case 'like':\n                outs = new RegExp(conds[condType]).test(val);\n                break;\n            case 'nlike':\n                outs = !new RegExp(conds[condType]).test(val);\n                break;\n            default:\n                outs = val === conds[condType] ? true : false;\n                break;\n        }\n    });\n    return outs;\n};"}